%!PS-Adobe-2.0
%%Creator: dvips(k) 5.992 Copyright 2012 Radical Eye Software
%%Title: new-member-manual.dvi
%%CreationDate: Thu Nov  1 15:46:41 2012
%%Pages: 18
%%PageOrder: Ascend
%%BoundingBox: 0 0 420 596
%%DocumentFonts: DejaVuSans-Bold DejaVuSans-Oblique DejaVuSerif-Italic
%%+ DejaVuSerif DejaVuSerif-Bold CMSY10
%%DocumentPaperSizes: a5
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -P pdf -o /tmp/new-member-manual_tmp1.ps
%+ new-member-manual.dvi
%DVIPSParameters: dpi=8000
%DVIPSSource:  TeX output 2012.11.01:1546
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: alt-rule.pro 0 0
%!
% Patch by TVZ
% Makes dvips files draw rules with stroke rather than fill.
% Makes narrow rules more predictable at low resolutions
% after distilling to PDF.
% May have unknown consequences for very thick rules.
% Tested only with dvips 5.85(k).
TeXDict begin
/QV {
  gsave newpath /ruleY X /ruleX X
  Rx Ry gt
  { ruleX ruleY Ry 2 div sub moveto Rx 0 rlineto Ry }
  { ruleX Rx 2 div add ruleY moveto 0 Ry neg rlineto Rx }
  ifelse
  setlinewidth 0 setlinecap stroke grestore
} bind def
end

%%EndProcSet
%%BeginProcSet: dejavusans_ot1.enc 0 0
% THIS FILE WAS AUTOMATICALLY GENERATED -- DO NOT EDIT

%%AutoEnc_erxmsn2dewfhvd5ktdkymdjaed
% Encoding created by otftotfm on Wed Nov  2 22:50:43 2011
% Command line follows encoding
/AutoEnc_erxmsn2dewfhvd5ktdkymdjaed [
%00
  /Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon
  /Phi /Psi /uni2126 /uniFB00 /fi /fl /uniFB03 /uniFB04
%10
  /dotlessi /dotlessj /grave /acute /caron /breve /macron /ring
  /cedilla /germandbls /ae /oe /oslash /AE /OE /Oslash
%20
  /space /exclam /quotedblright /numbersign /dollar /percent /ampersand /quoteright
  /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash
%30
  /zero /one /two /three /four /five /six /seven
  /eight /nine /colon /semicolon /exclamdown /equal /questiondown /question
%40
  /at /A /B /C /D /E /F /G
  /H /I /J /K /L /M /N /O
%50
  /P /Q /R /S /T /U /V /W
  /X /Y /Z /bracketleft /quotedblleft /bracketright /circumflex /dotaccent
%60
  /quoteleft /a /b /c /d /e /f /g
  /h /i /j /k /l /m /n /o
%70
  /p /q /r /s /t /u /v /w
  /x /y /z /endash /emdash /hungarumlaut /tilde /dieresis
%80
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%90
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%A0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%B0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%C0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%D0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%E0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%F0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
] def
% Command line: 'otftotfm --encoding=fontools_ot1 --pl
% --map-file=DejaVuSans.map --no-updmap --no-type1 --coding-scheme=TEX TEXT
% --feature=kern DejaVuSans-Bold.ttf DejaVuSans-Bold-tlf-ot1'

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 647 2012-02-12 15:03:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.12, 2012/02/12
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def

    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 594 2011-10-31 18:13:18Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.02, 2012/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 130 2009-08-27 08:55:03Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-barcode.pro 0 0
%!PS-Adobe-2.0
%%Creator: Terry Burton
%%DocumentPaperSizes: a4
%%EndComments

% Barcode Writer in Pure PostScript - Version 2011-03-09
% http://www.terryburton.co.uk/barcodewriter/
%
% Copyright (c) 2004-2011 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% Uncomment this next line to allow these named resource
% definitions to remain resident within a printer's
% PostScript virtual machine so that the barcode generation
% capability persists between jobs.

% serverdict begin 0 exitserver 

% --BEGIN TEMPLATE--

% --BEGIN PREAMBLE--
currentglobal
true setglobal
/Generic /Category findresource
dup length 1 add dict copy
dup /InstanceType /packedarraytype put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
% --END PREAMBLE--

% --BEGIN RENDERER renlinear--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renlinear {

    20 dict begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div x add def            % Centre of the bar = x + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add maxh gt {/maxh h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        dup -1 ne {
            aload pop newpath setlinewidth moveto 0 exch rlineto stroke
        } {
            pop
        } ifelse
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /f () def
            txt {
                {} forall
                2 copy s ne exch f ne or {
                    2 copy /s exch def /f exch def            
                    exch findfont exch scalefont setfont          
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont findfont textsize scalefont setfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /color (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /color color cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Extend bitmap horizontally to an 8-bit boundary
    /pixx8 pixx 8 div ceiling cvi 8 mul def
    /pixs8 [ pixx8 pixy mul {0} repeat ] def
    0 1 pixy 1 sub {
        /i exch def
        pixs8 pixx8 i mul pixs pixx i mul pixx getinterval putinterval
    } for
    /pixs pixs8 def

    % Convert bitmap into 8-bit sample string
    /imgstr pixs length 8 idiv string def
    0 1 pixs length 1 sub {
        /i exch def
        imgstr i 8 idiv 2 copy get 2 7 i 8 mod sub exp cvi pixs i get mul add put
    } for

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    gsave
    currentpoint translate
    72 width mul 72 height mul scale
    .0001 .0001 moveto .9999 .0001 lineto .9999 .9999 lineto .0001 .9999 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    color (unset) ne { color setanycolor } if
    pixx pixy true [ pixx 0 0 pixy neg 0 pixy ] {imgstr} imagemask
    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall
 
    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm
    0.5 0.5774 translate

    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath fill
    } forall

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13
% --EXAM: 977147396801
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval -10 textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean13 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8
% --EXAM: 01335583
% --EXOP: includetext guardwhitespace height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean8 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    
    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Add checksum digit
    /pad 8 string def
    /checksum 0 def
    0 1 6 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval      % Add barcode to the start of the pad
    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 43 string def
    /txt 8 array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 40 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def
        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def
    } {
        /bhs [22{height}repeat] def
        /bbs [22{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 67 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardleftpos 10
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean8 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A
% --EXAM: 78858101497
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upca {

    20 dict begin

    /options exch def
    /barcode exch def             % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def 
    /addongap 12 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall    

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit to barcode
    /pad 12 string def   % Create pad one bigger than barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum checksum barchar add def
        } {
            /checksum checksum barchar 3 mul add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 59 string def
    /txt 12 array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval 96 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def
        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upca dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E
% --EXAM: 0123456
% --EXOP: includetext height=0.4
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upce {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def    

    % Ensure 0 or 1 number systems
    barcode 0 get dup 48 ne exch 49 ne and {
        /barcode () def
    } if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Derive the equivalent UPC-A for its checksum
    /upcacode (00000000000) 11 string copy def
    upcacode 0 barcode 0 get put
    barcode 6 get 48 sub 2 le {
        upcacode 1 barcode 1 2 getinterval putinterval
        upcacode 3 barcode 6 1 getinterval putinterval
        upcacode 8 barcode 3 3 getinterval putinterval
    } if
    barcode 6 get 48 sub 3 eq {
        upcacode 1 barcode 1 3 getinterval putinterval
        upcacode 9 barcode 4 2 getinterval putinterval
    } if
    barcode 6 get 48 sub 4 eq {
        upcacode 1 barcode 1 4 getinterval putinterval
        upcacode 10 barcode 5 1 getinterval putinterval
    } if
    barcode 6 get 48 sub 5 ge {
        upcacode 1 barcode 1 5 getinterval putinterval
        upcacode 10 barcode 6 1 getinterval putinterval
    } if
    /checksum 0 def
    0 1 10 {
       /i exch def
       /barchar upcacode i get 48 sub def
       i 2 mod 0 ne {
           /checksum checksum barchar add def
       } {
           /checksum checksum barchar 3 mul add def
       } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    /pad 8 string def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad
    /barcode pad def
    /txt 8 array def
    txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps checksum get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs 33 string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 11 add textyoffset textfont textsize 2 sub] put

    % Put the end character
    sbs 27 encs 11 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height height] def
        /bbs [0 0 12{.075}repeat 0 0 0] def
    } {
        /bhs [17{height}repeat] def
        /bbs [17{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 51 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upce dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upce--

% --BEGIN ENCODER isbn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISBN
% --EXAM: 978-1-56592-479 54495
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/isbn {

    20 dict begin

    /options exch def      % We are given an options string
    /isbntxt exch def      % We are given the isbn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISBN text
    /isbnfont /Courier def
    /isbnsize 9 def
    /isbnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /isbnfont isbnfont cvlit def
    /isbnsize isbnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    isbnpos (unset) eq {
        /isbnpos height 72 mul 3 add def
    } {
        /isbnpos isbnpos cvr def
    } ifelse

    % Split off the addon
    isbntxt ( ) search {
        /isbntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Convert ISBN-10 to ISBN-13
    legacy not isbntxt length 13 le and {
        /pad isbntxt length 4 add string def
        pad 0 (978-) putinterval
        pad 4 isbntxt putinterval
        /isbntxt pad def
    } if

    % Read the digits from isbntxt and calculate checksums
    /isbn 13 string def
    /checksum10 0 def
    /checksum13 0 def
    /i 0 def /n 0 def
    { % loop
        /isbnchar isbntxt i get 48 sub def
        isbnchar -3 ne {     % Ignore dashes
            isbn n isbnchar 48 add put
            n 9 lt {
                /checksum10 checksum10 10 n sub isbnchar mul add def
            } if
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum13 isbnchar checksum13 add def
                } {
                    /checksum13 isbnchar 3 mul checksum13 add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i isbntxt length eq {exit} if
    } loop

    % Add the ISBN header to the isbntxt
    n 9 eq n 10 eq or {
        /checksum 11 checksum10 11 mod sub 11 mod def
        /isbn isbn 0 9 getinterval def
        /pad 18 string def
    } {
        /checksum 10 checksum13 10 mod sub 10 mod def
        /isbn isbn 0 12 getinterval def
        /pad 22 string def
    } ifelse
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval  % Add isbntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    checksum 10 eq {
        pad pad length 1 sub checksum 78 add put  % Check digit for 10 is X
    } {
        pad pad length 1 sub checksum 48 add put  % Put check digit
    } ifelse
    /isbntxt pad def

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISBN text
    includetext {
        isbn length 9 eq {
            /isbnxpos -1 def
        } {
            /isbnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbnxpos isbnpos isbnfont isbnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbnxpos isbnpos isbnfont isbnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/isbn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER isbn--

% --BEGIN ENCODER ismn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISMN
% --EXAM: 979-0-2600-0043
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/ismn {

    20 dict begin

    /options exch def      % We are given an options string
    /ismntxt exch def      % We are given the ismn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISMN text
    /ismnfont /Courier def
    /ismnsize 9 def
    /ismnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /ismnfont ismnfont cvlit def
    /ismnsize ismnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    ismnpos (unset) eq {
        /ismnpos height 72 mul 3 add def
    } {
        /ismnpos ismnpos cvr def
    } ifelse
   
    % Split off the addon
    ismntxt ( ) search {
        /ismntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Convert old ISMN to ISMN-13
    /legacytxt () def
    ismntxt 0 1 getinterval (M) eq ismntxt length 13 le and {
        /legacytxt ismntxt def
        /pad ismntxt length 4 add string def
        pad 0 (979-0-) putinterval
        pad 6 ismntxt 2 ismntxt length 2 sub getinterval putinterval
        /ismntxt pad def
    } if

    % Read the digits from ismntxt and calculate checksums
    /ismn 13 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /ismnchar ismntxt i get 48 sub def
        ismnchar -3 ne {           % Ignore dashes
            ismn n ismnchar 48 add put
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum ismnchar checksum add def
                } {
                    /checksum ismnchar 3 mul checksum add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i ismntxt length eq {exit} if
    } loop
    /checksum 10 checksum 10 mod sub 10 mod def

    % Add the ISMN header to the ismntxt
    legacy legacytxt () ne and {
        /ismntxt legacytxt def
        /pad 18 string def
    } {
        /pad 22 string def
    } ifelse
    pad 0 (ISMN ) putinterval
    pad 5 ismntxt putinterval  % Add ismntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    pad pad length 1 sub checksum 48 add put  % Put check digit
    /ismntxt pad def

    % Convert ISMN digits to EAN-13
    /barcode ismn 0 12 getinterval def 

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISMN text
    includetext {
        ismntxt length 18 eq {
            /ismnxpos -1 def
        } {
            /ismnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [ismntxt ismnxpos ismnpos ismnfont ismnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [ismntxt ismnxpos ismnpos ismnfont ismnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/ismn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ismn--

% --BEGIN ENCODER issn--
% --REQUIRES ean13--
% --SUGGESTS ean2 ean5--
% --DESC: ISSN
% --EXAM: 0317-8471 00 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/issn {

    20 dict begin

    /options exch def      % We are given an options string
    /issntxt exch def      % We are given the issn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISSN text
    /issnfont /Courier def
    /issnsize 9 def
    /issnpos (unset) def
    /height 1 def
    /addongap 12 def   

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /issnfont issnfont cvlit def
    /issnsize issnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    issnpos (unset) eq {
        /issnpos height 72 mul 3 add def
    } {
        /issnpos issnpos cvr def
    } ifelse
   
    % Split off the ISSN
    issntxt ( ) search {
        /issntxt exch def
        pop
        /seqvar exch def
    } if

    % Split off the sequence variant and 2 digit addon
    seqvar ( ) search {
        /seqvar exch def
        pop
        2 string dup exch 0 4 -1 roll putinterval /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Read the digits from issntxt and calculate checksums
    /issn 8 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /issnchar issntxt i get 48 sub def
        issnchar -3 ne {           % Ignore dashes
            issn n issnchar 48 add put
            n 7 lt {
                /checksum checksum issnchar 8 n sub mul add def
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i issntxt length eq {exit} if
    } loop
    /checksum 11 checksum 11 mod sub 11 mod def

    % Add the ISSN header to the issntxt
    /pad 14 string def
    pad 0 (ISSN ) putinterval
    pad 5 issntxt putinterval  % Add issntxt to the pad

    % Add checksum digit
    pad 13 checksum 48 add dup 58 eq {pop 88} if put  % Put check digit
    /issntxt pad def

    % Convert ISSN digits to EAN-13
    /barcode issn 0 7 getinterval def 

    % Append the sequence variant
    /barcode 12 string def
    barcode 0 (977) putinterval
    barcode 3 issn putinterval
    barcode 10 seqvar putinterval

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISSN text
    includetext {
        /issnxpos 10 def
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [issntxt issnxpos issnpos issnfont issnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [issntxt issnxpos issnpos issnfont issnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/issn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER issn--

% --BEGIN ENCODER code128--
% --DESC: Code 128
% --EXAM: Count01234567^FNC2!
% --EXOP: includetext parsefnc
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code128 {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /sta  -1 def  /stb  -2 def  /stc  -3 def 
    /swa  -4 def  /swb  -5 def  /swc  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def 
    /fn4 -10 def  /sft -11 def  /stp -12 def
    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    % Include pseudo characters for GS1-128 Composite linkage identifiers
    seta lka seta swb get put  seta lkc seta swc get put
    setb lka setb swc get put  setb lkc setb swa get put
    setc lka setc swa get put  setc lkc setc swb get put

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
            (LNKA) lka
            (LNKC) lkc
        >> def

        % Convert input into bytes accounting for FNC and LNK characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
        
        /cws barcode length 2 mul 3 add array def

        % Select start character
        /j 0 def
        msglen 0 gt {0 numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                stb enca
                /cset (setb) def
                exit
            } if
            msglen 2 eq nums 2 eq and {
                stc enca
                /cset (setc) def
                exit
            } if
            nums 4 ge {
                stc enca
                /cset (setc) def
                exit
            } if
            0 abeforeb { 
                sta enca
                /cset (seta) def
                exit 
            } if 
            stb enca
            /cset (setb) def
            exit
        } loop

        % Main encoding loop
        /i 0 def {  
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } ifelse
                } if
                cset (setb) eq msg i get anotb and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    exit
                } if
                cset (seta) eq msg i get bnota and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    exit
                } if
                cset (setc) eq nums 2 lt and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    exit
                } if
        
                % No switches or latches so encode
                cset (seta) eq {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if
         
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Derive checksum and place stop character
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add seta stp get put

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Derive space bar succession
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul encs cws i get get putinterval
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code128--

% --BEGIN ENCODER gs1-128--
% --REQUIRES code128--
% --DESC: GS1-128
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 0.5 def
    /linkagea false def
    /linkagec false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 
   
    /text barcode def
 
    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the code128 data 
    /fnc1 -1 def
    /c128 [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        c128 length ai length add val length add array
        dup 0 c128 putinterval
        dup c128 length ai [ exch {} forall ] putinterval
        dup c128 length ai length add val [ exch {} forall ] putinterval
        /c128 exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            c128 length 1 add array
            dup 0 c128 putinterval
            dup c128 length fnc1 put
            /c128 exch def
        } if
    } for

    % Compose input to code128
    /barcode c128 length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i c128 length eq {exit} if
        c128 i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    linkagea linkagec or {
        barcode j linkagea {(^LNKA)} {(^LNKC)} ifelse putinterval
        /j j 5 add def
    } if
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (height) height put
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/gs1-128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128--

% --BEGIN ENCODER ean14--
% --REQUIRES code128--
% --DESC: GS1-14
% --EXAM: (01)04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/ean14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 17 eq exch 18 eq or 
    barcode 0 4 getinterval (\(01\)) eq and {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        18 string
        dup 0 barcode 0 17 getinterval putinterval
        dup 17 checksum 48 add put
        /barcode exch def
        /gtin barcode 4 14 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 21 string def
    barcode 0 (^FNC101) putinterval
    barcode 7 gtin putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/ean14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean14--

% --BEGIN ENCODER sscc18--
% --REQUIRES code128--
% --DESC: SSCC-18
% --EXAM: (00)006141411234567890
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/sscc18 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 21 eq exch 22 eq or 
    barcode 0 4 getinterval (\(00\)) eq and {
        /checksum 0 def
        0 1 16 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        22 string
        dup 0 barcode 0 21 getinterval putinterval
        dup 21 checksum 48 add put
        /barcode exch def
        /sscc barcode 4 18 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 25 string def
    barcode 0 (^FNC100) putinterval
    barcode 7 sscc putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/sscc18 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER sscc18--

% --BEGIN ENCODER code39--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /hidestars false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*) def

    /barlen barcode length def  % Length of the code

    includecheck {
        /sbs barlen 10 mul 30 add string def
        /txt barlen 3 add array def
    } {
        /sbs barlen 10 mul 20 add string def
        /txt barlen 2 add array def
    } ifelse

    /checksum 0 def

    % Put the start character
    sbs 0 encs 43 get putinterval
    hidestars not {
        txt 0 [(*) 0 textyoffset textfont textsize] put
    } {
        txt 0 [() 0 textyoffset textfont textsize] put
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs i 10 mul 10 add enc putinterval  % Put encoded digit into sbs
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put
        /checksum checksum indx add def
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum checksum 43 mod def
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        hidestars not {
            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        hidestars not {
            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } ifelse
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39--

% --BEGIN ENCODER code39ext--
% --REQUIRES code39--
% --DESC: Code 39 Extended
% --EXAM: Code39 Ext!
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code39ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (%U) ($A) ($B) ($C) ($D) ($E) ($F) ($G) ($H) ($I) ($J) ($K) ($L) ($M) ($N) ($O)
      ($P) ($Q) ($R) ($S) ($T) ($U) ($V) ($W) ($X) ($Y) ($Z) (%A) (%B) (%C) (%D) (%E)
      ( )  (/A) (/B) (/C) (/D) (/E) (/F) (/G) (/H) (/I) (/J) (/K) (/L) (-)  (.)  (/O)
      (0)  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (/Z) (%F) (%G) (%H) (%I) (%J)
      (%V) (A)  (B)  (C)  (D)  (E)  (F)  (G)  (H)  (I)  (J)  (K)  (L)  (M)  (N)  (O)
      (P)  (Q)  (R)  (S)  (T)  (U)  (V)  (W)  (X)  (Y)  (Z)  (%K) (%L) (%M) (%N) (%O)
      (%W) (+A) (+B) (+C) (+D) (+E) (+F) (+G) (+H) (+I) (+J) (+K) (+L) (+M) (+N) (+O)
      (+P) (+Q) (+R) (+S) (+T) (+U) (+V) (+W) (+X) (+Y) (+Z) (%P) (%Q) (%R) (%S) (%T)
    ] def

    /newcode barlen 2 mul string def
    /newtext barlen 2 mul string def
    /j 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        newcode j extchar putinterval
        newtext j barcode i get put
        extchar length 1 ne {newtext j 1 add ( ) putinterval} if
        /j j extchar length add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 j getinterval def

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args newcode options //code39 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i 1 add get def
            txtentry 0 newtext i 1 getinterval put
            txt i 1 add txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code39ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39ext--

% --BEGIN ENCODER code32--
% --REQUIRES code39--
% --DESC: Italian PharmaCode
% --EXAM: 01234567
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code32 {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string

    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    /text 10 string def
    text 0 barcode 0 8 getinterval putinterval

    % calculate check digit
    text 8 0
    0 1 7 {
        dup text exch get 48 sub exch 1 and 1 add mul dup 9 gt {9 sub} if add
    } for
    10 mod 48 add put

    % convert number from base10 to base32
    /val text cvi 32 barcode cvrs def
    /barcode 6 string def
    0 1 5 {barcode exch 48 put} for
    barcode 6 val length sub val putinterval

    % convert base32 number to specified character set
    0 1 5 {
        dup barcode exch get
        dup (AEIO) {ge {1 add} if dup} forall pop
        barcode 3 1 roll put
    } for

    % format HRI
    text 1 text 0 9 getinterval putinterval
    text 0 65 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code32 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code32--

% --BEGIN ENCODER pzn--
% --REQUIRES code39--
% --DESC: Pharmazentralnummer (PZN)
% --EXAM: 123456
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/pzn {

    20 dict begin
 
    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string
 
    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def
    /height height cvr def
 
    /text 13 string def
    text 0 barcode 0 6 getinterval putinterval
 
    % calculate check digit
    text 6 0
    0 1 5 {
        dup text exch get 48 sub exch 2 add mul add
    } for
    11 mod 48 add put
 
    /barcode 8 string def
    barcode 1 text 0 7 getinterval putinterval
    barcode 0 45 put
 
    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def
 
    % format HRI
    text 6 text 0 7 getinterval putinterval
    text 0 (PZN - ) putinterval
 
    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end
 
} bind def
/pzn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pzn--

% --BEGIN ENCODER code93--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code93 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parsefnc false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def

    % Special function characters
    /sft1 -1 def  /sft2 -2 def  /sft3 -3 def  /sft4 -4 def
    /fncvals <<
        (SFT$) sft1
        (SFT%) sft2
        (SFT/) sft3
        (SFT+) sft4
    >> def

    % Convert input into bytes accounting for shift characters 
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    includecheck {
        /sbs msglen 6 mul 25 add string def
    } {
        /sbs msglen 6 mul 13 add string def
    } ifelse
    /txt msglen array def

    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def
    0 1 msglen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        msg i get dup 0 lt { 
            42 exch sub /indx exch def
            /char ( ) def
        } {
            1 string dup 0 4 -1 roll put /char exch def
            barchars char search
            pop                                  % Discard true leaving pre
            length /indx exch def                % indx is the length of pre
            pop pop                              % Discard seek and post
        } ifelse
        /enc encs indx get def                   % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval        % Put encoded digit into sbs
        txt i [char i 9 mul 9 add textyoffset textfont textsize] put
        /checksum1 checksum1 msglen i sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 msglen i sub 15 mod 1 add indx mul add def
    } for

    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs msglen 6 mul 6 add encs checksum1 get putinterval
        sbs msglen 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs msglen 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs msglen 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code93 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93--

% --BEGIN ENCODER code93ext--
% --REQUIRES code93--
% --DESC: Code 93 Extended
% --EXAM: Code93 Ext!
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code93 dup /uk.co.terryburton.bwipp findresource put
begin
/code93ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (^SFT%U) (^SFT$A) (^SFT$B) (^SFT$C) (^SFT$D) (^SFT$E) (^SFT$F) (^SFT$G) 
      (^SFT$H) (^SFT$I) (^SFT$J) (^SFT$K) (^SFT$L) (^SFT$M) (^SFT$N) (^SFT$O)
      (^SFT$P) (^SFT$Q) (^SFT$R) (^SFT$S) (^SFT$T) (^SFT$U) (^SFT$V) (^SFT$W)
      (^SFT$X) (^SFT$Y) (^SFT$Z) (^SFT%A) (^SFT%B) (^SFT%C) (^SFT%D) (^SFT%E)
      ( )      (^SFT/A) (^SFT/B) (^SFT/C) (^SFT/D) (^SFT/E) (^SFT/F) (^SFT/G)
      (^SFT/H) (^SFT/I) (^SFT/J) (^SFT/K) (^SFT/L) (-)      (.)      (^SFT/O)
      (0)      (1)      (2)      (3)      (4)      (5)      (6)      (7)
      (8)      (9)      (^SFT/Z) (^SFT%F) (^SFT%G) (^SFT%H) (^SFT%I) (^SFT%J)
      (^SFT%V) (A)      (B)      (C)      (D)      (E)      (F)      (G)
      (H)      (I)      (J)      (K)      (L)      (M)      (N)      (O)
      (P)      (Q)      (R)      (S)      (T)      (U)      (V)      (W)
      (X)      (Y)      (Z)      (^SFT%K) (^SFT%L) (^SFT%M) (^SFT%N) (^SFT%O)
      (^SFT%W) (^SFT+A) (^SFT+B) (^SFT+C) (^SFT+D) (^SFT+E) (^SFT+F) (^SFT+G)
      (^SFT+H) (^SFT+I) (^SFT+J) (^SFT+K) (^SFT+L) (^SFT+M) (^SFT+N) (^SFT+O)
      (^SFT+P) (^SFT+Q) (^SFT+R) (^SFT+S) (^SFT+T) (^SFT+U) (^SFT+V) (^SFT+W)
      (^SFT+X) (^SFT+Y) (^SFT+Z) (^SFT%P) (^SFT%Q) (^SFT%R) (^SFT%S) (^SFT%T)
    ] def

    /newcode barlen 6 mul string def
    /newtext barlen 6 mul string def
    /j 0 def /k 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        /extlen extchar length def
        newcode j extchar putinterval
        newtext k barcode i get put
        extlen 1 ne {newtext k 1 add ( ) putinterval} if
        /j j extlen add def
        /k k extlen 1 eq {1} {2} ifelse add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 k getinterval def

    % Get the result of encoding with code93
    options (dontdraw) true put
    options (parsefnc) true put
    /args newcode options //code93 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i get def
            txtentry 0 newtext i 1 getinterval put
            txt i txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code93ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93ext--

% --BEGIN ENCODER interleaved2of5--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 2401234567
% --EXOP: height=0.5 includecheck includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/interleaved2of5 {

    20 dict begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /barcode exch def               % We are given a barcode string

    /dontdraw false def
    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11221) (21112) (12112) (22111) (11212)
      (21211) (12211) (11122) (21121) (12121)
      (1111)  (2111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /barratio 2
    /spaceratio 2
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/interleaved2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER itf14--
% --REQUIRES interleaved2of5--
% --DESC: ITF-14
% --EXAM: 04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/itf14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /gtin barcode 0 13 getinterval def
    } if

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (showborder) true put
    options (borderwidth) 4 put
    options (borderleft) 15 put
    options (borderright) 15 put
    options (height) 0.5 put
    options (includecheck) true put
    options (includecheckintext) true put
    options (textyoffset) -10 put
    /args gtin options //interleaved2of5 exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/itf14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER itf14--

% --BEGIN ENCODER identcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Identcode
% --EXAM: 563102430313
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/identcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 11 eq exch 12 eq or {
        /checksum 0 def
        0 1 10 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        12 string
        dup 0 barcode 0 11 getinterval putinterval
        dup 11 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (  .       .     ) 16 string copy def
    text  0 barcode  0 2 getinterval putinterval
    text  3 barcode  2 3 getinterval putinterval
    text  7 barcode  5 3 getinterval putinterval
    text 11 barcode  8 3 getinterval putinterval
    text 15 barcode 11 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/identcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER identcode--

% --BEGIN ENCODER leitcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Leitcode
% --EXAM: 21348075016401
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/leitcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        14 string
        dup 0 barcode 0 13 getinterval putinterval
        dup 13 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (     .   .   .    ) 18 string copy def
    text  0 barcode  0 5 getinterval putinterval
    text  6 barcode  5 3 getinterval putinterval
    text 10 barcode  8 3 getinterval putinterval
    text 14 barcode 11 2 getinterval putinterval
    text 17 barcode 13 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/leitcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER leitcode--

% --BEGIN ENCODER databaromni--
% --DESC: GS1 DataBar Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromni {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 33 72 div def
    /linkage false def
    /format (omni) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
  
    format (truncated) eq {/height 13 72 div def} if
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 4 getinterval (\(01\)) eq {
            /binval [ 
                linkage {1} {0} ifelse
                barcode 4 13 getinterval {48 sub} forall
            ] def
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
     
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def
    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def
    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def
    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    % Stacked format
    format (omni) eq format (truncated) eq or {  % linear

        /sbs [
            1 d1w {} forall checklt {} forall d2w {} forall 
            d4w {} forall checkrt {} forall d3w {} forall 1 1
        ] def
        
        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /txt txt
        /textxalign (center)
        /opt options
        >>
    
        dontdraw not //renlinear if

    } {  % 2D - stacked or stackedomni

        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def
        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def 
        0 2 24 {
            /i exch def
            top i get {0} repeat
            top i 1 add get {1} repeat
        } for
        50 array astore /top exch def 
        0 2 24 {
            /i exch def
            bot i get {1} repeat
            bot i 1 add get {0} repeat
        } for
        50 array astore /bot exch def

        % Stacked
        format (stacked) eq {
            /sep [ 50 {0} repeat ] def
            4 1 45 {
                /i exch def
                top i get bot i get eq {
                    sep i 1 top i get sub put
                } {
                    sep i 1 sep i 1 sub get sub put
                } ifelse
            } for
            /pixs [
                5 {top aload pop} repeat
                sep aload pop
                7 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Stacked omnidirectional
        format (stackedomni) eq {
            /sep1 [ top {1 exch sub} forall ] def
            sep1 0  [ 0 0 0 0 ] putinterval
            sep1 46 [ 0 0 0 0 ] putinterval
            18 1 30 {
                /i exch def
                top i get 0 eq {
                    top i 1 sub get 1 eq {
                        1
                    } {
                        sep1 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep1 exch i exch put
            } for
            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def
            /sep3 [ bot {1 exch sub} forall ] def
            sep3 0  [ 0 0 0 0 ] putinterval
            sep3 46 [ 0 0 0 0 ] putinterval
            19 1 31 {
                /i exch def
                bot i get 0 eq {
                    bot i 1 sub get 1 eq {
                        1
                    } {
                        sep3 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep3 exch i exch put
            } for
            /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
            true 0 1 12 {dup bot exch 19 add get exch f3 exch get eq and} for {
                % Right shifted module for value 3 finder
                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
            } if
            /pixs [
                33 {top aload pop} repeat
                sep1 aload pop
                sep2 aload pop
                sep3 aload pop
                33 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Return the arguments
        <<
        /ren //renmatrix
        /pixs pixs
        /pixx 50
        /pixy pixy
        /height pixy 72 div
        /width 50 72 div
        /opt options
        >>
    
        dontdraw not //renmatrix if
     
    } ifelse
    
    end

} bind def
/databaromni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromni--

% --BEGIN ENCODER databarstacked--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stacked
    options (dontdraw) true put
    options (format) (stacked) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstacked--

% --BEGIN ENCODER databarstackedomni--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomni {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stackedomni
    options (dontdraw) true put
    options (format) (stackedomni) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstackedomni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomni--

% --BEGIN ENCODER databartruncated--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Truncated
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncated {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=truncated
    options (dontdraw) true put
    options (format) (truncated) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/databartruncated dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncated--

% --BEGIN ENCODER databarlimited--
% --DESC: GS1 DataBar Limited
% --EXAM: (01)15012345678907
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimited {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 10 72 div def
    /linkage false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 5 getinterval dup (\(01\)0) eq exch (\(01\)1) eq or {
            /binval [ 
                barcode 4 13 getinterval {48 sub} forall
            ] def
            linkage {
                /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def
                0 1 binval length 1 sub {
                    /i exch def
                    binval i binval i get linkval i get add put
                } for
            } if 
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def    
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def    
    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def

    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 320 {} for
        322 323
        326 337
    ] def
   
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 false getRSSwidths def
    /bwidths seq 21 mod  8 3 6 false getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/databarlimited dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimited--

% --BEGIN ENCODER databarexpanded--
% --DESC: GS1 DataBar Expanded
% --EXAM: (01)95012345678903(3103)000123
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpanded {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 34 72 div def
    /format (expanded) def
    /segments -1 def
    /linkage false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /segments segments cvi def

    segments -1 eq {
        /segments format (expandedstacked) eq {4} {22} ifelse def
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    {  % common exit
    
        % (01)9...(3103)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3103) eq and { 
                aival (01) get 0 1 getinterval (9) eq aival (3103) get cvi 32767 le and {
                   (0100) false exit 
                } if
            } if
        } if
    
        % (01)9...(3202)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3202) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3202) get cvi 9999 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(3203)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3203) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3203) get cvi 22767 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(310x/320x)...[(11/13/15/17)...]
        ais length dup 2 eq exch 3 eq or {
           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def
           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def
           ais length 3 eq {
               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def
           } {
               /aibad false def
           } ifelse
           ais 0 get (01) eq ai310x ai320x or and aibad not and {
               ais length 3 eq {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and 
                   aival ais 2 get get cvi 999999 le and {
                       ai310x ais 2 get (11) eq and { (0111000) false exit } if
                       ai320x ais 2 get (11) eq and { (0111001) false exit } if
                       ai310x ais 2 get (13) eq and { (0111010) false exit } if
                       ai320x ais 2 get (13) eq and { (0111011) false exit } if
                       ai310x ais 2 get (15) eq and { (0111100) false exit } if
                       ai320x ais 2 get (15) eq and { (0111101) false exit } if
                       ai310x ais 2 get (17) eq and { (0111110) false exit } if
                       ai320x ais 2 get (17) eq and { (0111111) false exit } if
                   } if
               } {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and {
                       ai310x { (0111000) false exit } if
                       ai320x { (0111001) false exit } if
                   } if
               } ifelse
           } if
        } if
    
        % (01)9...(392x)...
        ais length 2 ge {
            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai392x and {
                aival (01) get 0 1 getinterval (9) eq { (01100) true exit } if
            } if
        } if
    
        % (01)9...(393x)...
        ais length 2 ge {
            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai393x and {
                aival (01) get 0 1 getinterval (9) eq { (01101) true exit } if
            } if
        } if
    
        % (01)...
        ais 0 get (01) eq { (1) true exit } if
    
        % Freeform
        (00) true exit
    
    } loop
    /gpfallow exch def
    /method exch def
   
    /conv12to40 {
        (0000000000000000000000000000000000000000) 40 string copy
        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        exch pop
    } bind def
    
    /conv13to44 {
        (00000000000000000000000000000000000000000000) 44 string copy
        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval
    } bind def
    
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
    
    method (00) eq {
        /cdf [] def
        /gpf [] def
    } if
    
    method (1) eq {
        /cdf aival (01) get 0 13 getinterval conv13to44 def
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais ais 1 ais length 1 sub getinterval def
    } if
    
    method (0100) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 aival (3103) get cvi 15 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (0101) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        ais 1 get (3202) eq {
            aival (3202) get cvi 15 tobin
        } {
            aival (3203) get cvi 10000 add 15 tobin
        } ifelse
        cdf exch 40 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method length 7 eq {
        /cdf 76 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        6 string dup 0 ais 1 get 3 1 getinterval putinterval
        dup aival ais 1 get get 1 5 getinterval 1 exch putinterval cvi 20 tobin
        cdf exch 40 exch putinterval
        ais length 3 eq {
            aival ais 2 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
        } {
            38400
        } ifelse
        16 tobin cdf exch 60 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (01100) eq {
        /cdf 42 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    method (01101) eq {
        /cdf 52 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        cdf 42 aival ais 1 get get 0 3 getinterval cvi 10 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get dup length 3 sub 3 exch getinterval {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    % Variable length symbol field
    gpfallow {
        /vlf 2 array def
    } {
        /vlf [] def
    } ifelse
    
    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def
    
    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
    
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def
    
    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for
    
    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        dup
        12 div ceiling cvi 12 mul            % Round up to multiple of 12 
        48 2 copy lt {exch} if pop           % At least 4 symbols
        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol
            1 add 12 mul exch pop
        } {
            pop
        } ifelse 
        exch sub
    } bind def
    
    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def
   
    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 252 array def
    /i 0 def /j 0 def /mode (numeric) def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem 12 1 add method length add vlf length add cdf length add j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def
   
    % Complete the variable length field and create pad
    1 12 add method length add vlf length add cdf length add gpf length add 
    dup rembits dup array /pad exch def
    vlf length 0 ne {
        add 12 idiv
        dup 2 mod vlf exch 0 exch put
        14 le {0} {1} ifelse vlf exch 1 exch put
    } {
        pop pop
    } ifelse
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
    } if
   
    % Concatinate fields
    /binval [
        linkage {1} {0} ifelse 
        method {48 sub} forall
        vlf aload pop
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def
    /datalen binval length 12 idiv def
    
    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def

    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def
        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 sub 2 idiv get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for

    /checkweights [
        -1   -1   -1   -1   -1   -1   -1   -1   % A1L
        77   96   32   81   27   9    3    1    % A1R
        20   60   180  118  143  7    21   63   % A2L
        205  209  140  117  39   13   145  189  % A2R
        193  157  49   147  19   57   171  91   % B1L 
        132  44   85   169  197  136  186  62   % B1R
        185  133  188  142  4    12   36   108  % B2L
        50   87   29   80   97   173  128  113  % B2R
        150  28   84   41   123  158  52   156  % C1L
        166  196  206  139  187  203  138  46   % C1R
        76   17   51   153  37   111  122  155  % C2L
        146  119  110  107  106  176  129  43   % C2R
        16   48   144  10   30   90   59   177  % D1L
        164  125  112  178  200  137  116  109  % D1R
        70   210  208  202  184  130  179  115  % D2L
        190  204  68   93   31   151  191  134  % D2R
        148  22   66   198  172  94   71   2    % E1L
        40   154  192  64   162  54   18   6    % E1R
        120  149  25   75   14   42   126  167  % E2L
        175  199  207  69   23   78   26   79   % E2R
        103  98   83   38   114  131  182  124  % F1L
        159  53   88   170  127  183  61   161  % F1R
        55   165  73   8    24   72   5    15   % F2L
        89   100  174  58   160  194  135  45   % F2R
    ] def

    /checkweightseq [
       seq {16 mul checkweights exch 16 getinterval aload pop} forall
    ] dup length 8 sub 8 exch getinterval def

    /widths [
        dxw {{} forall} forall
    ] def
   
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweightseq i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def
    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def

    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for

    22 array dup dup
    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval
    /dxw exch def
    /datalen dxw length def

    % Encode row runlengths
    /rows datalen segments div ceiling cvi array def
    /numrows rows length def
    0 1 numrows 1 sub {
        /r exch def
        mark
        segments 4 mod 0 ne r 2 mod 1 eq and {0} if
        1 1
        0 1 segments 1 sub {
            /pos exch r segments mul add def
            pos datalen lt {
                dxw pos get {} forall                 
                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if
            } if
        } for
        1 1
        counttomark array astore rows exch r exch put pop
    } for

    format (expandedstacked) ne {  % Linear

        % Remove leading space
        /sbs rows 0 get dup length 1 sub 1 exch getinterval def

        /sbs [
            1
            0 1 datalen 1 sub {
                /i exch def
                dxw i get {} forall
                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            } for
            1 1
        ] def

        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /opt options
        >>

        dontdraw not //renlinear if

    } {  % expandedstacked

        /seps numrows array def
        0 1 numrows 1 sub {

            /r exch def
            /row rows r get def

            % Sample runlengths into bitmap
            mark
            0 2 row length 1 sub {
                /i exch def
                row i get {0} repeat
                i row length 1 sub lt {row i 1 add get {1} repeat} if
            } for
            counttomark array astore /row exch def pop

            % Derive the separator pattern
            /sep [ row {1 exch sub} forall ] def
            sep 0 [ 0 0 0 0 ] putinterval
            sep row length 4 sub [ 0 0 0 0 ] putinterval
            /finderpos [  % Finder pattern module positions
                19 98 row length 13 sub {} for
                68 98 row length 13 sub {} for
            ] def 
            finderpos {
                dup 14 add 1 exch {
                    /i exch def
                    row i get 0 eq {
                        row i 1 sub get 1 eq {
                            1
                        } {
                            sep i 1 sub get 0 eq {1} {0} ifelse
                        } ifelse
                    } {
                        0
                    } ifelse
                    sep exch i exch put
                } for
            } forall

            % For even segment-pair symbols reverse alternate rows
            segments 4 mod 0 eq r 2 mod 1 eq and {
                rows r get length rows 0 get length ne  % Except partial width last row
                finderpos length 2 mod 1 eq and {       % with odd finders
                    /row [ 0 row aload pop ] def
                    /sep [ 0 sep aload pop ] def
                } {
                    row length 1 sub -1 0 {row exch get} for
                    row astore pop
                    sep length 1 sub -1 0 {sep exch get} for
                    sep astore pop
                } ifelse
            } if

            rows r row put
            seps r sep put

        } for

        % Extend last row and separator to fill width of symbol
        /pixx rows 0 get length def
        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval
        rows exch numrows 1 sub exch put 
        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval
        seps exch numrows 1 sub exch put 

        % Middle separator pattern
        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def
        sep 0 [0 0 0 0] putinterval
        sep pixx 4 sub [0 0 0 0] putinterval

        % Compose the symbol
        /pixs [
            0 1 numrows 1 sub {
                /r exch def
                r 0 ne {
                    seps r get aload pop
                } if
                34 {rows r get aload pop} repeat
                r numrows 1 sub ne {
                    seps r get aload pop
                    sep aload pop
                } if
            } for
        ] def

        <<
        /ren //renmatrix
        /pixs pixs
        /pixx pixx
        /pixy pixs length pixx idiv
        /height pixs length pixx idiv 72 div
        /width pixx 72 div
        /opt options
        >>

        dontdraw not //renmatrix if

    } ifelse

    end

} bind def
/databarexpanded dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpanded--

% --BEGIN ENCODER databarexpandedstacked--
% --REQUIRES databarexpanded--
% --DESC: GS1 DataBar Expanded Stacked
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: segments=4
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databarexpanded with format=expandedstacked
    options (dontdraw) true put
    options (format) (expandedstacked) put

    /args barcode options //databarexpanded exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarexpandedstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstacked--

% --BEGIN ENCODER pharmacode--
% --DESC: Pharmaceutical Binary Code
% --EXAM: 117480
% --EXOP: showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /height 8 2.835 mul 72 div def
    /nwidth 0.5 2.835 mul def
    /wwidth 1.5 2.835 mul def
    /swidth 1.0 2.835 mul def    

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /nwidth nwidth cvr def
    /wwidth wwidth cvr def
    /swidth swidth cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Convert the integer into the paramacode string 
    /barcode barcode cvi 1 add 2 17 string cvrs def
    /barcode barcode 1 barcode length 1 sub getinterval def

    /barlen barcode length def  % Length of the code
    /sbs barlen 2 mul array def

    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (0) eq {
            sbs i 2 mul nwidth put
        } {
            sbs i 2 mul wwidth put
        } ifelse
        sbs i 2 mul 1 add swidth put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode--

% --BEGIN ENCODER pharmacode2--
% --DESC: Two-track Pharmacode
% --EXAM: 117480
% --EXOP: includetext showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode2 {

    20 dict begin

    /options exch def           % We are given an option string
    /barcode exch def           % We are given a barcode string

    /dontdraw false def
    /includetext false def      % Enable/disable text
    /height 4 def               % Height of short bars in millimetres

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /encstr 16 string def
    /bhs 16 array def
    /bbs 16 array def
    /sbs 32 array def
    /bar 1 25.4 div height mul def     % bar height (mm)
    /spc 1 25.4 div 72 mul def         % bar width & spacing (1mm)
 
    % Convert number into a base3 representation
    /i 15 def
    /val barcode cvi def
    {  % loop
        val 0 eq {exit} if
        val 3 mod dup
        [3 1 2] exch get val exch sub 3 idiv /val exch def
        encstr i [2 0 1] 4 -1 roll get put
        /i i 1 sub def
    } loop
    /encstr encstr i 1 add 15 i sub getinterval def
 
    % Generate the bar pattern
    0 1 encstr length 1 sub {
        /i exch def
        encstr i get dup
        bhs i bar [1 1 2] 5 -1 roll get mul put
        bbs i [0 bar 0] 4 -1 roll get put
    } for
     
    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs bbs
    /sbs [encstr length 2 mul {spc} repeat]
    /txt txt
    /textxalign (center)
    /textyoffset 4
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode2--

% --BEGIN ENCODER code2of5--
% --DESC: Code 25
% --EXAM: 01234567
% --EXOP: version=iata includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code2of5 {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /version (industrial) def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    << 
    /industrial
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (313111)     (31113)
        ] 
    /iata
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (1111)       (311)
        ]
    /matrix
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (311111) (31111)
        ]
    /coop
        [ (331111) (111331) (113131) (113311) (131131) (131311)
          (133111) (311131) (311311) (313111) (3131)   (133)
        ]
    /datalogic
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (1111)   (311)
        ]
    >>
    version get /encs exch def
    /cs encs 0 get length def
    /cw 0 encs 0 get {48 sub add} forall def
    /ss encs dup length 2 sub get length def
    /sw 0 encs dup length 2 sub get {48 sub add} forall def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def            % Length of the code

    includecheck {
        /sbs barlen 1 add cs mul ss add ss add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen cs mul ss add ss add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum 0 def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i cs mul ss add enc putinterval % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i cw mul sw add textyoffset textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum checksum indx add def
        } {
            /checksum checksum indx 3 mul add def
        } ifelse
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen cs mul ss add encs checksum get putinterval
        sbs barlen cs mul cs add ss add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen cw mul sw add textyoffset textfont textsize] put
        } {
            txt barlen [( ) barlen cw mul sw add textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen cs mul ss add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code2of5--

% --BEGIN ENCODER code11--
% --DESC: Code 11
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code11 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def

    /barlen barcode length def        % Length of the code

    includecheck {
        barlen 10 ge {
            /sbs barlen 6 mul 24 add string def
            /txt barlen 2 add array def
        } {
            /sbs barlen 6 mul 18 add string def
            /txt barlen 1 add array def
        } ifelse
    } {
        /sbs barlen 6 mul 12 add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 11 get putinterval

    /checksum1 0 def /checksum2 0 def
    
    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
   
    % Put the checksum and end characters
    includecheck {
        /checksum1 checksum1 11 mod def        
        barlen 10 ge {
            /checksum2 checksum2 checksum1 add 11 mod def
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
                txt barlen 1 add [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code11 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code11--

% --BEGIN ENCODER bc412--
% --DESC: BC412
% --EXAM: BC412
% --EXOP: semi includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/bc412 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /includestartstop false def
    /semi false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
   
    semi {
        /includecheck true def
        /includestartstop true def
    } if
 
    % Create an array containing the character mappings
    /encs
    [ (11111115) (13111212) (11131113) (12111213) (12121311)
      (13131111) (12111312) (11131212) (11121411) (11151111)
      (15111111) (11111511) (12131211) (13121112) (13111212)
      (11111214) (12121113) (11111313) (13111113) (11121213)
      (11141112) (11121312) (11141211) (14121111) (12121212)
      (11131311) (13121211) (12111411) (14111211) (11111412)
      (12111114) (14111112) (12141111) (11121114) (12131112)
      (12) (111)
    ] def

    % Create a string of the available characters
    /barchars (0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M) def

    /barlen barcode length def  % Length of the code

    /sbs barlen 1 add 8 mul 5 add string def
    includecheck {
        /txt barlen 1 add array def
    } {
        /txt barlen array def
    } ifelse

    % Put the start character
    includestartstop {
        sbs 0 encs 35 get putinterval
        /pos 2 def
        /txtpos 3 def
    } {
        /pos 0 def
        /txtpos 0 def
    } ifelse

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs pos enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul txtpos add textyoffset textfont textsize] put
        /checksum checksum indx add def
        /pos pos 8 add def
    } for

    % Put the checksum
    includecheck {
        /checksum checksum 35 mod def
        sbs pos encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 12 mul txtpos add textyoffset textfont textsize] put
        } {
            txt barlen [() barlen 12 mul txtpos add textyoffset textfont textsize] put
        } ifelse
        /pos pos 8 add def
    } if 

    % Put the stop character
    includestartstop { 
        sbs pos encs 36 get putinterval
        /pos pos 2 add def
    } if

    % Return the arguments
    /sbs sbs 0 pos getinterval def 
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/bc412 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER bc412--

% --BEGIN ENCODER rationalizedCodabar--
% --DESC: Rationalized Codabar
% --EXAM: A0123456789B
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/rationalizedCodabar {

    20 dict begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /barcode exch def          % We are given a barcode string

    /dontdraw false def
    /includecheck false def     % Enable/disable checkdigit
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-$:/.+ABCD) def

    /barlen barcode length def    % Length of the code

    includecheck {
        /sbs barlen 8 mul 8 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul string def
        /txt barlen array def
    } ifelse

    /checksum 0 def
    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                          % Discard true leaving pre
        length /indx exch def        % indx is the length of pre
        pop pop                      % Discard seek and post
        /enc encs indx get def       % Get the indxth encoding
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum checksum indx add def
    } for

    % Find index of last character
    barcode barlen 1 sub 1 getinterval barchars exch search
    pop                          % Discard true leaving pre
    length /indx exch def        % indx is the length of pre
    pop pop                      % Discard seek and post

    includecheck {
        % Put the checksum character
        /checksum checksum indx add def
        /checksum 16 checksum 16 mod sub 16 mod def
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } {
        % Put the end character
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/rationalizedCodabar dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --DESC: United States Postal Service Intelligent Mail
% --EXAM: 0123456709498765432101234567891
% --EXOP: barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/onecode {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.15 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def

    /barlen barcode length def
 
    % Create the human readable text
    /txtdict <<
        2 dup
        5 dup
        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup
        20 dup
        25 dup
        29 dup
    >> def
    /txt barlen 6 add array def
    /spacecnt 0 def
    0 1 barlen 1 sub {
        /i exch def
        txtdict i known {
            txt i spacecnt add [( ) 0 0 () 0] put
            /spacecnt spacecnt 1 add def
        } if
        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put
    } for
    /txt txt 0 barcode length spacecnt add getinterval def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 [
        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87 
      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776 
       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151 
      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744 
       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203 
      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912 
       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241 
      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904 
       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310 
      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664 
       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357 
      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488 
       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406 
      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784 
       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453 
      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392 
       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539 
      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536 
       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589 
      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864 
       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626 
      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440 
       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678 
      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936 
       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722 
      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680 
       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796 
      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504 
       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842 
      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240 
       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914 
      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144 
      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069 
      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924 
      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113 
      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756 
      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166 
      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308 
      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204 
      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452 
      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294 
      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292 
      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332 
      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436 
      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418 
      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164 
      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561 
      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700 
      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610 
      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116 
      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730 
      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332 
      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071 
      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714 
      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125 
      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338 
      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187 
      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850 
      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243 
      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322 
      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329 
      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498 
      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401 
      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274 
      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582 
      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698 
      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691 
      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170 
      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079 
      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870 
      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145 
      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262 
      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457 
      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142 
      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141 
      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465 
      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235 
      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769 
      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365 
      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497 
      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619 
      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745 
      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131 
      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181 
      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681 
      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496 
    ] def

    /tab213 [
         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18 
      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384 
        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130 
      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528 
       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028 
       520  272  160
    ] def

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /txt txt
    /textxalign (left)
    /textfont /Helvetica
    /textyoffset 1
    /textxoffset -0.3
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/onecode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --DESC: United States Postal Service POSTNET
% --EXAM: 01234
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/postnet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 5, 9 or 11 digits
    barlen 5 lt {
        /barlen -1 def  % Error
    } {
        barlen 11 ge {
            /barlen 11 def
        } if
        barlen 10 eq {
            /barlen 9 def
        } if
        barlen 8 le {
            /barlen 5 def
        } if
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/postnet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER postnet--

% --BEGIN ENCODER planet--
% --DESC: United States Postal Service PLANET
% --EXAM: 01234567890
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/planet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 11 or 13 digits
    barlen 11 lt {
        /barlen -1 def  % Error
    } {
        barlen 13 ge {
            /barlen 13 def
        } {
            /barlen 11 def
        } ifelse
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (22555) (55522) (55252) (55225) (52552)
      (52525) (52255) (25552) (25525) (25255)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/planet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER planet--

% --BEGIN ENCODER royalmail--
% --DESC: Royal Mail 4 State Customer Code (RM4SCC)
% --EXAM: LE28HS9Z
% --EXOP: includetext includecheckintext barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/royalmail {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def

    /barlen barcode length def
    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul 1 add enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for

    % Put the checksum character
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    /enc encs checksum get def
    encstr barlen 4 mul 1 add enc putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/royalmail dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
% --EXOP: includetext custinfoenc=character
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/auspost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (45) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) 12 string copy def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/auspost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --DESC: Royal Dutch TPG Post KIX 4-State Barcode
% --EXAM: 1231FZ13XHS
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/kix {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/kix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER kix--

% --BEGIN ENCODER japanpost--
% --DESC: Japan Post 4 State Customer Code
% --EXAM: 6540123789-A-K-Z
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/japanpost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
  
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    % 0123456789- C1C2C3C4C5C6C7C8 ST EN
    /encs
    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)
      (120) (102) (210) (012) (201) (021) (003) (333) 
      (31) (13)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /barlen barcode length def
    
    /encstr 20 1 add 3 mul 4 add string def
    /digits 20 array def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 19 get putinterval

    /checksum 0 def
    /j 0 def /i 0 def
    0 1 barlen 1 sub {
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard match and post
        indx 11 ge indx 37 lt and {          % Insert escape
            j 18 gt {exit} if                % Should fit in 20 chars
                                             % 11-20: C1 (11)
                                             % 21-30: C2 (12)
                                             % 31-36: C3 (13)
            /digit indx 1 sub 10 idiv 10 add def
            encstr j 3 mul 2 add encs digit get putinterval
            /checksum checksum digit add def
            digits j digit put
            /j j 1 add def
        } if
        j 19 gt {exit} if                    % Should fit in 20 chars
        /digit 0 def
        indx 37 eq {
            /digit 14 def                    % space (C14)
        } if
        indx 11 ge indx 37 lt and {
            /digit indx 1 sub 10 mod def
        } if
        indx 11 lt {
            /digit indx def
        } if
        encstr j 3 mul 2 add encs digit get putinterval % space
        /checksum checksum digit add def
        digits j digit put
        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put
        /j j 1 add def
    } for

    % Fill spaces (c14) at right end
    j 1 20 1 sub {
        /k exch def
        encstr k 3 mul 2 add encs 14 get putinterval
        /checksum checksum 14 add def
        digits k 14 put
    } for

    % Put the checksum character
    /checksum checksum 19 mod 19 exch sub def
    encstr 2 20 3 mul add encs checksum get putinterval

    % Put end character
    encstr 2 21 3 mul add encs 20 get putinterval
    /checkdigit ( ) def
    includecheckintext {
        /checkdigit barchars checksum 1 getinterval def
    } if
    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put

    % Put end character
    encstr 20 1 add 3 mul 2 add encs 20 get putinterval

    /bbs 21 3 mul 4 add array def
    /bhs bbs length array def
    0 1 bbs length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        /bunit 0 def
        /hunit 0 def
        enc (0) eq {
            /bunit 3 def
            /hunit 2 def
        } if
        enc (1) eq {
            /bunit 0 def
            /hunit 5 def
        } if
        enc (2) eq {
            /bunit 3 def
            /hunit 5 def
        } if
        enc (3) eq {
            /bunit 0 def
            /hunit 8 def
        } if
        bbs i bunit height mul 8 div put
        bhs i hunit height mul 8 div put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/japanpost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER japanpost--

% --BEGIN ENCODER msi--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/msi {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /checktype (mod10) def
    /badmod11 false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (12121212) (12121221) (12122112) (12122121) (12211212)
      (12211221) (12212112) (12212121) (21121212) (21121221)
      (21) (121)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code
    /txtlen barlen def

    /mod10 {
        /code exch def
        0 0 code {48 sub exch 10 mul add exch} forall pop 2 mul  
        0 {1 index 10 mod add exch 10 idiv dup 0 eq {pop exit} if exch} loop
        0 0 code {48 sub add exch} forall exch pop add
        10 mod 10 exch sub 10 mod
        code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
    } bind def

    /mod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 6 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    /ncrmod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 8 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    % Calculate checksum
    includecheck {
        checktype (mod10) eq      {barcode mod10} if
        checktype (mod1010) eq    {barcode mod10 mod10} if
        checktype (mod11) eq      {barcode mod11} if
        checktype (ncrmod11) eq   {barcode ncrmod11} if
        checktype (mod1110) eq    {barcode mod11 mod10} if
        checktype (ncrmod1110) eq {barcode ncrmod11 mod10} if
        /barcode exch def
        /barlen barcode length def
        includecheckintext {/txtlen barlen def} if
    } if

    /sbs barlen 8 mul 5 add string def
    /txt barlen array def

    % Put start character
    sbs 0 encs 10 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul 3 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs barlen 8 mul 2 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt 0 txtlen getinterval
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/msi dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --DESC: Plessey UK
% --EXAM: 01234ABCD
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/plessey {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /includecheckintext false def
    /unidirectional false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (14141414) (32141414) (14321414) (32321414)
      (14143214) (32143214) (14323214) (32323214)
      (14141432) (32141432) (14321432) (32321432)
      (14143232) (32143232) (14323232) (32323232)
      (32321432) (541412323) (323)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def

    /barlen barcode length def     % Length of the code
    unidirectional {
        /sbs barlen 8 mul 27 add string def
    } {
        /sbs barlen 8 mul 33 add string def
    } ifelse
    /txt barlen 2 add array def
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 20 mul 20 add textyoffset textfont textsize] put
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for

    % Checksum is last 8 bits of a CRC using a salt
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for

    % Calculate the value of the checksum digits
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 i exp cvi checkbits barlen 4 mul i add get mul add def
    } for

    % Put the checksum characters
    /checksum1 checkval 15 and def
    /checksum2 checkval -4 bitshift def
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } ifelse

    % Put end character
    unidirectional {
        sbs barlen 8 mul 24 add encs 18 get putinterval
    } {
        sbs barlen 8 mul 24 add encs 17 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/plessey dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER plessey--

% --BEGIN ENCODER telepen--
% --DESC: Telepen
% --EXAM: 123456
% --EXOP: numeric includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/telepen {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /numeric false def
    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Create an array containing the character mappings
    /encs
    [ (31313131)        (1131313111)     (33313111)       (1111313131)
      (3111313111)      (11333131)       (13133131)       (111111313111)
      (31333111)        (1131113131)     (33113131)       (1111333111)
      (3111113131)      (1113133111)     (1311133111)     (111111113131)
      (3131113111)      (11313331)       (333331)         (111131113111)
      (31113331)        (1133113111)     (1313113111)     (1111113331)
      (31131331)        (113111113111)   (3311113111)     (1111131331)
      (311111113111)    (1113111331)     (1311111331)     (11111111113111)
      (31313311)        (1131311131)     (33311131)       (1111313311)
      (3111311131)      (11333311)       (13133311)       (111111311131)
      (31331131)        (1131113311)     (33113311)       (1111331131)
      (3111113311)      (1113131131)     (1311131131)     (111111113311)
      (3131111131)      (1131131311)     (33131311)       (111131111131)
      (3111131311)      (1133111131)     (1313111131)     (111111131311)
      (3113111311)      (113111111131)   (3311111131)     (111113111311)
      (311111111131)    (111311111311)   (131111111311)   (11111111111131)
      (3131311111)      (11313133)       (333133)         (111131311111)
      (31113133)        (1133311111)     (1313311111)     (1111113133)
      (313333)          (113111311111)   (3311311111)     (11113333)
      (311111311111)    (11131333)       (13111333)       (11111111311111)
      (31311133)        (1131331111)     (33331111)       (1111311133)
      (3111331111)      (11331133)       (13131133)       (111111331111)
      (3113131111)      (1131111133)     (33111133)       (111113131111)
      (3111111133)      (111311131111)   (131111131111)   (111111111133)
      (31311313)        (113131111111)   (3331111111)     (1111311313)
      (311131111111)    (11331313)       (13131313)       (11111131111111)
      (3133111111)      (1131111313)     (33111313)       (111133111111)
      (3111111313)      (111313111111)   (131113111111)   (111111111313)
      (313111111111)    (1131131113)     (33131113)       (11113111111111)
      (3111131113)      (113311111111)   (131311111111)   (111111131113)
      (3113111113)      (11311111111111) (331111111111)   (111113111113)
      (31111111111111)  (111311111113)   (131111111113)   (1111111111111111)
    ] def

    /barlen barcode length def    % Length of the code
    /sbs barlen 16 mul 48 add string def
    /txt barlen array def

    % Put the start character ASCII 95
    /enc encs 95 get def
    sbs 0 enc putinterval
    /l enc length def

    /checksum 0 def
    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        numeric {  % numeric mode: 00-99 & 0X-9X
            barcode i get 16 gt { 
                /np barcode i 2 getinterval def
                np 1 1 getinterval (X) eq {  % X in even position amongst digits
                    /indx np 0 1 getinterval cvi 17 add def
                } {
                    /indx np cvi 27 add def
                } ifelse
                txt j [np j 16 mul 16 add textyoffset textfont textsize] put
                /i i 2 add def
            } {
                /indx barcode i get def
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
                /i i 1 add def
            } ifelse
        } {  % ASCII mode
            /indx barcode i get def
            indx 32 ge indx 126 le and {
                txt j [barcode i 1 getinterval j 16 mul 16 add textyoffset textfont textsize] put
            } {
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
            } ifelse
            /i i 1 add def
        } ifelse
        /checksum checksum indx add def
        /enc encs indx get def
        sbs l enc putinterval          % Put encoded digit into sbs
        /l l enc length add def
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum 127 checksum 127 mod sub 127 mod def
    /enc encs checksum get def
    sbs l enc putinterval
    /l l enc length add def

    % Put the end character ASCII 122
    /enc encs 122 get def
    sbs l enc putinterval
    /l l enc length add def

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 l getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/telepen dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER telepen--

% --BEGIN ENCODER posicode--
% --DESC: PosiCode
% --EXAM: ABC123
% --EXOP: version=b inkspread=-0.5 parsefnc includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/posicode {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /version (a) def
    /checkoffset 0 def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /encoding encoding cvlit def
    /version version cvlit def
    /checkoffset checkoffset cvi def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /la0  -1 def  /la1  -2 def  /la2  -3 def 
    /sf0  -4 def  /sf1  -5 def  /sf2  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def  /fn4 -10 def

    % Character maps for each state
    <<
    /normal
      [
          %  0    1    2        0    1    2        0    1    2
          [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (<)   28 ]  % 0-2 
          [ (3)  (=)   29 ]  [ (4)  (>)   30 ]  [ (5)  (?)   31 ]  % 3-5
          [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8
          [ (9)  (])  (&) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11
          [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14
          [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17
          [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20
          [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23
          [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26
          [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29
          [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32
          [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35
          [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38
          [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41
          [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44
          [ sf2  sf2  fn4 ]                                        % 45
      ]
    /limited
      [
          [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2
          [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5
          [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8
          [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11
          [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14
          [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17
          [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20
          [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23
          [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26
          [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29
          [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32
          [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35
          [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37
      ]
    >> 
    version (a) eq version (b) eq or {/normal} {/limited} ifelse get 
    /charmaps exch def

    % Invert charmaps to give character to value maps for each state
    /charvals [
        charmaps length dict charmaps length dict charmaps length dict
    ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /set0 charvals 0 get def
    /set1 charvals 1 get def
    /set2 charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def

        % Convert input into bytes accounting for FNC characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Convert the input message to codewords
        /enc {
            exch get cws exch j exch put
            /j j 1 add def
        } bind def

        /cws barcode length 2 mul array def
        /i 0 def /j 0 def /cset (set0) def
        {
            i msglen eq {exit} if
       
            {  % common exit

                % Read next two characters
                /char1 msg i get def
                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def

                % If current mode is sufficient then directly encode
                cset load char1 known { 
                    char1 cset load enc
                    /i i 1 add def
                    exit
                } if

                % If char1 is in set2 then shift encode
                set2 char1 known {
                    sf2 cset load enc
                    char1 set2 enc
                    /i i 1 add def
                    exit
                } if 

                % If char2 is also not in this set then latch else shift encode
                cset load char2 known not {
                    cset (set0) eq {
                       la1 cset load enc
                       /cset (set1) def
                    } {
                       la0 cset load enc
                       /cset (set0) def
                    } ifelse
                    exit
                } { 
                    cset (set0) eq {
                        sf1 cset load enc
                        char1 set1 enc
                    } {
                        sf0 cset load enc
                        char1 set0 enc
                    } ifelse 
                    /i i 1 add def
                    exit
                } ifelse

                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Create an array containing the character mappings
    <<   % ";"=11, "<"=12
    /a
        [ (141112) (131212) (121312) (111412) (131113)
          (121213) (111313) (121114) (111214) (111115)
          (181111) (171211) (161311) (151411) (141511)
          (131611) (121711) (111811) (171112) (161212)
          (151312) (141412) (131512) (121612) (111712)
          (161113) (151213) (141313) (131413) (121513)
          (111613) (151114) (141214) (131314) (121414)
          (111514) (141115) (131215) (121315) (111415)
          (131116) (121216) (111316) (121117) (111217)
          (111118) (1<111112) (111111111;1)
        ]
    /b
        [ (151213) (141313) (131413) (121513) (141214)
          (131314) (121414) (131215) (121315) (121216)
          (191212) (181312) (171412) (161512) (151612)
          (141712) (131812) (121912) (181213) (171313)
          (161413) (151513) (141613) (131713) (121813)
          (171214) (161314) (151414) (141514) (131614)
          (121714) (161215) (151315) (141415) (131515)
          (121615) (151216) (141316) (131416) (121516)
          (141217) (131317) (121417) (131218) (121318)
          (121219) (1<121312) (121212121<1)
        ]
    /limiteda
        [ (111411) (111312) (111213) (111114) (121311)
          (121212) (121113) (141111) (131211) (131112)
          (171111) (161211) (151311) (141411) (131511)
          (121611) (111711) (161112) (151212) (141312)
          (131412) (121512) (111612) (151113) (141213)
          (131313) (121413) (111513) (141114) (131214)
          (121314) (111414) (131115) (121215) (111315)
          (121116) (111216) (111117) (151111) (1)
        ]
    /limitedb
        [ (121512) (121413) (121314) (121215) (131412)
          (131313) (131214) (151212) (141312) (141213)
          (181212) (171312) (161412) (151512) (141612)
          (131712) (121812) (171213) (161313) (151413)
          (141513) (131613) (121713) (161214) (151314)
          (141414) (131514) (121614) (151215) (141315)
          (131415) (121515) (141216) (131316) (121416)
          (131217) (121317) (121218) (141212) (1)
        ]
    >>
    version get /encs exch def

    /c2w [
        [ 495 330 210 126  70  35  15   5 ]
        [ 165 120  84  56  35  20  10   4 ]
        [  45  36  28  21  15  10   6   3 ] 
        [   9   8   7   6   5   4   3   2 ]
        [   1   1   1   1   1   1   1   1 ]
    ] def
    /v 0 def
    cws {
        /cw exch def
        6 {
            cw v xor 1 and 0 ne {
                /v v 7682 xor def
            } if
            /v v -1 bitshift def
            /cw cw -1 bitshift def
        } repeat 
    } forall
    /v v checkoffset add def

    version (limiteda) eq version (limitedb) eq or {
        /v v 1023 and def
        v 824 gt v 853 lt and {
            /v v 292 add def
        } if 
    } {
        /v v 1023 and 45 add def
    } ifelse

    /d [ 2 2 2 2 2 2 ] def
    /r 0 def /c 0 def /w 0 def /sum 0 def
    {
        sum v eq {exit} if
        /t sum c2w r get c get add def
        t v eq {
            /w w 1 add def
            d r w 2 add put
            /sum t def
        } if
        t v gt {
            d r w 2 add put
            /r r 1 add def
            /w 0 def
        } if
        t v lt {
            /c c 1 add def
            /w w 1 add def
            /sum t def
        } if
    } loop
    20 0 1 4 {d exch get sub} for
    d exch 5 exch put
    version (b) eq version (limitedb) eq or {  
        /d [ d {1 add} forall ] def
    } if
    /cbs (111111111111) 12 string copy def
    5 -1 0 {
        /i exch def
        cbs 5 i sub 2 mul 1 add d i get 47 add put
    } for

    % Concatenate the space bar successions
    /sbs cws length 6 mul 31 add string def
    encs encs length 2 sub get dup 
    sbs exch 0 exch putinterval 
    length /j exch def
    0 1 cws length 1 sub {
        /i exch def
        sbs j encs cws i get get putinterval
        /j j 6 add def
    } for
    sbs j cbs putinterval
    /j j 12 add def
    encs encs length 1 sub get dup
    sbs exch j exch putinterval
    length j add /j exch def
    /sbs sbs 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/posicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER posicode--

% --BEGIN ENCODER codablockf--
% --DESC: Codablock F
% --EXAM: CODABLOCK F 34567890123456789010040digit
% --EXOP: cols=8
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codablockf {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /rows -1 def
    /cols 8 def
    /rowheight 10 def
    /sepheight 1 def
    /encoding (auto) def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /rows rows cvi def
    /cols cols cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    cols 4 ge cols 62 le and 
    rows 2 ge rows 44 le and rows -1 eq or and {/c cols def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa -1 def  /swb -2 def  /swc -3 def  /sft -4 def
    /fn1 -5 def  /fn2 -6 def  /fn3 -7 def  /fn4 -8 def
    /sta -9 def  /stp -10 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stp  stp  stp  ]  % 102-104
    ] def
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 105 dict 105 dict 105 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
        (FNC4) fn4
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Determine digit runlength and characters from given position
    /numsscr {
        /n 0 def /s 0 def
        /p exch def {
            p msglen ge {exit} if
            msg p get
            dup setc exch known not {pop exit} if
            fn1 eq {
                % FNC1 in odd position of run like two digits
                s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
            } if
            /n n 1 add def
            /s s 1 add def
            /p p 1 add def
        } loop
        n s
    } bind def

    % Encoding for each alphabet
    /enca {
        seta exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encb {
        setb exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encc {
        dup type /arraytype ne {
            setc exch get
        } {
            aload pop 48 sub exch 48 sub 10 mul add
        } ifelse
        cws exch j exch put
        /j j 1 add def
    } bind def

    % Character exclusively in either alphabet A or B
    /anotb {dup seta exch known exch setb exch known not and} bind def
    /bnota {dup setb exch known exch seta exch known not and} bind def

    % Pre-compute relative position of next anotb and next bnota characters
    /nextanotb [ msg length {0} repeat 9999 ] def
    /nextbnota [ msg length {0} repeat 9999 ] def
    msg length 1 sub -1 0 {
        /i exch def
        msg i get anotb {
            nextanotb i 0 put
        } {
            nextanotb i nextanotb i 1 add get 1 add put
        } ifelse
        msg i get bnota {
            nextbnota i 0 put
        } {
            nextbnota i nextbnota i 1 add get 1 add put
        } ifelse
    } for

    % Does a-only come before b-only after given position and vice versa
    /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
    /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def

    % Add padding to row
    /padrow {
        {
           {  % common exit
               cset (seta) eq {swc enca /cset (setc) def exit} if
               cset (setb) eq {swc encb /cset (setc) def exit} if
               cset (setc) eq {swb encc /cset (setb) def exit} if
           } loop
        } repeat
    } bind def

    % Convert message to codewords
    /cws c 5 add rows -1 ne {rows} {44} ifelse mul array def

    /i 0 def /j 0 def /r 1 def
    /lastrow false def {
        
        lastrow {exit} if

        % Add start character and code subset selector
        sta enca
        i msglen lt {i numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                swb enca
                /cset (setb) def
                exit
            } if
            nums 2 ge {
                swc enca
                /cset (setc) def
                exit
            } if
            i abeforeb { 
                sft enca
                /cset (seta) def
                exit 
            } if 
            swb enca
            /cset (setb) def
            exit
        } loop
        /j j 1 add def  % Skip row indicator position

        % Main encoding loop
        /endofrow false def {
            /rem c 3 add j c 5 add mod sub def  % Codewords to end of row

            i msglen eq endofrow or {exit} if
        
            i numsscr /nums exch def /nchars exch def

            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq
                    rem 3 ge and {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                    nums 2 mod 0 ne
                    rem 4 ge and {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                } if
                cset (setb) eq msg i get anotb and 
                rem 2 ge and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (seta) eq msg i get bnota and
                rem 2 ge and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 lt and
                rem 2 ge and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        msg i get enca
                        /i i 1 add def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
        
                % No switches or latches so try to encode
                cset (seta) eq seta msg i get known and
                rem 1 ge and {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq setb msg i get known and
                rem 1 ge and {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 ge and
                rem 1 ge and {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if

                % Encoding does not fit in the row
                /endofrow true def
                exit

            } loop  % common exit

        } loop

        % Determine whether this is the final row
        r rows eq rows -1 eq or r 1 gt and i msglen eq and rem 2 ge and {
            rem 2 sub padrow
            /j j 3 add def  % Skip symbol and row checksum character positions
            stp enca
            /lastrow true def
        } {
            rem padrow
            /j j 1 add def  % Skip row checksum character positions
            stp enca
            /r r 1 add def
        } ifelse

    } loop
    /cws cws 0 j getinterval def

    % Maps for row indicators and symbol checksums
    /abmap [
        64 1 95 {} for
         0 1 15 {} for
        26 1 63 {} for
    ] def
    /cmap [ 0 1 85 {} for ] def
    
    % Add symbol check characters to last row
    /chkmsg msglen array def
    /j 0 def
    0 1 msglen 1 sub {
        /i exch def
        /char msg i get def
        char 0 ge {chkmsg j char put /j j 1 add def} if
        char fn1 eq i 0 ne and {chkmsg j 29 put /j j 1 add def} if
    } for
    /t1 0 def /t2 0 def /k1 0 def /k2 0 def
    0 1 j 1 sub {
        /i exch def
        /t1 chkmsg i get i mul 86 mod def
        /t2 t1 chkmsg i get add 86 mod def
        /k1 k1 t2 add 86 mod def
        /k2 k2 t1 add 86 mod def
    } for
    cws cws length 4 sub cset (setc) ne {abmap} {cmap} ifelse k1 get put
    cws cws length 3 sub cset (setc) ne {abmap} {cmap} ifelse k2 get put

    % Populate row indicators
    cws 2 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse r 2 sub get put
    1 1 r 1 sub {
        /i exch def
        cws i c 5 add mul 2 add 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse i 42 add get put
    } for

    % Calculate row check characters
    0 1 r 1 sub {
        cws exch c 5 add mul c 4 add getinterval /rcws exch def
        /csum rcws 0 get def
        1 1 rcws length 2 sub {
            /i exch def
            /csum csum rcws i get i mul add def
        } for
        rcws rcws length 1 sub csum 103 mod put
    } for

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (2331112)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            cws i c 5 add mul c 5 add getinterval {
                encs exch get {48 sub} forall
            } forall 
        ] def
        mark
        0 sbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /symwid c 11 mul 57 add def
    /pixs [
        symwid sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {
                1 1 0 1 0 0 0 0 1 0 0
                symwid 24 sub {1} repeat
                1 1 0 0 0 1 1 1 0 1 0 1 1
            } repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        symwid sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx symwid
    /pixy pixs length symwid idiv
    /height pixs length symwid idiv 72 div
    /width symwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codablockf--

% --BEGIN ENCODER code16k--
% --DESC: Code 16K
% --EXAM: Abcd-1234567890-wxyZ
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code16k {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    pos -1 ne {/rows 16 def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa  -1 def  /swb  -2 def  /swc  -3 def 
    /sa1  -4 def  /sb1  -5 def  /sc1  -6 def 
    /sa2  -7 def  /sb2  -8 def  /sc2  -9 def 
    /pad -10 def  /sb3 -11 def  /sc3 -12 def
    /fn1 -13 def  /fn2 -14 def  /fn3 -15 def  /fn4 -16 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sb1  sa1  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ pad  pad  pad  ]  [ sb2  sa2  sb1  ]  % 102-104
      [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def
        /msg barlen array def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
    
        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
 
        /cws barcode length 2 mul 3 add array def
       
        % Select mode and encode first characters
        /i 0 def /j 0 def
        {  % common exit
            % extended data length
            pos -1 ne {
                % encode one and two
                cws 0 pos 10 idiv 1 sub put
                cws 1 pos 10 mod 1 sub put 
                /j 2 def
                /cset (setb) def
                /mode 7 def
                exit
            } if
            % empty => b
            msglen 0 eq {
                /cset (setb) def
                /mode 1 def
                exit
            } if
            % FNC1 . 2+ nums => c fnc1
            msglen 2 ge {
                msg 0 get fn1 eq 1 numsscr exch pop 2 ge and {
                    /cset (setc) def
                    /mode 4 def
                    /i 1 def
                    exit
                } if
            } if
            % FNC1 => b fnc1
            msg 0 get fn1 eq {
                /cset (setb) def
                /mode 3 def
                /i 1 def
                exit
            } if
            msglen 2 ge {
                % 2+ even nums => c
                0 numsscr exch pop dup 2 ge exch 2 mod 0 eq and {
                    /cset (setc) def
                    /mode 2 def
                    exit
                } if
                % 3+ odd nums => c sb1 encode
                0 numsscr exch pop dup 3 ge exch 2 mod 1 eq and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 2+ even nums => c sb1 encode
                setb msg 0 get known
                1 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 3+ odd nums => c sb2 encode 
                setb msg 0 get known
                1 numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
                % b . b . 2+ even nums => c sb2 encode
                setb msg 0 get known
                setb msg 1 get known and
                2 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
            } if
            % anotb before bnota => a
            0 abeforeb {
                /cset (seta) def
                /mode 0 def
                exit
            } if
            % otherwise => b
            /cset (setb) def
            /mode 1 def
            exit
        } loop

        {  % Encode remainder
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq {
                    % bnota . anotb before bnota => sb1 encode
                    i msglen 1 sub lt {
                        msg i get bnota
                        i 1 add abeforeb and {
                            sb1 enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % bnota . bnota . anotb before bnota => sb2 encode
                    i msglen 2 sub lt {
                        msg i get bnota
                        msg i 1 add get bnota and
                        i 2 add abeforeb and {
                            sb2 enca
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % bnota => swb
                    msg i get bnota {
                        swb enca
                        /cset (setb) def
                        exit
                    } if
                    % 4 nums . a => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq 
                        seta msg i 4 add get known and {
                            sc2 enca
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def 
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . a => sc3 encode
                    i msglen 6 sub lt { 
                        nums 6 eq 
                        seta msg i 6 add get known and {
                            sc3 enca
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc enca
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    % anotb . bnota before anotb => sa1 encode
                    i msglen 1 sub lt {
                        msg i get anotb
                        i 1 add bbeforea and {
                            sa1 encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % anotb . anotb . bnota before anotb => sa2 encode
                    i msglen 2 sub lt {
                        msg i get anotb 
                        msg i 1 add get anotb and
                        i 2 add bbeforea and {
                            sa2 encb
                            msg i get enca
                            msg i 1 add get enca
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % anotb => swa
                    msg i get anotb {
                        swa encb
                        /cset (seta) def
                        exit
                    } if
                    % 4 nums . b => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq
                        setb msg i 4 add get known and {
                            sc2 encb
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . b => sc3 encode
                    i msglen 6 sub lt {
                        nums 6 eq
                        setb msg i 6 add get known and {
                            sc3 encb
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc encb
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get encb
                    /i i 1 add def
                    exit 
                } if
                cset (setc) eq {
                    % 2+ nums => encode
                    nums 2 ge {
                        msg i get fn1 eq {
                            fn1 encc
                            /i i 1 add def
                        } {
                            msg i 2 getinterval encc
                            /i i 2 add def
                        } ifelse
                        exit
                    } if
                    % b . 2+ even nums => sb1 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb1 encc
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % b . 3+ odd nums => sb2 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 2+ even nums => sb2 encode
                    i msglen 2 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 3+ odd nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit
                        } if
                    } if
                    % b . b . b . 2+ even nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known 
                        setb msg i 1 add get known and
                        setb msg i 2 add get known and
                        i 3 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit 
                        } if
                    } if
                    % anotb before bnota => swa
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    % otherwise => swb
                    swb encc
                    /cset (setb) def
                    exit
                } if
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding
    
    % Basic metrics for the each symbol
    %     r  dcws 
    /metrics [
        [  2    7 ]
        [  3   12 ]
        [  4   17 ]
        [  5   22 ]
        [  6   27 ]
        [  7   32 ]
        [  8   37 ]
        [  9   42 ]
        [ 10   47 ]
        [ 11   52 ]
        [ 12   57 ]
        [ 13   62 ]
        [ 14   67 ]
        [ 15   72 ]
        [ 16   77 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {103} repeat ] def

    % Add the start character
    /cws [ r 2 sub 7 mul mode add cws aload pop ] def

    % Calculate the check characters
    0 0 1 dcws {dup 2 add exch cws exch get mul add} for 
    107 mod /c1 exch def
    0 0 1 dcws {dup 1 add exch cws exch get mul add} for 
    c1 dcws 2 add mul add 107 mod /c2 exch def
    /cws [ cws aload pop c1 c2 ] def

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (211133)
    ] def

    % Start/stop character encodings
    /startencs [ 
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
    ] def
    /stopencsodd [
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (1132) (1231) (1114) (3112) (3211) (2221) (2122) (1411)
    ] def
    /stopencseven [
        (2122) (1411) (1132) (1231) (1114) (3112) (1132) (1231)
        (1114) (3112) (3211) (2221) (2122) (1411) (3211) (2221)
    ] def
    pos -1 eq pos 10 idiv 2 mod 1 eq or {
        /stopencs stopencsodd def
    } {
        /stopencs stopencseven def
    } ifelse
 
    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            10
            startencs i get {48 sub} forall
            1
            cws i 5 mul 5 getinterval {
                encs exch get {48 sub} forall
            } forall 
            stopencs i get {48 sub} forall
            1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code16k dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code16k--

% --BEGIN ENCODER code49--
% --DESC: Code 49
% --EXAM: MULTIPLE ROWS IN CODE 49
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code49 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /s1 -1 def /s2 -2 def /fn1 -3 def /fn2 -4 def /fn3 -5 def /ns -6 def
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Character encodings
    /charmap [
        (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
        (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M)
        (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z)
        (-) (.) ( ) ($) (/) (+) (%)
        s1  s2  fn1 fn2 fn3 ns
    ] def

    % Invert charmap to give character to value map
    /charvals 49 dict def
    0 1 48 {
        /i exch def
        charmap i get 
        dup type /stringtype eq {0 get} if  % convert string to ASCII if required
        charvals exch i put 
    } for

    % Shifted character encodings
    /combos
    [ (1 ) (1A) (1B) (1C) (1D) (1E) (1F) (1G) (1H) (1I) (1J) (1K) (1L) (1M) (1N) (1O)
      (1P) (1Q) (1R) (1S) (1T) (1U) (1V) (1W) (1X) (1Y) (1Z) (11) (12) (13) (14) (15)
      (  ) (16) (17) (18) ( $) ( %) (19) (10) (1-) (1.) (1$) ( +) (1/) ( -) ( .) ( /)
      ( 0) ( 1) ( 2) ( 3) ( 4) ( 5) ( 6) ( 7) ( 8) ( 9) (1+) (21) (22) (23) (24) (25)
      (26) ( A) ( B) ( C) ( D) ( E) ( F) ( G) ( H) ( I) ( J) ( K) ( L) ( M) ( N) ( O)
      ( P) ( Q) ( R) ( S) ( T) ( U) ( V) ( W) ( X) ( Y) ( Z) (27) (28) (29) (20) (2-)
      (2.) (2A) (2B) (2C) (2D) (2E) (2F) (2G) (2H) (2I) (2J) (2K) (2L) (2M) (2N) (2O)
      (2P) (2Q) (2R) (2S) (2T) (2U) (2V) (2W) (2X) (2Y) (2Z) (2$) (2/) (2+) (2%) (2 )
    ] def
    0 1 127 {
        /i exch def
        combos i get dup 0 get /c1 exch def 1 get /c2 exch def
        c1 49 eq {  % s1 char
            charvals i [ charvals s1 get charvals c2 get ] put
        } if
        c1 50 eq {  % s2 char
            charvals i [ charvals s2 get charvals c2 get ] put
        } if
    } for

    /encodealpha {
        charvals exch get
        dup type /arraytype ne {1 array astore} if
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /base48 {
        0 exch {48 sub exch 10 mul add} forall
        [ 3 1 roll exch 1 sub {dup 48 mod exch 48 idiv} repeat ]
        [ exch dup length 1 sub -1 0 {1 index exch get exch} for pop ]
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /encodenumeric {
        /nums exch def
        /pre nums length dup 5 mod dup 2 ne {sub} {sub 5 sub} ifelse def
        0 5 pre 1 sub {nums exch 5 getinterval 3 exch base48} for
        /nums nums pre nums length pre sub getinterval def
        nums length
        dup 1 eq {nums i get encodealpha} if
        dup 3 eq {2 nums base48} if
        dup 4 eq {3 [49 48 nums aload pop] base48} if
        7 eq {
            3 [49 48 nums 0 4 getinterval aload pop] base48
            2 nums 4 3 getinterval base48
        } if
    } bind def

    % Pre-compute alphanumeric and numeric runlengths
    /numericruns [ msglen {0} repeat 0 ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get
        dup 48 ge exch 57 le and {
            numericruns i numericruns i 1 add get 1 add put
        } {
            numericruns i 0 put
        } ifelse
    } for

    % Autoselect mode
    mode -1 eq {
        {  % common exit
            pos -1 ne {/mode 3 def exit} if
            numericruns 0 get 5 ge {/mode 2 def exit} if
            charvals msg 0 get get
            dup type /arraytype ne {pop /mode 0 def exit} if
            0 get 43 eq {4} {5} ifelse /mode exch def
            exit
        } loop
    } if

    /cws msglen 2 mul 1 add array def
    /method (alpha) def /i -1 def /j -1 def

    % Handle start for each mode
    mode 0 eq mode 1 eq or {/method (alpha) def /i 0 def /j 0 def} if 
    mode 2 eq {/method (numeric) def /i 0 def /j 0 def} if
    mode 3 eq {
        /posval [ 
            12 22
            13 23 33
            14 24 34 44
            15 25 35 45 55
            16 26 36 46 56 66
            17 27 37 47 57 67 77 
            18 28 38 48 58 68 78 88 
            19 29 39 49 59 69 79 89 99
        ] def
        cws 0 0 1 43 {dup posval exch get pos ne {pop} if} for 1 add put
        /method (alpha) def /i 0 def /j 1 def
    } if
    mode 4 eq mode 5 eq or {
        cws 0 charvals msg 0 get get 1 get put
        /method (alpha) def /i 1 def /j 1 def
    } if

    % Encode remainder
    {
        i msglen eq {exit} if
        {  % not a loop but common exit point
            method (alpha) eq {
                numericruns i get 5 ge {
                    ns encodealpha
                    /method (numeric) def
                    exit
                } if
                msg i get encodealpha
                /i i 1 add def
                exit
            } if
            method (numeric) eq {
                numericruns i get 5 lt {
                    ns encodealpha
                    /method (alpha) def
                    exit
                } if
                msg i numericruns i get getinterval encodenumeric
                /i i numericruns i get add def
                exit
            } if
        } loop
    } loop
    /cws cws 0 j getinterval def

    % Basic metrics for the each symbol
    %     r dcws 
    /metrics [
        [ 2    9 ]
        [ 3   16 ]
        [ 4   23 ]
        [ 5   30 ]
        [ 6   37 ]
        [ 7   42 ]
        [ 8   49 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {48} repeat ] def

    % Populate code character array and add row check characters
    /ccs r 8 mul array def
    /j 0 def
    0 1 r 2 sub {
        /i exch def
        /cc cws j 7 getinterval def
        ccs i 8 mul cc putinterval       
        ccs i 8 mul 7 add 0 cc {add} forall 49 mod put
        /j j 7 add def
    } for
    j dcws lt {
        ccs ccs length 8 sub cws j dcws j sub getinterval putinterval
    } if

    % Place row count character
    /cr7 r 2 sub 7 mul mode add def
    ccs ccs length 2 sub cr7 put

    % Calculate the symbol check characters
    [  1  9 31 26  2 12 17 23 37 18 22  6 27 44 15 43 39
      11 13  5 41 33 36  8  4 32  3 19 40 25 29 10 24 30 ]
    dup [ exch 20 exch 0 32 getinterval aload pop ] /weightx exch def
    dup [ exch 16 exch 1 32 getinterval aload pop ] /weighty exch def
        [ exch 38 exch 2 32 getinterval aload pop ] /weightz exch def
    /calccheck {
        /weights exch def
        /score 0 def
        0 1 r 1 sub 8 mul 2 idiv 1 sub {
            /i exch def
            ccs i 2 mul get 49 mul ccs i 2 mul 1 add get add 
            weights i 1 add get mul /score exch score add def
        } for
        score
    } bind def
    /lastrow ccs ccs length 8 sub 8 getinterval def

    % wr1 check character
    r 7 ge {
        cr7 weightz 0 get mul weightz calccheck add 2401 mod
        dup 49 idiv exch 49 mod 2 array astore
        lastrow 0 3 -1 roll putinterval
    } if
    /wr1 lastrow 0 get 49 mul lastrow 1 get add def

    % wr2 check character
    cr7 weighty 0 get mul weighty calccheck add 
    wr1 weighty r 4 mul 3 sub get mul add
    2401 mod dup /wr2 exch def
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 2 3 -1 roll putinterval

    % wr3 check character
    cr7 weightx 0 get mul weightx calccheck add
    wr1 weightx r 4 mul 3 sub get mul add
    wr2 weightx r 4 mul 2 sub get mul add
    2401 mod
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 4 3 -1 roll putinterval

    % Place last row check character
    ccs ccs length 8 sub 7 getinterval 0 exch {add} forall 49 mod
    ccs ccs length 1 sub 3 -1 roll put

    /patterns [
        [  % Even parity
            (11521132) (25112131) (14212132) (25121221) (14221222) (12412132) (23321221)
            (12421222) (21521221) (15112222) (15121312) (13312222) (24221311) (13321312)
            (11512222) (22421311) (11521312) (25112311) (14212312) (23312311) (12412312)
            (21512311) (16121131) (14321131) (12521131) (15212131) (15221221) (13412131)
            (13421221) (11612131) (16112221) (16121311) (14312221) (14321311) (12512221)
            (12521311) (15212311) (13412311) (11612311) (11131135) (31131133) (51131131)
            (21122134) (41122132) (21131224) (41131222) (11113135) (31113133) (51113131)
            (11122225) (31122223) (51122221) (11131315) (31131313) (51131311) (21113224)
            (41113222) (21122314) (41122312) (11113315) (31113313) (51113311) (12131134)
            (32131132) (21231133) (41231131) (22122133) (42122131) (11222134) (22131223)
            (42131221) (11231224) (31231222) (12113134) (32113132) (12122224) (32122222)
            (12131314) (32131312) (21231313) (41231311) (22113223) (42113221) (11213224)
            (22122313) (42122311) (11222314) (31222312) (12113314) (32113312) (21213313)
            (41213311) (13131133) (33131131) (22231132) (11331133) (31331131) (23122132)
            (12222133) (23131222) (12231223) (32231221) (21331222) (13113133) (33113131)
            (13122223) (33122221) (11313133) (13131313) (33131311) (11322223) (22231312)
            (11331313) (31331311) (23113222) (12213223) (23122312) (12222313) (32222311)
            (21322312) (13113313) (33113311) (22213312) (11313313) (31313311) (14131132)
            (23231131) (12331132) (21431131) (24122131) (13222132) (24131221) (13231222)
            (11422132) (22331221) (11431222) (14113132) (14122222) (12313132) (14131312)
            (12322222) (23231311) (12331312) (21431311) (24113221) (13213222) (24122311)
            (13222312) (11413222) (22322311) (11422312) (14113312) (23213311) (12313312)
            (21413311) (15131131) (13331131) (14222131) (14231221) (12422131) (12431221)
            (15113131) (15122221) (13313131) (15131311) (13322221) (11513131) (13331311)
            (11522221) (14213221) (14222311) (12413221) (12422311) (15113311) (13313311)
            (11513311) (11141134) (31141132) (21132133) (41132131) (21141223) (41141221)
            (11123134) (31123132) (11132224) (31132222) (11141314) (31141312) (21114133)
            (41114131) (21123223) (41123221) (21132313) (41132311) (11114224) (31114222)
            (11123314) (31123312) (21114313) (41114311) (12141133) (32141131) (21241132)
            (22132132) (11232133) (22141222) (11241223) (31241221) (12123133) (32123131)
            (12132223) (32132221) (12141313) (32141311) (21241312) (22114132) (11214133)
            (22123222) (11223223) (22132312) (11232313) (31232311) (12114223) (32114221)
            (12123313) (32123311) (21223312) (22114312) (11214313) (31214311) (13141132)
            (22241131) (11341132) (23132131) (12232132) (23141221) (12241222) (21341221)
            (13123132) (13132222) (11323132) (13141312) (11332222) (22241311) (11341312)
            (23114131) (12214132) (23123221) (12223222) (23132311) (12232312) (21332311)
            (13114222) (13123312) (11314222) (22223311) (11323312) (23114311) (12214312)
            (21314311) (14141131) (12341131) (13232131) (13241221) (11432131) (14123131)
            (14132221) (12323131) (14141311) (12332221) (12341311) (13214131) (13223221)
            (11414131) (13232311) (11423221) (11432311) (14114221) (14123311) (12314221)
            (12323311) (13214311) (11414311) (11151133) (31151131) (21142132) (21151222)
            (11133133) (31133131) (11142223) (31142221) (11151313) (31151311) (21124132)
            (21133222) (21142312) (11115133) (31115131) (11124223) (31124221) (11133313)
            (31133311) (21115222) (21124312) (12151132) (21251131) (22142131) (11242132)
            (22151221) (11251222) (12133132) (12142222) (12151312) (21251311) (22124131)
            (11224132) (22133221) (11233222) (22142311) (11242312) (12115132) (12124222)
            (12133312) (21233311) (22115221) (11215222) (22124311) (11224312) (13151131)
            (12242131) (12251221) (13133131) (13142221) (11333131) (13151311) (11342221)
            (12224131) (12233221) (12242311) (13115131) (13124221) (11315131) (13133311)
            (11324221) (11333311) (12215221) (12224311) (11161132) (21152131) (21161221)
            (11143132) (11152222) (11161312) (21134131) (21143221) (21152311) (11125132)
            (11134222) (11143312) (21116131) (21125221) (21134311) (12161131) (11252131)
            (12143131) (12152221) (12161311) (11234131) (11243221) (11252311) (12125131)
            (12134221) (12143311) (11216131) (11225221) (11234311) (11111236) (31111234)
            (51111232) (21111325) (41111323) (61111321) (11111416) (31111414) (51111412)
            (31211143) (51211141) (12111235) (32111233) (52111231) (21211234) (41211232)
            (22111324) (42111322) (11211325) (31211323) (51211321) (12111415) (32111413)
            (52111411) (21211414) (41211412) (12211144) (32211142) (21311143) (41311141)
            (13111234) (33111232) (22211233) (42211231) (11311234) (31311232) (23111323)
            (43111321) (12211324) (32211322) (21311323) (41311321) (13111414) (33111412)
            (22211413) (42211411) (11311414) (31311412) (13211143) (33211141) (22311142)
            (11411143) (31411141) (14111233) (34111231) (23211232) (12311233) (32311231)
            (21411232) (24111322) (13211323) (33211321) (22311322) (11411323) (31411321)
            (14111413) (34111411) (23211412) (12311413) (32311411) (21411412) (14211142)
            (23311141) (12411142) (21511141) (15111232) (24211231) (13311232) (22411231)
            (11511232) (25111321) (14211322) (23311321) (12411322) (21511321) (15111412)
            (24211411) (13311412) (22411411) (11511412) (15211141) (13411141) (11611141)
            (16111231) (14311231) (12511231) (15211321) (13411321) (11611321) (16111411)
            (14311411) (12511411) (21121144) (41121142) (11112145) (31112143) (51112141)
            (11121235) (31121233) (51121231) (21112234) (41112232) (21121324) (41121322)
            (11112325) (31112323) (51112321) (11121415) (31121413) (51121411) (21112414)
            (41112412) (22121143) (42121141) (11221144) (31221142) (12112144) (32112142)
            (12121234) (32121232) (21221233) (41221231) (22112233) (42112231) (11212234)
            (22121323) (42121321) (11221324) (31221322) (12112324) (32112322) (12121414)
            (32121412) (21221413) (41221411) (22112413) (42112411) (11212414) (31212412)
            (23121142) (12221143) (32221141) (21321142) (13112143) (33112141) (13121233)
            (33121231) (11312143) (22221232) (11321233) (31321231) (23112232) (12212233)
            (23121322) (12221323) (32221321) (21321322) (13112323) (33112321) (13121413)
            (33121411) (11312323) (22221412) (11321413) (31321411) (23112412) (12212413)
            (32212411) (21312412) (24121141) (13221142) (22321141) (11421142) (14112142)
            (14121232) (12312142) (23221231) (12321232) (21421231) (24112231) (13212232)
            (24121321) (13221322) (11412232) (22321321) (11421322) (14112322) (14121412)
            (12312322) (23221411) (12321412) (21421411) (24112411) (13212412) (22312411)
            (11412412) (14221141) (12421141) (15112141) (15121231) (13312141) (13321231)
            (11512141) (11521231) (14212231) (14221321) (12412231) (12421321) (15112321)
            (15121411) (13312321) (13321411) (11512321) (11521411) (14212411) (12412411)
            (21131143) (41131141) (11122144) (31122142) (11131234) (31131232) (21113143)
            (41113141) (21122233) (41122231) (21131323) (41131321) (11113234) (31113232)
            (11122324) (31122322) (11131414) (31131412) (21113323) (41113321) (21122413)
            (41122411) (11113414) (31113412) (22131142) (11231143) (31231141) (12122143)
            (32122141) (12131233) (32131231) (21231232) (22113142) (11213143) (22122232)
            (11222233) (22131322) (11231323) (31231321) (12113233) (32113231) (12122323)
            (32122321) (12131413) (32131411) (21231412) (22113322) (11213323) (22122412)
            (11222413) (31222411) (12113413) (32113411) (21213412) (23131141) (12231142)
            (21331141) (13122142) (13131232) (11322142) (22231231) (11331232) (23113141)
            (12213142) (23122231) (12222232) (23131321) (12231322) (21331321) (13113232)
            (13122322) (11313232) (13131412) (11322322) (22231411) (11331412) (23113321)
            (12213322) (23122411) (12222412) (21322411) (13113412) (22213411) (11313412)
            (13231141) (11431141) (14122141) (14131231) (12322141) (12331231) (13213141)
            (13222231) (11413141) (13231321) (11422231) (11431321) (14113231) (14122321)
            (12313231) (14131411) (12322321) (12331411) (13213321) (13222411) (11413321)
            (11422411) (14113411) (12313411) (21141142) (11132143) (31132141) (11141233)
            (31141231) (21123142) (21132232) (21141322) (11114143) (31114141) (11123233)
            (31123231) (11132323) (31132321) (11141413) (31141411) (21114232) (21123322)
            (21132412) (11114323) (31114321) (11123413) (31123411) (22141141) (11241142)
            (12132142) (12141232) (21241231) (22123141) (11223142) (22132231) (11232232)
            (22141321) (11241322) (12114142) (12123232) (12132322) (12141412) (21241411)
            (22114231) (11214232) (22123321) (11223322) (22132411) (11232412) (12114322)
            (12123412) (21223411) (12241141) (13132141) (13141231) (11332141) (11341231)
            (12223141) (12232231) (12241321) (13114141) (13123231) (11314141) (13132321)
            (11323231) (13141411) (11332321) (11341411) (12214231) (12223321) (12232411)
            (13114321) (13123411) (11314321) (11323411) (21151141) (11142142) (11151232)
            (21133141) (21142231) (21151321) (11124142) (11133232) (11142322) (11151412)
            (21115141) (21124231) (21133321) (21142411) (11115232) (11124322) (11133412)
            (11251141) (12142141) (12151231) (11233141) (11242231) (11251321) (12124141)
            (12133231) (12142321) (12151411) (11215141) (11224231) (11233321) (11242411)
            (12115231) (12124321) (12133411) (11152141) (11161231) (11134141) (11143231)
            (11152321) (11161411) (11116141) (11125231) (11134321) (11143411) (21111244)
            (41111242) (11111335) (31111333) (51111331) (21111424) (41111422) (11111515)
            (31111513) (51111511) (21211153) (41211151) (22111243) (42111241) (11211244)
            (31211242) (12111334) (32111332) (21211333) (41211331) (22111423) (42111421)
            (11211424) (31211422) (12111514) (32111512) (21211513) (41211511) (22211152)
            (11311153) (31311151) (23111242) (12211243) (32211241) (21311242) (13111333)
            (33111331) (22211332) (11311333) (31311331) (23111422) (12211423) (32211421)
            (21311422) (13111513) (33111511) (22211512) (11311513) (31311511) (23211151)
            (12311152) (21411151) (24111241) (13211242) (22311241) (11411242) (14111332)
            (23211331) (12311332) (21411331) (24111421) (13211422) (22311421) (11411422)
            (14111512) (23211511) (12311512) (21411511) (13311151) (11511151) (14211241)
            (12411241) (15111331) (13311331) (11511331) (14211421) (12411421) (15111511)
            (13311511) (11511511) (31121152) (21112153) (41112151) (21121243) (41121241)
            (11112244) (31112242) (11121334) (31121332) (21112333) (41112331) (21121423)
            (41121421) (11112424) (31112422) (11121514) (31121512) (21112513) (41112511)
            (12121153) (32121151) (21221152) (22112152) (11212153) (22121242) (11221243)
            (31221241) (12112243) (32112241) (12121333) (32121331) (21221332) (22112332)
            (11212333) (22121422) (11221423) (31221421) (12112423) (32112421) (12121513)
            (32121511) (21221512) (22112512) (11212513) (31212511) (13121152) (22221151)
            (11321152) (23112151) (12212152) (23121241) (12221242) (21321241) (13112242)
            (13121332) (11312242) (22221331) (11321332) (23112331) (12212332) (23121421)
            (12221422) (21321421) (13112422) (13121512) (11312422) (22221511) (11321512)
            (23112511) (12212512) (21312511) (14121151) (12321151) (13212151) (13221241)
            (11412151) (11421241) (14112241) (14121331) (12312241) (12321331) (13212331)
            (13221421) (11412331) (11421421) (14112421) (14121511) (12312421) (12321511)
            (13212511) (11412511) (11131153) (31131151) (21122152) (21131242) (11113153)
            (31113151) (11122243) (31122241) (11131333) (31131331) (21113242) (21122332)
            (21131422) (11113333) (31113331) (11122423) (31122421) (11131513) (31131511)
            (21113422) (21122512) (12131152) (21231151) (22122151) (11222152) (22131241)
            (11231242) (12113152) (12122242) (12131332) (21231331) (22113241) (11213242)
            (22122331) (11222332) (22131421) (11231422) (12113332) (12122422) (12131512)
            (21231511) (22113421) (11213422) (22122511) (11222512) (13131151) (11331151)
            (12222151) (12231241) (13113151) (13122241) (11313151) (13131331) (11322241)
            (11331331) (12213241) (12222331) (12231421) (13113331) (13122421) (11313331)
            (13131511) (11322421) (11331511) (12213421) (12222511) (11141152) (21132151)
            (21141241) (11123152) (11132242) (11141332) (21114151) (21123241) (21132331)
            (21141421) (11114242) (11123332) (11132422) (11141512) (21114331) (21123421)
            (21132511) (12141151) (11232151) (11241241) (12123151) (12132241) (12141331)
            (11214151) (11223241) (11232331) (11241421) (12114241) (12123331) (12132421)
            (12141511) (11214331) (11223421) (11232511) (11151151) (11133151) (11142241)
            (11151331) (11115151) (11124241) (11133331) (11142421) (11151511) (11111254)
            (31111252) (21111343) (41111341) (11111434) (31111432) (21111523) (41111521)
            (11111614) (31111612) (31211161) (12111253) (32111251) (21211252) (22111342)
            (11211343) (31211341) (12111433) (32111431) (21211432) (22111522) (11211523)
            (31211521) (12111613) (32111611) (21211612) (12211162) (21311161) (13111252)
            (22211251) (11311252) (23111341) (12211342) (21311341) (13111432) (22211431)
            (11311432) (23111521) (12211522) (21311521) (13111612) (22211611) (11311612)
            (13211161) (11411161) (14111251) (12311251) (13211341) (11411341) (14111431)
            (12311431) (13211521) (11411521) (14111611) (12311611) (21121162) (11112163)
            (31112161) (11121253) (31121251) (21112252) (21121342) (11112343) (31112341)
            (11121433) (31121431) (21112432) (21121522) (11112523) (31112521) (11121613)
            (31121611) (22121161) (11221162) (12112162) (12121252) (21221251) (22112251)
            (11212252) (22121341) (11221342) (12112342) (12121432) (21221431) (22112431)
            (11212432) (22121521) (11221522) (12112522) (12121612) (21221611) (12221161)
            (13112161) (13121251) (11312161) (11321251) (32121115) (52121113) (21221116)
            (41221114) (61221112) (22112116) (42112114) (31212115) (51212113) (13121116)
            (33121114) (22221115) (42221113) (11321116) (31321114) (51321112) (23112115)
            (43112113) (12212116) (32212114) (52212112) (21312115) (41312113) (61312111)
            (14121115) (34121113) (23221114) (43221112) (12321115) (32321113) (52321111)
            (21421114) (41421112) (24112114) (13212115) (33212113) (22312114) (42312112)
            (11412115) (31412113) (51412111) (15121114) (24221113) (13321114) (33321112)
            (22421113) (42421111) (11521114) (31521112) (25112113) (14212114) (34212112)
            (23312113) (43312111) (12412114) (32412112) (21512113) (41512111) (16121113)
            (25221112) (14321113) (34321111) (23421112) (12521113) (32521111) (15212113)
            (24312112) (13412113) (33412111) (22512112) (11612113) (31612111) (31131115)
            (51131113) (21122116) (41122114) (61122112) (31113115) (51113113) (12131116)
            (32131114) (52131112) (21231115) (41231113) (61231111) (22122115) (42122113)
            (11222116) (31222114) (51222112) (12113116) (32113114) (52113112) (21213115)
            (41213113) (61213111) (13131115) (33131113) (22231114) (42231112) (11331115)
            (31331113) (51331111) (23122114) (43122112) (12222115) (32222113) (52222111)
            (21322114) (41322112) (13113115) (33113113) (22213114) (42213112) (11313115)
            (31313113) (51313111) (14131114) (34131112) (23231113) (43231111) (12331114)
            (32331112) (21431113) (41431111) (24122113) (13222114) (33222112) (22322113)
            (42322111) (11422114) (31422112) (14113114) (34113112) (23213113) (43213111)
            (12313114) (32313112) (21413113) (41413111) (15131113) (24231112) (13331113)
            (33331111) (22431112) (25122112) (14222113) (34222111) (23322112) (12422113)
            (32422111) (21522112) (15113113) (24213112) (13313113) (33313111) (22413112)
            (11513113) (31513111) (16131112) (25231111) (14331112) (23431111) (15222112)
            (24322111) (13422112) (22522111) (16113112) (25213111) (14313112) (23413111)
            (12513112) (21613111) (11141116) (31141114) (51141112) (21132115) (41132113)
            (61132111) (11123116) (31123114) (51123112) (21114115) (41114113) (61114111)
            (12141115) (32141113) (52141111) (21241114) (41241112) (22132114) (42132112)
            (11232115) (31232113) (51232111) (12123115) (32123113) (52123111) (21223114)
            (41223112) (22114114) (42114112) (11214115) (31214113) (51214111) (13141114)
            (33141112) (22241113) (42241111) (11341114) (31341112) (23132113) (43132111)
            (12232114) (32232112) (21332113) (41332111) (13123114) (33123112) (22223113)
            (42223111) (11323114) (31323112) (23114113) (43114111) (12214114) (32214112)
            (21314113) (41314111) (14141113) (34141111) (23241112) (12341113) (32341111)
            (24132112) (13232113) (33232111) (22332112) (11432113) (31432111) (14123113)
            (34123111) (23223112) (12323113) (32323111) (21423112) (24114112) (13214113)
            (33214111) (22314112) (11414113) (31414111) (15141112) (24241111) (13341112)
            (25132111) (14232112) (23332111) (12432112) (15123112) (24223111) (13323112)
            (22423111) (11523112) (25114111) (14214112) (23314111) (12414112) (21514111)
            (16141111) (14341111) (15232111) (13432111) (16123111) (14323111) (12523111)
            (15214111) (13414111) (11614111) (11151115) (31151113) (51151111) (21142114)
            (41142112) (11133115) (31133113) (51133111) (21124114) (41124112) (11115115)
            (31115113) (51115111) (12151114) (32151112) (21251113) (41251111) (22142113)
            (42142111) (11242114) (31242112) (12133114) (32133112) (21233113) (41233111)
            (22124113) (42124111) (11224114) (31224112) (12115114) (32115112) (21215113)
            (41215111) (13151113) (33151111) (22251112) (23142112) (12242113) (32242111)
            (21342112) (13133113) (33133111) (22233112) (11333113) (31333111) (23124112)
            (12224113) (32224111) (21324112) (13115113) (33115111) (22215112) (11315113)
            (31315111) (14151112) (23251111) (24142111) (13242112) (22342111) (14133112)
            (23233111) (12333112) (21433111) (24124111) (13224112) (22324111) (11424112)
            (14115112) (23215111) (12315112) (21415111) (15151111) (14242111) (15133111)
            (13333111) (14224111) (12424111) (15115111) (13315111) (11515111) (11161114)
            (31161112) (21152113) (41152111) (11143114) (31143112) (21134113) (41134111)
            (11125114) (31125112) (21116113) (41116111) (12161113) (32161111) (22152112)
            (11252113) (31252111) (12143113) (32143111) (21243112) (22134112) (11234113)
            (31234111) (12125113) (32125111) (21225112) (22116112) (11216113) (31216111)
            (13161112) (23152111) (12252112) (13143112) (22243111) (11343112) (23134111)
            (12234112) (21334111) (13125112) (22225111) (11325112) (23116111) (12216112)
            (21316111) (14161111) (13252111) (14143111) (12343111) (13234111) (11434111)
            (14125111) (12325111) (13216111) (11416111) (31111216) (51111214) (31211125)
            (51211123) (32111215) (52111213) (21211216) (41211214) (61211212) (12211126)
            (32211124) (52211122) (21311125) (41311123) (61311121) (13111216) (33111214)
            (22211215) (42211213) (11311216) (31311214) (51311212) (13211125) (33211123)
            (22311124) (42311122) (11411125) (31411123) (51411121) (14111215) (34111213)
            (23211214) (43211212) (12311215) (32311213) (52311211) (21411214) (41411212)
            (14211124) (34211122) (23311123) (43311121) (12411124) (32411122) (21511123)
            (41511121) (15111214) (24211213) (13311214) (33311212) (22411213) (42411211)
            (11511214) (31511212) (15211123) (24311122) (13411123) (33411121) (22511122)
            (11611123) (31611121) (16111213) (25211212) (14311213) (34311211) (23411212)
            (12511213) (32511211) (21611212) (21121126) (41121124) (61121122) (31112125)
            (51112123) (31121215) (51121213) (21112216) (41112214) (61112212) (22121125)
            (42121123) (11221126) (31221124) (51221122) (12112126) (32112124) (52112122)
            (12121216) (32121214) (52121212) (21221215) (41221213) (61221211) (22112215)
            (42112213) (11212216) (31212214) (51212212) (23121124) (43121122) (12221125)
            (32221123) (52221121) (21321124) (41321122) (13112125) (33112123) (13121215)
            (33121213) (11312125) (22221214) (42221212) (11321215) (31321213) (51321211)
            (23112214) (43112212) (12212215) (32212213) (52212211) (21312214) (41312212)
            (24121123) (13221124) (33221122) (22321123) (42321121) (11421124) (31421122)
            (14112124) (34112122) (14121214) (34121212) (12312124) (23221213) (43221211)
            (12321214) (32321212) (21421213) (41421211) (24112213) (13212214) (33212212)
            (22312213) (42312211) (11412214) (31412212) (25121122) (14221123) (34221121)
            (23321122) (12421123) (32421121) (21521122) (15112123) (15121213) (13312123)
            (24221212) (13321213) (33321211) (11512123) (22421212) (11521213) (31521211)
            (25112212) (14212213) (34212211) (23312212) (12412213) (32412211) (21512212)
            (15221122) (24321121) (13421122) (22521121) (16112122) (16121212) (14312122)
            (25221211) (14321212) (12512122) (23421211) (12521212) (15212212) (24312211)
            (13412212) (22512211) (11612212) (21131125) (41131123) (61131121) (11122126)
            (31122124) (51122122) (11131216) (31131214) (51131212) (21113125) (41113123)
            (61113121) (21122215) (41122213) (61122211) (11113216) (31113214) (51113212)
            (22131124) (42131122) (11231125) (31231123) (51231121) (12122125) (32122123)
            (52122121) (12131215) (32131213) (52131211) (21231214) (41231212) (22113124)
            (42113122) (11213125) (22122214) (42122212) (11222215) (31222213) (51222211)
            (12113215) (32113213) (52113211) (21213214) (41213212) (23131123) (43131121)
            (12231124) (32231122) (21331123) (41331121) (13122124) (33122122) (13131214)
            (33131212) (11322124) (22231213) (42231211) (11331214) (31331212) (23113123)
            (43113121) (12213124) (23122213) (43122211) (12222214) (32222212) (21322213)
            (41322211) (13113214) (33113212) (22213213) (42213211) (11313214) (31313212)
            (24131122) (13231123) (33231121) (22331122) (11431123) (31431121) (14122123)
            (34122121) (14131213) (34131211) (12322123) (23231212) (12331213) (32331211)
            (21431212) (24113122) (13213123) (24122212) (13222213) (33222211) (11413123)
            (22322212) (11422213) (31422211) (14113213) (34113211) (23213212) (12313213)
            (32313211) (21413212) (25131121) (14231122) (23331121) (12431122) (15122122)
            (15131212) (13322122) (24231211) (13331212) (11522122) (22431211) (25113121)
            (14213122) (25122211) (14222212) (12413122) (23322211) (12422212) (21522211)
            (15113212) (24213211) (13313212) (22413211) (11513212) (15231121) (13431121)
            (16122121) (16131211) (14322121) (14331211) (12522121) (15213121) (15222211)
            (13413121) (13422211) (11613121) (16113211) (14313211) (12513211) (21141124)
            (41141122) (11132125) (31132123) (51132121) (11141215) (31141213) (51141211)
            (21123124) (41123122) (21132214) (41132212) (11114125) (31114123) (51114121)
            (11123215) (31123213) (51123211) (21114214) (41114212) (22141123) (42141121)
            (11241124) (31241122) (12132124) (32132122) (12141214) (32141212) (21241213)
            (41241211) (22123123) (42123121) (11223124) (22132213) (42132211) (11232214)
            (31232212) (12114124) (32114122) (12123214) (32123212) (21223213) (41223211)
            (22114213) (42114211) (11214214) (31214212) (23141122) (12241123) (32241121)
            (21341122) (13132123) (33132121) (13141213) (33141211) (11332123) (22241212)
            (11341213) (31341211) (23123122) (12223123) (23132212) (12232213) (32232211)
            (21332212) (13114123) (33114121) (13123213) (33123211) (11314123) (22223212)
            (11323213) (31323211) (23114212) (12214213) (32214211) (21314212) (24141121)
            (13241122) (22341121) (14132122) (14141212) (12332122) (23241211) (12341212)
            (24123121) (13223122) (24132211) (13232212) (11423122) (22332211) (11432212)
            (14114122) (14123212) (12314122) (23223211) (12323212) (21423211) (24114211)
            (13214212) (22314211) (11414212) (14241121) (15132121) (15141211) (13332121)
            (13341211) (14223121) (14232211) (12423121) (12432211) (15114121) (15123211)
            (13314121) (13323211) (11514121) (11523211) (14214211) (12414211) (21151123)
            (41151121) (11142124) (31142122) (11151214) (31151212) (21133123) (41133121)
            (21142213) (41142211) (11124124) (31124122) (11133214) (31133212) (21115123)
            (41115121) (21124213) (41124211) (11115214) (31115212) (22151122) (11251123)
            (31251121) (12142123) (32142121) (12151213) (32151211) (21251212) (22133122)
            (11233123) (22142212) (11242213) (31242211) (12124123) (32124121) (12133213)
            (32133211) (21233212) (22115122) (11215123) (22124212) (11224213) (31224211)
            (12115213) (32115211) (21215212) (23151121) (12251122) (13142122) (13151212)
            (11342122) (22251211) (23133121) (12233122) (23142211) (12242212) (21342211)
            (13124122) (13133212) (11324122) (22233211) (11333212) (23115121) (12215122)
            (23124211) (12224212) (21324211) (13115212) (22215211) (11315212) (13251121)
            (14142121) (14151211) (12342121) (13233121) (13242211) (11433121) (14124121)
            (14133211) (12324121) (12333211) (13215121) (13224211) (11415121) (11424211)
            (14115211) (12315211) (21161122) (11152123) (31152121) (11161213) (31161211)
            (21143122) (21152212) (11134123) (31134121) (11143213) (31143211) (21125122)
            (21134212) (11116123) (31116121) (11125213) (31125211) (22161121) (12152122)
            (12161212) (22143121) (11243122) (22152211) (11252212) (12134122) (12143212)
            (21243211) (22125121) (11225122) (22134211) (11234212) (12116122) (12125212)
            (21225211) (13152121) (13161211) (12243121) (12252211) (13134121) (13143211)
            (11334121) (11343211) (12225121) (12234211) (13116121) (13125211) (11316121)
            (11325211) (21111226) (41111224) (61111222) (31111315) (51111313) (21211135)
            (41211133) (61211131) (22111225) (42111223) (11211226) (31211224) (51211222)
            (12111316) (32111314) (52111312) (21211315) (41211313) (61211311) (22211134)
            (42211132) (11311135) (31311133) (51311131) (23111224) (43111222) (12211225)
            (32211223) (52211221) (21311224) (41311222) (13111315) (33111313) (22211314)
            (42211312) (11311315) (31311313) (51311311) (23211133) (43211131) (12311134)
            (32311132) (21411133) (41411131) (24111223) (13211224) (33211222) (22311223)
            (42311221) (11411224) (31411222) (14111314) (34111312) (23211313) (43211311)
            (12311314) (32311312) (21411313) (41411311) (24211132) (13311133) (33311131)
            (22411132) (11511133) (31511131) (25111222) (14211223) (34211221) (23311222)
            (12411223) (32411221) (21511222) (15111313) (24211312) (13311313) (33311311)
            (22411312) (11511313) (31511311) (25211131) (14311132) (23411131) (12511132)
            (21611131) (15211222) (24311221) (13411222) (22511221) (11611222) (16111312)
            (25211311) (14311312) (23411311) (12511312) (21611311) (31121134) (51121132)
            (21112135) (41112133) (61112131) (21121225) (41121223) (61121221) (11112226)
            (31112224) (51112222) (11121316) (31121314) (51121312) (21112315) (41112313)
            (61112311) (12121135) (32121133) (52121131) (21221134) (41221132) (22112134)
            (42112132) (11212135) (22121224) (42121222) (11221225) (31221223) (51221221)
            (12112225) (32112223) (52112221) (12121315) (32121313) (52121311) (21221314)
            (41221312) (22112314) (42112312) (11212315) (31212313) (51212311) (13121134)
            (33121132) (22221133) (42221131) (11321134) (31321132) (23112133) (43112131)
            (12212134) (23121223) (43121221) (12221224) (32221222) (21321223) (41321221)
            (13112224) (33112222) (13121314) (33121312) (11312224) (22221313) (42221311)
            (11321314) (31321312) (23112313) (43112311) (12212314) (32212312) (21312313)
            (41312311) (14121133) (34121131) (23221132) (12321133) (32321131) (21421132)
            (24112132) (13212133) (24121222) (13221223) (33221221) (11412133) (22321222)
            (11421223) (31421221) (14112223) (34112221) (14121313) (34121311) (12312223)
            (23221312) (12321313) (32321311) (21421312) (24112312) (13212313) (33212311)
            (22312312) (11412313) (31412311) (15121132) (24221131) (13321132) (22421131)
        ] [  % Odd parity
            (22121116) (42121114) (31221115) (51221113) (32112115) (52112113) (21212116)
            (41212114) (61212112) (23121115) (43121113) (12221116) (32221114) (52221112)
            (21321115) (41321113) (61321111) (13112116) (33112114) (22212115) (42212113)
            (11312116) (31312114) (51312112) (24121114) (13221115) (33221113) (22321114)
            (42321112) (11421115) (31421113) (51421111) (14112115) (34112113) (23212114)
            (43212112) (12312115) (32312113) (52312111) (21412114) (41412112) (25121113)
            (14221114) (34221112) (23321113) (43321111) (12421114) (32421112) (21521113)
            (41521111) (15112114) (24212113) (13312114) (33312112) (22412113) (42412111)
            (11512114) (31512112) (15221113) (24321112) (13421113) (33421111) (22521112)
            (16112113) (25212112) (14312113) (34312111) (23412112) (12512113) (32512111)
            (21612112) (21131116) (41131114) (61131112) (31122115) (51122113) (21113116)
            (41113114) (61113112) (22131115) (42131113) (11231116) (31231114) (51231112)
            (12122116) (32122114) (52122112) (21222115) (41222113) (61222111) (22113115)
            (42113113) (11213116) (31213114) (51213112) (23131114) (43131112) (12231115)
            (32231113) (52231111) (21331114) (41331112) (13122115) (33122113) (22222114)
            (42222112) (11322115) (31322113) (51322111) (23113114) (43113112) (12213115)
            (32213113) (52213111) (21313114) (41313112) (24131113) (13231114) (33231112)
            (22331113) (42331111) (11431114) (31431112) (14122114) (34122112) (23222113)
            (43222111) (12322114) (32322112) (21422113) (41422111) (24113113) (13213114)
            (33213112) (22313113) (42313111) (11413114) (31413112) (25131112) (14231113)
            (34231111) (23331112) (12431113) (32431111) (15122113) (24222112) (13322113)
            (33322111) (22422112) (11522113) (31522111) (25113112) (14213113) (34213111)
            (23313112) (12413113) (32413111) (21513112) (15231112) (24331111) (13431112)
            (16122112) (25222111) (14322112) (23422111) (12522112) (15213112) (24313111)
            (13413112) (22513111) (11613112) (21141115) (41141113) (61141111) (11132116)
            (31132114) (51132112) (21123115) (41123113) (61123111) (11114116) (31114114)
            (51114112) (22141114) (42141112) (11241115) (31241113) (51241111) (12132115)
            (32132113) (52132111) (21232114) (41232112) (22123114) (42123112) (11223115)
            (31223113) (51223111) (12114115) (32114113) (52114111) (21214114) (41214112)
            (23141113) (43141111) (12241114) (32241112) (21341113) (41341111) (13132114)
            (33132112) (22232113) (42232111) (11332114) (31332112) (23123113) (43123111)
            (12223114) (32223112) (21323113) (41323111) (13114114) (33114112) (22214113)
            (42214111) (11314114) (31314112) (24141112) (13241113) (33241111) (22341112)
            (14132113) (34132111) (23232112) (12332113) (32332111) (21432112) (24123112)
            (13223113) (33223111) (22323112) (11423113) (31423111) (14114113) (34114111)
            (23214112) (12314113) (32314111) (21414112) (25141111) (14241112) (23341111)
            (15132112) (24232111) (13332112) (22432111) (25123111) (14223112) (23323111)
            (12423112) (21523111) (15114112) (24214111) (13314112) (22414111) (11514112)
            (15241111) (16132111) (14332111) (15223111) (13423111) (16114111) (14314111)
            (12514111) (21151114) (41151112) (11142115) (31142113) (51142111) (21133114)
            (41133112) (11124115) (31124113) (51124111) (21115114) (41115112) (22151113)
            (42151111) (11251114) (31251112) (12142114) (32142112) (21242113) (41242111)
            (22133113) (42133111) (11233114) (31233112) (12124114) (32124112) (21224113)
            (41224111) (22115113) (42115111) (11215114) (31215112) (23151112) (12251113)
            (32251111) (13142113) (33142111) (22242112) (11342113) (31342111) (23133112)
            (12233113) (32233111) (21333112) (13124113) (33124111) (22224112) (11324113)
            (31324111) (23115112) (12215113) (32215111) (21315112) (24151111) (13251112)
            (14142112) (23242111) (12342112) (24133111) (13233112) (22333111) (11433112)
            (14124112) (23224111) (12324112) (21424111) (24115111) (13215112) (22315111)
            (11415112) (14251111) (15142111) (13342111) (14233111) (12433111) (15124111)
            (13324111) (11524111) (14215111) (12415111) (21161113) (41161111) (11152114)
            (31152112) (21143113) (41143111) (11134114) (31134112) (21125113) (41125111)
            (11116114) (31116112) (22161112) (12152113) (32152111) (21252112) (22143112)
            (11243113) (31243111) (12134113) (32134111) (21234112) (22125112) (11225113)
            (31225111) (12116113) (32116111) (21216112) (23161111) (13152112) (22252111)
            (23143111) (12243112) (21343111) (13134112) (22234111) (11334112) (23125111)
            (12225112) (21325111) (13116112) (22216111) (11316112) (14152111) (13243111)
            (14134111) (12334111) (13225111) (11425111) (14116111) (12316111) (41111215)
            (61111213) (21211126) (41211124) (61211122) (22111216) (42111214) (31211215)
            (51211213) (22211125) (42211123) (11311126) (31311124) (51311122) (23111215)
            (43111213) (12211216) (32211214) (52211212) (21311215) (41311213) (61311211)
            (23211124) (43211122) (12311125) (32311123) (52311121) (21411124) (41411122)
            (24111214) (13211215) (33211213) (22311214) (42311212) (11411215) (31411213)
            (51411211) (24211123) (13311124) (33311122) (22411123) (42411121) (11511124)
            (31511122) (25111213) (14211214) (34211212) (23311213) (43311211) (12411214)
            (32411212) (21511213) (41511211) (25211122) (14311123) (34311121) (23411122)
            (12511123) (32511121) (21611122) (15211213) (24311212) (13411213) (33411211)
            (22511212) (11611213) (31611211) (31121125) (51121123) (21112126) (41112124)
            (61112122) (21121216) (41121214) (61121212) (31112215) (51112213) (12121126)
            (32121124) (52121122) (21221125) (41221123) (61221121) (22112125) (42112123)
            (11212126) (22121215) (42121213) (11221216) (31221214) (51221212) (12112216)
            (32112214) (52112212) (21212215) (41212213) (61212211) (13121125) (33121123)
            (22221124) (42221122) (11321125) (31321123) (51321121) (23112124) (43112122)
            (12212125) (23121214) (43121212) (12221215) (32221213) (52221211) (21321214)
            (41321212) (13112215) (33112213) (22212214) (42212212) (11312215) (31312213)
            (51312211) (14121124) (34121122) (23221123) (43221121) (12321124) (32321122)
            (21421123) (41421121) (24112123) (13212124) (24121213) (13221214) (33221212)
            (11412124) (22321213) (42321211) (11421214) (31421212) (14112214) (34112212)
            (23212213) (43212211) (12312214) (32312212) (21412213) (41412211) (15121123)
            (24221122) (13321123) (33321121) (22421122) (11521123) (31521121) (25112122)
            (14212123) (25121212) (14221213) (34221211) (12412123) (23321212) (12421213)
            (32421211) (21521212) (15112213) (24212212) (13312213) (33312211) (22412212)
            (11512213) (31512211) (16121122) (25221121) (14321122) (23421121) (12521122)
            (15212122) (15221212) (13412122) (24321211) (13421212) (11612122) (22521211)
            (16112212) (25212211) (14312212) (23412211) (12512212) (21612211) (11131126)
            (31131124) (51131122) (21122125) (41122123) (61122121) (21131215) (41131213)
            (61131211) (11113126) (31113124) (51113122) (11122216) (31122214) (51122212)
            (21113215) (41113213) (61113211) (12131125) (32131123) (52131121) (21231124)
            (41231122) (22122124) (42122122) (11222125) (22131214) (42131212) (11231215)
            (31231213) (51231211) (12113125) (32113123) (52113121) (12122215) (32122213)
            (52122211) (21222214) (41222212) (22113214) (42113212) (11213215) (31213213)
            (51213211) (13131124) (33131122) (22231123) (42231121) (11331124) (31331122)
            (23122123) (43122121) (12222124) (23131213) (43131211) (12231214) (32231212)
            (21331213) (41331211) (13113124) (33113122) (13122214) (33122212) (11313124)
            (22222213) (42222211) (11322214) (31322212) (23113213) (43113211) (12213214)
            (32213212) (21313213) (41313211) (14131123) (34131121) (23231122) (12331123)
            (32331121) (21431122) (24122122) (13222123) (24131212) (13231213) (33231211)
            (11422123) (22331212) (11431213) (31431211) (14113123) (34113121) (14122213)
            (34122211) (12313123) (23222212) (12322213) (32322211) (21422212) (24113212)
            (13213213) (33213211) (22313212) (11413213) (31413211) (15131122) (24231121)
            (13331122) (22431121) (25122121) (14222122) (25131211) (14231212) (12422122)
            (23331211) (12431212) (15113122) (15122212) (13313122) (24222211) (13322212)
            (11513122) (22422211) (11522212) (25113211) (14213212) (23313211) (12413212)
            (21513211) (16131121) (14331121) (15222121) (15231211) (13422121) (13431211)
            (16113121) (16122211) (14313121) (14322211) (12513121) (12522211) (15213211)
            (13413211) (11613211) (11141125) (31141123) (51141121) (21132124) (41132122)
            (21141214) (41141212) (11123125) (31123123) (51123121) (11132215) (31132213)
            (51132211) (21114124) (41114122) (21123214) (41123212) (11114215) (31114213)
            (51114211) (12141124) (32141122) (21241123) (41241121) (22132123) (42132121)
            (11232124) (22141213) (42141211) (11241214) (31241212) (12123124) (32123122)
            (12132214) (32132212) (21232213) (41232211) (22114123) (42114121) (11214124)
            (22123213) (42123211) (11223214) (31223212) (12114214) (32114212) (21214213)
            (41214211) (13141123) (33141121) (22241122) (11341123) (31341121) (23132122)
            (12232123) (23141212) (12241213) (32241211) (21341212) (13123123) (33123121)
            (13132213) (33132211) (11323123) (22232212) (11332213) (31332211) (23114122)
            (12214123) (23123212) (12223213) (32223211) (21323212) (13114213) (33114211)
            (22214212) (11314213) (31314211) (14141122) (23241121) (12341122) (24132121)
            (13232122) (24141211) (13241212) (11432122) (22341211) (14123122) (14132212)
            (12323122) (23232211) (12332212) (21432211) (24114121) (13214122) (24123211)
            (13223212) (11414122) (22323211) (11423212) (14114212) (23214211) (12314212)
            (21414211) (15141121) (13341121) (14232121) (14241211) (12432121) (15123121)
            (15132211) (13323121) (13332211) (11523121) (14214121) (14223211) (12414121)
            (12423211) (15114211) (13314211) (11514211) (11151124) (31151122) (21142123)
            (41142121) (21151213) (41151211) (11133124) (31133122) (11142214) (31142212)
            (21124123) (41124121) (21133213) (41133211) (11115124) (31115122) (11124214)
            (31124212) (21115213) (41115211) (12151123) (32151121) (21251122) (22142122)
            (11242123) (22151212) (11251213) (31251211) (12133123) (32133121) (12142213)
            (32142211) (21242212) (22124122) (11224123) (22133212) (11233213) (31233211)
            (12115123) (32115121) (12124213) (32124211) (21224212) (22115212) (11215213)
            (31215211) (13151122) (22251121) (23142121) (12242122) (23151211) (12251212)
            (13133122) (13142212) (11333122) (22242211) (11342212) (23124121) (12224122)
            (23133211) (12233212) (21333211) (13115122) (13124212) (11315122) (22224211)
            (11324212) (23115211) (12215212) (21315211) (14151121) (13242121) (13251211)
            (14133121) (14142211) (12333121) (12342211) (13224121) (13233211) (11424121)
            (11433211) (14115121) (14124211) (12315121) (12324211) (13215211) (11415211)
            (11161123) (31161121) (21152122) (21161212) (11143123) (31143121) (11152213)
            (31152211) (21134122) (21143212) (11125123) (31125121) (11134213) (31134211)
            (21116122) (21125212) (12161122) (22152121) (11252122) (22161211) (12143122)
            (12152212) (21252211) (22134121) (11234122) (22143211) (11243212) (12125122)
            (12134212) (21234211) (22116121) (11216122) (22125211) (11225212) (13161121)
            (12252121) (13143121) (13152211) (11343121) (12234121) (12243211) (13125121)
            (13134211) (11325121) (11334211) (12216121) (12225211) (31111225) (51111223)
            (21111316) (41111314) (61111312) (31211134) (51211132) (12111226) (32111224)
            (52111222) (21211225) (41211223) (61211221) (22111315) (42111313) (11211316)
            (31211314) (51211312) (12211135) (32211133) (52211131) (21311134) (41311132)
            (13111225) (33111223) (22211224) (42211222) (11311225) (31311223) (51311221)
            (23111314) (43111312) (12211315) (32211313) (52211311) (21311314) (41311312)
            (13211134) (33211132) (22311133) (42311131) (11411134) (31411132) (14111224)
            (34111222) (23211223) (43211221) (12311224) (32311222) (21411223) (41411221)
            (24111313) (13211314) (33211312) (22311313) (42311311) (11411314) (31411312)
            (14211133) (34211131) (23311132) (12411133) (32411131) (21511132) (15111223)
            (24211222) (13311223) (33311221) (22411222) (11511223) (31511221) (25111312)
            (14211313) (34211311) (23311312) (12411313) (32411311) (21511312) (15211132)
            (24311131) (13411132) (22511131) (11611132) (16111222) (25211221) (14311222)
            (23411221) (12511222) (21611221) (15211312) (24311311) (13411312) (22511311)
            (11611312) (21121135) (41121133) (61121131) (11112136) (31112134) (51112132)
            (11121226) (31121224) (51121222) (21112225) (41112223) (61112221) (21121315)
            (41121313) (61121311) (11112316) (31112314) (51112312) (22121134) (42121132)
            (11221135) (31221133) (51221131) (12112135) (32112133) (52112131) (12121225)
            (32121223) (52121221) (21221224) (41221222) (22112224) (42112222) (11212225)
            (22121314) (42121312) (11221315) (31221313) (51221311) (12112315) (32112313)
            (52112311) (21212314) (41212312) (23121133) (43121131) (12221134) (32221132)
            (21321133) (41321131) (13112134) (33112132) (13121224) (33121222) (11312134)
            (22221223) (42221221) (11321224) (31321222) (23112223) (43112221) (12212224)
            (23121313) (43121311) (12221314) (32221312) (21321313) (41321311) (13112314)
            (33112312) (22212313) (42212311) (11312314) (31312312) (24121132) (13221133)
            (33221131) (22321132) (11421133) (31421131) (14112133) (34112131) (14121223)
            (34121221) (12312133) (23221222) (12321223) (32321221) (21421222) (24112222)
            (13212223) (24121312) (13221313) (33221311) (11412223) (22321312) (11421313)
            (31421311) (14112313) (34112311) (23212312) (12312313) (32312311) (21412312)
            (25121131) (14221132) (23321131) (12421132) (21521131) (15112132) (15121222)
            (13312132) (24221221) (13321222) (11512132) (22421221) (11521222) (25112221)
            (14212222) (25121311) (14221312) (12412222) (23321311) (12421312) (21521311)
            (15112312) (24212311) (13312312) (22412311) (11512312) (15221131) (13421131)
            (16112131) (16121221) (14312131) (14321221) (12512131) (12521221) (15212221)
            (15221311) (13412221) (13421311) (11612221) (16112311) (14312311) (12512311)
            (21131134) (41131132) (11122135) (31122133) (51122131) (11131225) (31131223)
            (51131221) (21113134) (41113132) (21122224) (41122222) (21131314) (41131312)
            (11113225) (31113223) (51113221) (11122315) (31122313) (51122311) (21113314)
            (41113312) (22131133) (42131131) (11231134) (31231132) (12122134) (32122132)
            (12131224) (32131222) (21231223) (41231221) (22113133) (42113131) (11213134)
            (22122223) (42122221) (11222224) (22131313) (42131311) (11231314) (31231312)
            (12113224) (32113222) (12122314) (32122312) (21222313) (41222311) (22113313)
            (42113311) (11213314) (31213312) (23131132) (12231133) (32231131) (21331132)
            (13122133) (33122131) (13131223) (33131221) (11322133) (22231222) (11331223)
            (31331221) (23113132) (12213133) (23122222) (12222223) (23131312) (12231313)
            (32231311) (21331312) (13113223) (33113221) (13122313) (33122311) (11313223)
            (22222312) (11322313) (31322311) (23113312) (12213313) (32213311) (21313312)
            (24131131) (13231132) (22331131) (11431132) (14122132) (14131222) (12322132)
            (23231221) (12331222) (21431221) (24113131) (13213132) (24122221) (13222222)
            (24131311) (11413132) (13231312) (11422222) (22331311) (11431312) (14113222)
            (14122312) (12313222) (23222311) (12322312) (21422311) (24113311) (13213312)
            (22313311) (11413312) (14231131) (12431131) (15122131) (15131221) (13322131)
            (13331221) (11522131) (14213131) (14222221) (12413131) (14231311) (12422221)
            (12431311) (15113221) (15122311) (13313221) (13322311) (11513221) (11522311)
            (14213311) (12413311) (21141133) (41141131) (11132134) (31132132) (11141224)
            (31141222) (21123133) (41123131) (21132223) (41132221) (21141313) (41141311)
            (11114134) (31114132) (11123224) (31123222) (11132314) (31132312) (21114223)
            (41114221) (21123313) (41123311) (11114314) (31114312) (22141132) (11241133)
            (31241131) (12132133) (32132131) (12141223) (32141221) (21241222) (22123132)
            (11223133) (22132222) (11232223) (22141312) (11241313) (31241311) (12114133)
            (32114131) (12123223) (32123221) (12132313) (32132311) (21232312) (22114222)
            (11214223) (22123312) (11223313) (31223311) (12114313) (32114311) (21214312)
            (23141131) (12241132) (21341131) (13132132) (13141222) (11332132) (22241221)
            (11341222) (23123131) (12223132) (23132221) (12232222) (23141311) (12241312)
            (21341311) (13114132) (13123222) (11314132) (13132312) (11323222) (22232311)
            (11332312) (23114221) (12214222) (23123311) (12223312) (21323311) (13114312)
            (22214311) (11314312) (13241131) (14132131) (14141221) (12332131) (12341221)
            (13223131) (13232221) (11423131) (13241311) (11432221) (14114131) (14123221)
            (12314131) (14132311) (12323221) (12332311) (13214221) (13223311) (11414221)
            (11423311) (14114311) (12314311) (21151132) (11142133) (31142131) (11151223)
            (31151221) (21133132) (21142222) (21151312) (11124133) (31124131) (11133223)
            (31133221) (11142313) (31142311) (21115132) (21124222) (21133312) (11115223)
            (31115221) (11124313) (31124311) (22151131) (11251132) (12142132) (12151222)
            (21251221) (22133131) (11233132) (22142221) (11242222) (22151311) (11251312)
            (12124132) (12133222) (12142312) (21242311) (22115131) (11215132) (22124221)
            (11224222) (22133311) (11233312) (12115222) (12124312) (21224311) (12251131)
            (13142131) (13151221) (11342131) (12233131) (12242221) (12251311) (13124131)
            (13133221) (11324131) (13142311) (11333221) (11342311) (12215131) (12224221)
            (12233311) (13115221) (13124311) (11315221) (11324311) (21161131) (11152132)
            (11161222) (21143131) (21152221) (21161311) (11134132) (11143222) (11152312)
            (21125131) (21134221) (21143311) (11116132) (11125222) (11134312) (12152131)
            (12161221) (11243131) (11252221) (12134131) (12143221) (12152311) (11225131)
            (11234221) (11243311) (12116131) (12125221) (12134311) (21111235) (41111233)
            (61111231) (11111326) (31111324) (51111322) (21111415) (41111413) (61111411)
            (21211144) (41211142) (22111234) (42111232) (11211235) (31211233) (51211231)
            (12111325) (32111323) (52111321) (21211324) (41211322) (22111414) (42111412)
            (11211415) (31211413) (51211411) (22211143) (42211141) (11311144) (31311142)
            (23111233) (43111231) (12211234) (32211232) (21311233) (41311231) (13111324)
            (33111322) (22211323) (42211321) (11311324) (31311322) (23111413) (43111411)
            (12211414) (32211412) (21311413) (41311411) (23211142) (12311143) (32311141)
            (21411142) (24111232) (13211233) (33211231) (22311232) (11411233) (31411231)
            (14111323) (34111321) (23211322) (12311323) (32311321) (21411322) (24111412)
            (13211413) (33211411) (22311412) (11411413) (31411411) (24211141) (13311142)
            (22411141) (11511142) (25111231) (14211232) (23311231) (12411232) (21511231)
            (15111322) (24211321) (13311322) (22411321) (11511322) (25111411) (14211412)
            (23311411) (12411412) (21511411) (14311141) (12511141) (15211231) (13411231)
            (11611231) (16111321) (14311321) (12511321) (15211411) (13411411) (11611411)
            (31121143) (51121141) (21112144) (41112142) (21121234) (41121232) (11112235)
            (31112233) (51112231) (11121325) (31121323) (51121321) (21112324) (41112322)
            (21121414) (41121412) (11112415) (31112413) (51112411) (12121144) (32121142)
            (21221143) (41221141) (22112143) (42112141) (11212144) (22121233) (42121231)
            (11221234) (31221232) (12112234) (32112232) (12121324) (32121322) (21221323)
            (41221321) (22112323) (42112321) (11212324) (22121413) (42121411) (11221414)
            (31221412) (12112414) (32112412) (21212413) (41212411) (13121143) (33121141)
            (22221142) (11321143) (31321141) (23112142) (12212143) (23121232) (12221233)
            (32221231) (21321232) (13112233) (33112231) (13121323) (33121321) (11312233)
            (22221322) (11321323) (31321321) (23112322) (12212323) (23121412) (12221413)
            (32221411) (21321412) (13112413) (33112411) (22212412) (11312413) (31312411)
            (14121142) (23221141) (12321142) (21421141) (24112141) (13212142) (24121231)
            (13221232) (11412142) (22321231) (11421232) (14112232) (14121322) (12312232)
            (23221321) (12321322) (21421321) (24112321) (13212322) (24121411) (13221412)
            (11412322) (22321411) (11421412) (14112412) (23212411) (12312412) (21412411)
            (15121141) (13321141) (11521141) (14212141) (14221231) (12412141) (12421231)
            (15112231) (15121321) (13312231) (13321321) (11512231) (11521321) (14212321)
            (14221411) (12412321) (12421411) (15112411) (13312411) (11512411) (11131144)
            (31131142) (21122143) (41122141) (21131233) (41131231) (11113144) (31113142)
            (11122234) (31122232) (11131324) (31131322) (21113233) (41113231) (21122323)
            (41122321) (21131413) (41131411) (11113324) (31113322) (11122414) (31122412)
            (21113413) (41113411) (12131143) (32131141) (21231142) (22122142) (11222143)
            (22131232) (11231233) (31231231) (12113143) (32113141) (12122233) (32122231)
            (12131323) (32131321) (21231322) (22113232) (11213233) (22122322) (11222323)
            (22131412) (11231413) (31231411) (12113323) (32113321) (12122413) (32122411)
            (21222412) (22113412) (11213413) (31213411) (13131142) (22231141) (11331142)
            (23122141) (12222142) (23131231) (12231232) (21331231) (13113142) (13122232)
            (11313142) (13131322) (11322232) (22231321) (11331322) (23113231) (12213232)
            (23122321) (12222322) (23131411) (12231412) (21331411) (13113322) (13122412)
            (11313322) (22222411) (11322412) (23113411) (12213412) (21313411) (14131141)
            (12331141) (13222141) (13231231) (11422141) (11431231) (14113141) (14122231)
            (12313141) (14131321) (12322231) (12331321) (13213231) (13222321) (11413231)
            (13231411) (11422321) (11431411) (14113321) (14122411) (12313321) (12322411)
            (13213411) (11413411) (11141143) (31141141) (21132142) (21141232) (11123143)
            (31123141) (11132233) (31132231) (11141323) (31141321) (21114142) (21123232)
            (21132322) (21141412) (11114233) (31114231) (11123323) (31123321) (11132413)
            (31132411) (21114322) (21123412) (12141142) (21241141) (22132141) (11232142)
            (22141231) (11241232) (12123142) (12132232) (12141322) (21241321) (22114141)
            (11214142) (22123231) (11223232) (22132321) (11232322) (22141411) (11241412)
            (12114232) (12123322) (12132412) (21232411) (22114321) (11214322) (22123411)
            (11223412) (13141141) (11341141) (12232141) (12241231) (13123141) (13132231)
            (11323141) (13141321) (11332231) (11341321) (12214141) (12223231) (12232321)
            (12241411) (13114231) (13123321) (11314231) (13132411) (11323321) (11332411)
            (12214321) (12223411) (11151142) (21142141) (21151231) (11133142) (11142232)
            (11151322) (21124141) (21133231) (21142321) (21151411) (11115142) (11124232)
            (11133322) (11142412) (21115231) (21124321) (21133411) (12151141) (11242141)
            (11251231) (12133141) (12142231) (12151321) (11224141) (11233231) (11242321)
            (11251411) (12115141) (12124231) (12133321) (12142411) (11215231) (11224321)
            (11233411) (11161141) (11143141) (11152231) (11161321) (11125141) (11134231)
            (11143321) (11152411) (11111245) (31111243) (51111241) (21111334) (41111332)
            (11111425) (31111423) (51111421) (21111514) (41111512) (31211152) (12111244)
            (32111242) (21211243) (41211241) (22111333) (42111331) (11211334) (31211332)
            (12111424) (32111422) (21211423) (41211421) (22111513) (42111511) (11211514)
            (31211512) (12211153) (32211151) (21311152) (13111243) (33111241) (22211242)
            (11311243) (31311241) (23111332) (12211333) (32211331) (21311332) (13111423)
            (33111421) (22211422) (11311423) (31311421) (23111512) (12211513) (32211511)
            (21311512) (13211152) (22311151) (11411152) (14111242) (23211241) (12311242)
            (21411241) (24111331) (13211332) (22311331) (11411332) (14111422) (23211421)
            (12311422) (21411421) (24111511) (13211512) (22311511) (11411512) (14211151)
            (12411151) (15111241) (13311241) (11511241) (14211331) (12411331) (15111421)
            (13311421) (11511421) (14211511) (12411511) (21121153) (41121151) (11112154)
            (31112152) (11121244) (31121242) (21112243) (41112241) (21121333) (41121331)
            (11112334) (31112332) (11121424) (31121422) (21112423) (41112421) (21121513)
            (41121511) (11112514) (31112512) (22121152) (11221153) (31221151) (12112153)
            (32112151) (12121243) (32121241) (21221242) (22112242) (11212243) (22121332)
            (11221333) (31221331) (12112333) (32112331) (12121423) (32121421) (21221422)
            (22112422) (11212423) (22121512) (11221513) (31221511) (12112513) (32112511)
            (21212512) (23121151) (12221152) (21321151) (13112152) (13121242) (11312152)
            (22221241) (11321242) (23112241) (12212242) (23121331) (12221332) (21321331)
            (13112332) (13121422) (11312332) (22221421) (11321422) (23112421) (12212422)
            (23121511) (12221512) (21321511) (13112512) (22212511) (11312512) (13221151)
            (11421151) (14112151) (14121241) (12312151) (12321241) (13212241) (13221331)
            (11412241) (11421331) (14112331) (14121421) (12312331) (12321421) (13212421)
            (13221511) (11412421) (11421511) (14112511) (12312511) (21131152) (11122153)
            (31122151) (11131243) (31131241) (21113152) (21122242) (21131332) (11113243)
            (31113241) (11122333) (31122331) (11131423) (31131421) (21113332) (21122422)
            (21131512) (11113423) (31113421) (11122513) (31122511) (22131151) (11231152)
            (12122152) (12131242) (21231241) (22113151) (11213152) (22122241) (11222242)
            (22131331) (11231332) (12113242) (12122332) (12131422) (21231421) (22113331)
            (11213332) (22122421) (11222422) (22131511) (11231512) (12113422) (12122512)
            (21222511) (12231151) (13122151) (13131241) (11322151) (11331241) (12213151)
            (12222241) (12231331) (13113241) (13122331) (11313241) (13131421) (11322331)
            (11331421) (12213331) (12222421) (12231511) (13113421) (13122511) (11313421)
            (11322511) (21141151) (11132152) (11141242) (21123151) (21132241) (21141331)
            (11114152) (11123242) (11132332) (11141422) (21114241) (21123331) (21132421)
            (21141511) (11114332) (11123422) (11132512) (11241151) (12132151) (12141241)
            (11223151) (11232241) (11241331) (12114151) (12123241) (12132331) (12141421)
            (11214241) (11223331) (11232421) (11241511) (12114331) (12123421) (12132511)
            (11142151) (11151241) (11124151) (11133241) (11142331) (11151421) (11115241)
            (11124331) (11133421) (11142511) (21111253) (41111251) (11111344) (31111342)
            (21111433) (41111431) (11111524) (31111522) (21111613) (41111611) (21211162)
            (22111252) (11211253) (31211251) (12111343) (32111341) (21211342) (22111432)
            (11211433) (31211431) (12111523) (32111521) (21211522) (22111612) (11211613)
            (31211611) (22211161) (11311162) (23111251) (12211252) (21311251) (13111342)
            (22211341) (11311342) (23111431) (12211432) (21311431) (13111522) (22211521)
            (11311522) (23111611) (12211612) (21311611) (12311161) (13211251) (11411251)
            (14111341) (12311341) (13211431) (11411431) (14111521) (12311521) (13211611)
            (11411611) (31121161) (21112162) (21121252) (11112253) (31112251) (11121343)
            (31121341) (21112342) (21121432) (11112433) (31112431) (11121523) (31121521)
            (21112522) (21121612) (12121162) (21221161) (22112161) (11212162) (22121251)
            (11221252) (12112252) (12121342) (21221341) (22112341) (11212342) (22121431)
            (11221432) (12112432) (12121522) (21221521) (22112521) (11212522) (22121611)
            (11221612) (13121161) (11321161) (12212161) (12221251) (13112251) (13121341)
            (11312251) (11321341) (12212341) (12221431) (13112431) (13121521) (11312431)
            (11321521) (12212521) (12221611) (11131162) (21122161) (21131251) (11113162)
        ]
    ] def

    /parity [
        (1001) (0101) (1100) (0011) (1010) (0110) (1111) (0000)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /p i r 1 sub ne {parity i get} {(0000)} ifelse def
        /ccrow ccs i 8 mul 8 getinterval def
        /scrow [
            0 2 7 {ccrow exch 2 getinterval aload pop exch 49 mul add} for
        ] def
        /sbs [
            10 1 1
            0 1 3 {
                /j exch def
                patterns p j get 48 sub get scrow j get get {48 sub} forall
            } for
            4 1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code49 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code49--

% --BEGIN ENCODER channelcode--
% --DESC: Channel Code
% --EXAM: 3493
% --EXOP: height=0.5 includetext 
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/channelcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /shortfinder false def
    /includetext false def
    /includecheck false def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def
  
    /barlen barcode length def

    barlen 2 ge barlen 7 le and {
        /channels barlen 1 add def
    } if

    % Determine finder
    shortfinder {
        /finder [ 1 1 1 1 1 ] def
    } {
        /finder [ 1 1 1 1 1 1 1 1 1 ] def
    } ifelse

    /nextb {
        dup
        dup s exch get exch
        dup b exch 1 sub get exch
        dup s exch 1 sub get exch
        b exch 2 sub get exch
        add add add 4 gt {1} {2} ifelse
        1 index chan 2 add lt {
            dup 1 4 index {
                b 3 index 2 index put
                3 index exch sub 1 add 4 index 3 index 1 add nexts
            } for
        } {
            dup 3 index le {
                b 2 index 4 index put
                value target eq {
                    /out [ 
                        3 1 10 {dup s exch get exch b exch get} for
                    ] 0 chan 2 mul getinterval def 
                } if
                /value value 1 add def
            } if
        } ifelse 
        pop pop pop pop
    } bind def

    /nexts {
        dup chan 2 add lt {1} {1 index} ifelse 1 3 index {
            s 2 index 2 index put
            2 index exch sub 1 add 3 index 2 index nextb
        } for
        pop pop pop
    } bind def

    /encode {
        /chan exch def
        /target exch def
        /value 0 def
        /out -1 def
        /b [ 1 1 1 0 0 0 0 0 0 0 0 ] def
        /s [ 0 1 1 0 0 0 0 0 0 0 0 ] def
        chan dup 3 nexts
        out
    } bind def

    % Encode the main data
    /data barcode cvi channels encode def

    % Determine check data
    /check [] def
    includecheck {
        /mod23 [
            [] [] []
            [ 13 12  4  9  3  1 ]
            [ 13  2 12  3 18 16  4  1 ]
            [ 11 16 17  8 20  4 10  2  5  1 ]
            [  1  4 16 18  3 12  2  8  9 13  6  1 ]
            [ 20 16 22 13 15 12  5  4  8  9 21  3  7  1 ]
            [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]
        ] channels get def
        0
        0 1 data length 1 sub {
            dup data exch get 1 sub exch mod23 exch get mul add
        } for
        23 mod 3 encode /check exch def
    } if

    % Construct the symbol
    /sbs [
        finder aload pop
        data aload pop
        check aload pop
    ] def

    % Create the human readable text
    /txt barlen array def
    0 1 barlen 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/channelcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER channelcode--

% --BEGIN ENCODER flattermarken--
% --DESC: Flattermarken
% --EXAM: 12345
% --EXOP: inkspread=-0.25
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/flattermarken {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.3 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (0018) (0117) (0216) (0315) (0414) (0513) (0612) (0711) (0810)
      (0900)
    ] def

    % Create a string of the available characters
    /barchars (1234567890) def

    /barlen barcode length def            % Length of the code

    /sbs barlen 4 mul string def
    /txt barlen array def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 4 mul enc putinterval         % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/flattermarken dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER flattermarken--

% --BEGIN ENCODER raw--
% --DESC: Raw bar space succession for custom symbologies 
% --EXAM: 331132131313411122131311333213114131131221323
% --EXOP: height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/raw {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /sbs exch def        % We are given a barcode string

    /dontdraw false def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/raw dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER raw--

% --BEGIN ENCODER daft--
% --DESC: Raw DAFT succession for custom 4 state symbologies
% --EXAM: FATDAFTDAD
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/daft {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.175 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    /barlen barcode length def

    /bbs barlen array def
    /bhs barlen array def
    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (D) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (A) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (F) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (T) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/daft dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER daft--

% --BEGIN ENCODER symbol--
% --DESC: Miscellaneous symbols
% --EXAM: fima
% --EXOP: backgroundcolor=DD000011
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/symbol {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def

    barcode (fima) eq {
        /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0] def
    } if

    barcode (fimb) eq {
        /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if

    barcode (fimc) eq {
        /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if
    
    barcode (fimd) eq {
        /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0 0] def
    } if
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/symbol dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER symbol--

% --BEGIN ENCODER pdf417--
% --DESC: PDF417
% --EXAM: This is PDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/pdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /compact false def
    /eclevel -1 def
    /columns 0 def
    /rows 0 def
    /rowmult 3 def
    /ccc false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /eclevel eclevel cvi def
    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccc {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Determine the error correction level if unspecified
    /m datcws length def
    eclevel -1 eq {
        m  40 le              {/eclevel 2 def} if
        m  41 ge m 160 le and {/eclevel 3 def} if
        m 161 ge m 320 le and {/eclevel 4 def} if
        m 321 ge              {/eclevel 5 def} if
    } if

    % Reduce the error level so that it does not cause an excessive number of codewords
    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def
    eclevel maxeclevel gt {/eclevel maxeclevel def} if
    /k 2 eclevel 1 add exp cvi def

    % To determine size of matrix, number of columns if given by user...
    columns 0 eq {/columns m k add 3 div sqrt round cvi def} if
    columns 1 ge columns 30 le and {/c columns def} if

    % ... and rows is greater of those required and that given by user within limits
    /r m k add 1 add columns div ceiling cvi def  % Required
    r rows lt rows 90 le and {/r rows def} if
    r 3 lt {/r 3 def} if

    % Opportunistically raise the error level if a better fit to the matrix is possible
    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub 8 2 copy gt {exch} if pop def
    maxeclevel eclevel gt {
      /eclevel maxeclevel def
      /k 2 eclevel 1 add exp cvi def
    } if

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 n put
    cws 1 datcws putinterval
    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Populate bitmap for the image
    compact {
        /rwid 17 c mul 17 add 17 add 1 add def
    } {
        /rwid 17 c mul 17 add 17 add 17 add 18 add def
    } ifelse
    /pixs rwid r mul array def

   0 1 r 1 sub {
        /i exch def

        i 3 mod 0 eq {
            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def
            /rcw i 3 idiv 30 mul c add 1 sub def
        } if
        i 3 mod 1 eq {
            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def
        } if
        i 3 mod 2 eq {
            /lcw i 3 idiv 30 mul c add 1 sub def
            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
        } if

        pixs rwid i mul [
            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0
            lcw i 3 mod cwtobits {} forall
            cws c i mul c getinterval { i 3 mod cwtobits {} forall } forall
            compact {
                1
            } {
                rcw i 3 mod cwtobits {} forall
                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1
            } ifelse
        ] putinterval

    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/pdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pdf417--

% --BEGIN ENCODER micropdf417--
% --DESC: MicroPDF417
% --EXAM: MicroPDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/micropdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /rowmult 2 def
    /cca false def
    /ccb false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    cca {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccb {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /metrics [
        [ 1 11   7   1  0  9 ]
        [ 1 14   7   8  0  8 ]
        [ 1 17   7  36  0 36 ]
        [ 1 20   8  19  0 19 ]
        [ 1 24   8   9  0 17 ]
        [ 1 28   8  25  0 33 ]
        [ 2  8   8   1  0  1 ]
        [ 2 11   9   1  0  9 ]
        [ 2 14   9   8  0  8 ]
        [ 2 17  10  36  0 36 ]
        [ 2 20  11  19  0 19 ]
        [ 2 23  13   9  0 17 ]
        [ 2 26  15  27  0 35 ]
        [ 3  6  12   1  1  1 ]
        [ 3  8  14   7  7  7 ]
        [ 3 10  16  15 15 15 ]
        [ 3 12  18  25 25 25 ]
        [ 3 15  21  37 37 37 ]
        [ 3 20  26   1 17 33 ]
        [ 3 26  32   1  9 17 ]
        [ 3 32  38  21 29 37 ]
        [ 3 38  44  15 31 47 ]
        [ 3 44  50   1 25 49 ]
        [ 4  4   8  47 19 43 ]
        [ 4  6  12   1  1  1 ]
        [ 4  8  14   7  7  7 ]
        [ 4 10  16  15 15 15 ]
        [ 4 12  18  25 25 25 ]
        [ 4 15  21  37 37 37 ]
        [ 4 20  26   1 17 33 ]
        [ 4 26  32   1  9 17 ]
        [ 4 32  38  21 29 37 ]
        [ 4 38  44  15 31 47 ]
        [ 4 44  50   1 25 49 ]
    ] def

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /ccametrics [
        [ 2  5   4  39  0 19 ]
        [ 2  6   4   1  0 33 ]
        [ 2  7   5  32  0 12 ]
        [ 2  8   5   8  0 40 ]
        [ 2  9   6  14  0 46 ]
        [ 2 10   6  43  0 23 ]
        [ 2 12   7  20  0 52 ]
        [ 3  4   4  11 43 23 ]
        [ 3  5   5   1 33 13 ]
        [ 3  6   6   5 37 17 ]
        [ 3  7   7  15 47 27 ]
        [ 3  8   7  21  1 33 ]
        [ 4  3   4  40 20 52 ]
        [ 4  4   5  43 23  3 ]
        [ 4  5   6  46 26  6 ]
        [ 4  6   7  34 14 46 ]
        [ 4  7   8  29  9 41 ]
    ] def
    cca {/metrics ccametrics def} if

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /c    m 0 get def        % Rows in symbol
        /r    m 1 get def        % Columns in symbol
        /k    m 2 get def        % Error correction codewords
        /rapl m 3 get def        % Left row address pattern
        /rapc m 4 get def        % Centre row address pattern
        /rapr m 5 get def        % Right row address pattern
        /ncws r c mul k sub def  % Data codewords
        /okay true def
        datcws length ncws gt     {/okay false def} if
        urows 0 ne urows r ne and {/okay false def} if
        ucols 0 ne ucols c ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /m datcws length def

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 datcws putinterval
    cws m [ n m sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Row address patterns
    /raps [
        [  % Left and right
            802 930 946 818 882 890 826 954 922 986 970 906 778
            794 786 914 978 982 980 916 948 932 934 942 940 936
            808 812 814 806 822 950 918 790 788 820 884 868 870
            878 876 872 840 856 860 862 846 844 836 838 834 866
        ] [  % Centre
            718 590 622 558 550 566 534 530 538 570 562 546 610
            626 634 762 754 758 630 628 612 614 582 578 706 738
            742 740 748 620 556 552 616 744 712 716 708 710 646
            654 652 668 664 696 688 656 720 592 600 604 732 734
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Return the 10 bits for a row address pattern
    /raptobits {
        raps exch get exch get /v exch def
        [ 10 {0} repeat v 2 10 string cvrs {48 sub} forall ]
        dup length 10 sub 10 getinterval
    } bind def

    % Populate bitmap for the image
    /rwid [38 55 82 99] c 1 sub get def
    c 3 eq cca and {/rwid 72 def} if
    /pixs rwid r mul array def

    0 1 r 1 sub {
        /i exch def
        /clst i rapl add 1 sub 3 mod def
        pixs rwid i mul [
            c 1 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 2 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 2 mul get clst cwtobits aload pop
                cws i 2 mul 1 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 3 eq {
                cca not {
                    i rapl add 1 sub 52 mod 0 raptobits aload pop
                } if
                cws i 3 mul get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 3 mul 1 add get clst cwtobits aload pop
                cws i 3 mul 2 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 4 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 4 mul get clst cwtobits aload pop
                cws i 4 mul 1 add get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 4 mul 2 add get clst cwtobits aload pop
                cws i 4 mul 3 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            1
        ] putinterval
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/micropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER micropdf417--

% --BEGIN ENCODER datamatrix--
% --DESC: Data Matrix
% --EXAM: This is Data Matrix!
% --EXOP: rows=32 columns=32
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /encoding (byte) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (byte) eq {
        barlen 250 lt {
            /cws [231 barlen barcode {} forall] def
        } {
            /cws [231 barlen 250 idiv 249 add barlen 250 mod barcode {} forall] def
        } ifelse 
        1 1 cws length 1 sub {
            /i exch def
            i 1 add 149 mul 255 mod 1 add cws i get add
            dup 256 ge {256 sub} if
            cws exch i exch put
        } for
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (edifact) eq {
        /cws 1558 array def
        /i 0 def /j 1 def /k 0 def
        cws 0 240 put
        { % loop
            i barlen gt {exit} if
            /k 0 def /v 0 def
            { % loop until triplet is full or beyond end of data
                k 4 eq i barlen gt or {exit} if
                /cval (unset) def
                i barlen lt {
                    /char barcode i get def
                    char 32 ge char 94 le and {
                        /cval char 63 and def
                    } if
                } {  % Unlatch at end of data
                    /cval 31 def
                } ifelse
                /v v cval 3 k sub 6 mul bitshift or def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -16 bitshift v -8 bitshift 255 and v 255 and ] putinterval
            /j j 3 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (c40) eq encoding (text) eq or encoding (x12) eq or {

        /s1 0 def /s2 1 def /s3 2 def /us 30 def

        encoding (c40) eq {
            /latch 230 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                14 1 39 { [ exch ]                    } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                1 1 26  { [ exch s3 exch ]            } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
        } if

        encoding (text) eq {
            /latch 239 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                1 1 26  { [ exch s3 exch ]            } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                14 1 39 { [ exch ]                    } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
         } if

         encoding (x12) eq {
             /latch 238 def
             /charmap [
                 13      { [ () ]   } repeat  % 0-12
                           [ 0 ]              % 13
                 18      { [ () ]   } repeat  % 14-31
                           [ 3 ]              % 32
                 9       { [ () ]   } repeat  % 33-41
                           [ 1 ]              % 42
                 5       { [ () ]   } repeat  % 43-47
                 4 1 13  { [ exch ] } for     % 48-57
                 4       { [ () ]   } repeat  % 58-61
                           [ 2 ]              % 62
                 2       { [ () ]   } repeat  % 63-64
                 14 1 39 { [ exch ] } for     % 65-90
                 165     { [ () ]   } repeat  % 91-255 
             ] def
         } if

         % Derive the encoded character stream
         /encstr barlen 4 mul array def
         /j 0 def
         0 1 barlen 1 sub {
             barcode exch get charmap exch get
             dup encstr exch j exch putinterval
             length j add /j exch def
         } for
         /encstr encstr 0 j getinterval def
         /enclen j def

         % Compress triples into doubles
         /cws 1558 array def
         /i 0 def /j 1 def /k 0 def
         cws 0 latch put
         { % loop
            i enclen ge {exit} if
            /k 0 def /v 1 def
            { % loop until triple is full or end of data
                k 3 eq i enclen ge or {exit} if
                /v v encstr i get 40 2 k sub exp cvi mul add def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -8 bitshift v 255 and ] putinterval
            /j j 2 add def
        } loop
        cws j 254 put
        /cws cws 0 j 1 add getinterval def

    } if

    % Basic metrics for the each symbol
    %    rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
        [  10    10     1     1     5     1 ]
        [  12    12     1     1     7     1 ]
        [  14    14     1     1    10     1 ]
        [  16    16     1     1    12     1 ]
        [  18    18     1     1    14     1 ]
        [  20    20     1     1    18     1 ] 
        [  22    22     1     1    20     1 ]
        [  24    24     1     1    24     1 ]
        [  26    26     1     1    28     1 ]
        [  32    32     2     2    36     1 ]
        [  36    36     2     2    42     1 ]
        [  40    40     2     2    48     1 ]
        [  44    44     2     2    56     1 ]
        [  48    48     2     2    68     1 ]
        [  52    52     2     2    84     2 ]
        [  64    64     4     4   112     2 ]
        [  72    72     4     4   144     4 ]
        [  80    80     4     4   192     4 ]
        [  88    88     4     4   224     4 ]
        [  96    96     4     4   272     4 ]
        [ 104   104     4     4   336     6 ]
        [ 120   120     6     6   408     6 ]
        [ 132   132     6     6   496     8 ]
        [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
        [   8    18     1     1     7     1 ]
        [   8    32     1     2    11     1 ]
        [  12    26     1     1    14     1 ]
        [  12    36     1     2    18     1 ]
        [  16    36     1     2    24     1 ]
        [  16    48     1     2    28     1 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws gt           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pseudo-randomised pad characters
    cws length ncws lt {
        /datlen cws length def
        /cws [ cws {} forall ncws datlen sub {129} repeat ] def
        datlen 1 add 1 ncws 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def 
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def 
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for 
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll 
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs 
        dup length 8 exch sub exch putinterval 
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def
    
    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def
    
    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if  
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if 
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if 
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 1.5 mul
    /width cols 72 div 1.5 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER datamatrix--

% --BEGIN ENCODER qrcode--
% --DESC: QR Code
% --EXAM: http://www.terryburton.co.uk/barcodewriter/
% --EXOP: eclevel=M
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro
    /version (unset) def
    /eclevel (unset) def   % L, M, Q or H
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Force raw mode for micro format symbols
    format (micro) eq {/raw true def} if

    % Default to error correction level M
    eclevel (unset) eq {/eclevel (M) def} if

    % Convert from input into message bitstream
    raw {
        /msgbits barcode def 
    } {  % Simple autoencoder from input to bitstream using byte mode only for full format symbols

        /barlen barcode length def
        eclevel (unset) eq {/eclevel (M) def} if

        % Determine smallest symbol version to hold given amount of byte-encoded data
        version (unset) eq {
            /caps [
                [
                      17    32    53    78   106   134   154   192   230   271   % 1-L  - 10-L
                     321   367   425   458   520   586   644   718   792   858   % 11-L - 20-L
                     929  1003  1091  1171  1273  1367  1465  1528  1628  1732   % 21-L - 30-L
                    1840  1952  2068  2188  2303  2431  2563  2699  2809  2953   % 31-L - 40-L
                ] [
                      14    26    42    62    84   106   122   152   180   213   % 1-M  - 10-M
                     251   287   331   362   412   450   504   560   624   666   % 11-M - 20-M
                     711   779   857   911   997  1059  1125  1190  1264  1370   % 21-M - 30-M
                    1452  1538  1628  1722  1809  1911  1989  2099  2213  2331   % 31-M - 40-M
                ] [
                      11    20    32    46    60    74    86   108   130   151   % 1-Q  - 10-Q
                     177   203   241   258   292   322   364   394   442   482   % 11-Q - 20-Q
                     509   565   611   661   715   751   805   868   908   982   % 21-Q - 30-Q
                    1030  1112  1168  1228  1283  1351  1423  1499  1579  1663   % 31-Q - 40-Q
                ] [
                       7    14    24    34    44    58    64    84    98   119   % 1-H  - 10-H
                     137   155   177   194   220   250   280   310   338   382   % 11-H - 20-H
                     403   439   461   511   535   593   625   658   698   742   % 21-H - 30-H
                     790   842   898   958   983  1051  1093  1139  1219  1273   % 31-H - 40-H
                ]
            ] def
            /caps caps (LMQH) eclevel search pop length exch pop exch pop get def
            /i 1 def
            {
                barlen caps i 1 sub get le {exit} if 
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
        } if

        % Set the control character data for the version
        /mid (0100) def /term (0000) def /cclen 8 def
        version 0 1 getinterval (M) ne {  % Version 10 and above
            version cvi 10 ge {/cclen 16 def} if
        } if
        /midlen mid length def
        /termlen term length def

        % Create the bitstream as byte_mode_id character_count data_bytes term
        /msgbits midlen cclen add barlen 8 mul add termlen add string def
        msgbits 0 mid putinterval
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen cvi 2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        msgbits midlen cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits midlen cclen add i 8 mul add 3 -1 roll putinterval
        } for
        msgbits midlen cclen add barlen 8 mul add term putinterval

    } ifelse

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  size align modules    error codewords        error correction blocks 
        %                                      L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)   11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)   13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)   15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)   17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)    21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)    25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)    29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)    33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)    37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)    41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)    45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)    49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)    53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /size m 2 get def                             % Length of side
        /asp2 m 3 get def                             % Position of second alignment symbol
        /asp3 m 4 get def                             % Position of third alignment symbol
        /nmod m 5 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 6 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 7 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 7 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        msgbits length dmod gt {/okay false def} if   % Bitstream must fit into data modules
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        okay {exit} if
        /i i 1 add def
    } loop
    /format frmt def
    /version vers def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 4 dmod 1 sub {pad exch (0000) putinterval} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size 1 add array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER qrcode--

% --BEGIN ENCODER maxicode--
% --DESC: MaxiCode
% --EXAM: [\)>^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004
% --EXOP: mode=2 parse
% --RNDR: renmaximatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmaximatrix dup /uk.co.terryburton.bwipp findresource put
begin
/maxicode {

    20 dict begin

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /mode -1 def
    /sam -1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /sam sam cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if
    
    /msg barcode def
    /msglen msg length def

    % Special message handling for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Normalise messages that begin with a field identifier [)>RS01GSyy
        msg 0 7 getinterval <5b293e1e30311d> eq {
            /fid msg 0 9 getinterval def
            /msg msg 9 msglen 9 sub getinterval def 
        } {
            /fid () def
        } ifelse

        % Read the postcode, country code and service code fields seperated by GS
        msg <1d> search pop /pcode exch def
        pop <1d> search pop /ccode exch def
        pop <1d> search pop /scode exch def
        pop /msg exch def

        % Prepend the field identifier
        msg length fid length add string dup
        0 fid putinterval dup 
        fid length msg putinterval
        /msg exch def
        /msglen msg length def

    } if

    % Special function characters
    /eci -1 def  /pad -2 def  /ns -3 def
    /la  -4 def  /lb  -5 def
    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def
    /sa2 -11 def /sa3 -12 def  
    /lkc -13 def /lkd -14 def /lke -15 def
    /pd2 -16 def /pd3 -17 def 
    
    % Character maps for each state
    /charmaps [
        %  A    B    C    D    E
        [  13  (`)  192  224    0 ]  % 0
        [ (A)  (a)  193  225    1 ]  % 1
        [ (B)  (b)  194  226    2 ]  % 2
        [ (C)  (c)  195  227    3 ]  % 3
        [ (D)  (d)  196  228    4 ]  % 4
        [ (E)  (e)  197  229    5 ]  % 5
        [ (F)  (f)  198  230    6 ]  % 6
        [ (G)  (g)  199  231    7 ]  % 7
        [ (H)  (h)  200  232    8 ]  % 8
        [ (I)  (i)  201  233    9 ]  % 9 
        [ (J)  (j)  202  234   10 ]  % 10
        [ (K)  (k)  203  235   11 ]  % 11
        [ (L)  (l)  204  236   12 ]  % 12
        [ (M)  (m)  205  237   13 ]  % 13
        [ (N)  (n)  206  238   14 ]  % 14
        [ (O)  (o)  207  239   15 ]  % 15
        [ (P)  (p)  208  240   16 ]  % 16
        [ (Q)  (q)  209  241   17 ]  % 17
        [ (R)  (r)  210  242   18 ]  % 18
        [ (S)  (s)  211  243   19 ]  % 19
        [ (T)  (t)  212  244   20 ]  % 20
        [ (U)  (u)  213  245   21 ]  % 21
        [ (V)  (v)  214  246   22 ]  % 22
        [ (W)  (w)  215  247   23 ]  % 23
        [ (X)  (x)  216  248   24 ]  % 24
        [ (Y)  (y)  217  249   25 ]  % 25
        [ (Z)  (z)  218  250   26 ]  % 26
        [ eci  eci  eci  eci  eci ]  % 27
        [  28   28   28   28  pad ]  % 28
        [  29   29   29   29  pad ]  % 29
        [  30   30   30   30   27 ]  % 30
        [  ns   ns   ns   ns   ns ]  % 31
        [ ( )  ({)  219  251   28 ]  % 32
        [ pad  pad  220  252   29 ]  % 33
        [ (")  (})  221  253   30 ]  % 34
        [ (#)  (~)  222  254   31 ]  % 35
        [ ($)  127  223  255  159 ]  % 36
        [ (%)  (;)  170  161  160 ]  % 37
        [ (&)  (<)  172  168  162 ]  % 38
        [ (')  (=)  177  171  163 ]  % 39
        [  40  (>)  178  175  164 ]  % 40
        [  41  (?)  179  176  165 ]  % 41
        [ (*)  ([)  181  180  166 ]  % 42
        [ (+)   92  185  183  167 ]  % 43
        [ (,)  (])  186  184  169 ]  % 44
        [ (-)  (^)  188  187  173 ]  % 45
        [ (.)  (_)  189  191  174 ]  % 46
        [ (/)  ( )  190  138  182 ]  % 47
        [ (0)  (,)  128  139  149 ]  % 48
        [ (1)  (.)  129  140  150 ]  % 49
        [ (2)  (/)  130  141  151 ]  % 50
        [ (3)  (:)  131  142  152 ]  % 51
        [ (4)  (@)  132  143  153 ]  % 52
        [ (5)  (!)  133  144  154 ]  % 53
        [ (6)  (|)  134  145  155 ]  % 54
        [ (7)  pd2  135  146  156 ]  % 55
        [ (8)  sa2  136  147  157 ]  % 56
        [ (9)  sa3  137  148  158 ]  % 57
        [ (:)  pd3   la   la   la ]  % 58
        [  sb   sa  ( )  ( )  ( ) ]  % 59
        [  sc   sc  lkc   sc   sc ]  % 60
        [  sd   sd   sd  lkd   sd ]  % 61
        [  se   se   se   se  lke ]  % 62
        [  lb   la   lb   lb   lb ]  % 63
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 4 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    /setd charvals 3 get def
    /sete charvals 4 get def

    % Compute numeric runlengths
    /nseq [ msglen 1 add {0} repeat ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get dup 48 ge exch 57 le and {
            nseq i nseq i 1 add get 1 add put
        } {
            nseq i 0 put
        } ifelse
    } for
    /nseq nseq 0 msglen getinterval def

    % Encode the message from ASCII to codewords 
    /prefixinset {
        0 {
            2 copy exch length ge {exit} if 
            2 copy get 3 index exch known {1 add} {exit} ifelse
        } loop
        exch pop exch pop
    } bind def
    
    /enc {
        exch get out exch j exch put
        /j j 1 add def
    } bind def

    /out 144 array def
    /i 0 def /j 0 def /cset (seta) def
    { % loop
        % Exit when no characters remain latching back to A if necessary
        i msglen eq {
            cset (seta) ne cset (setb) ne and {
                la cset load enc
                /cset (seta) def
            } if
            exit
        } if
        { % not a loop but common exit point
    
            % If 9 numerals available then use NS
            nseq i get 9 ge {
                msg i 9 getinterval cvi 4 { dup 63 and exch -6 bitshift } repeat cset load ns get
                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat
                out exch j exch putinterval
                /i i 9 add def
                /j j 6 add def
                exit
            } if
    
            % Read next three characters
            /char1 msg i get def
            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def
            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def
    
            % If current mode is sufficient then directly encode
            cset load char1 known { 
                char1 cset load enc
                /i i 1 add def
                exit
            } if
    
            % For switching from A to B
            cset (seta) eq setb char1 known and {
                setb char2 known {
                    lb seta enc
                    /cset (setb) def
                } {
                    sb seta enc
                    char1 setb enc
                    /i i 1 add def
                } ifelse
                exit
            } if
    
            % For switching from B to A encode according to length of prefix
            cset (setb) eq seta char1 known and {
                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
                p 1 eq {
                    sa setb enc
                    char1 seta enc
                    /i i 1 add def
                } if
                p 2 eq {
                    sa2 setb enc
                    char1 seta enc
                    char2 seta enc
                    /i i 2 add def 
                } if
                p 3 eq {
                    sa3 setb enc
                    char1 seta enc
                    char2 seta enc
                    char3 seta enc
                    /i i 3 add def 
                } if
                p 4 ge {
                    la setb enc
                    /cset (seta) def
                } if
                exit
            } if
    
            % If character is in A or B then directly latch
            seta char1 known {
                la cset load enc
                /cset (seta) def
                exit
            } if      
            setb char1 known {
                lb cset load enc
                /cset (setb) def
                exit
            } if      
     
            % Determine which one of sets C, D or E the character is in
            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if
            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if
            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if
    
            % Encode according to the length of the prefix
            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
            p 1 eq {
                sx cset load enc
                char1 setx load enc
                /i i 1 add def
            } if
            p 2 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                /i i 2 add def
            } if
            p 3 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                sx cset load enc
                char3 setx load enc
                /i i 3 add def
            } if
            p 4 ge {
                sx cset load enc
                lkx setx load enc
                /cset setx def 
            } if
    
            exit
        } loop  % out
    } loop
    /encmsg out 0 j getinterval def
    /padval cset load pad get def 

    % Prefix the encoded message with the structured append insert
    /sami [] def
    sam -1 ne {
        /sami 2 array def
        sami 0 seta pad get put 
        sami 1 sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add put
    } if
    /encmsg [ sami aload pop encmsg aload pop ] def

    % Derive the primary and secondary codewords for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Calculate the fixed-width binary values for the mode, postcode, country code and service
        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def
        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /pcb (000000000000000000000000000000000000) 36 string copy def
        mode 2 eq {
            % For numeric postcode, first six bits represent length and remaining 30 bits the value
            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval
            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval
        } {  % mode=3
            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary
            /pccw [ 
                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval 
                {seta exch get} forall
            ] def
            0 1 5 {
                /i exch def
                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval
            } for
        } ifelse

        % Convolute the binary values into the structured carrier message
        /scm 60 string def
        scm 2  mdb putinterval
        scm 38 pcb 0  4 getinterval putinterval
        scm 30 pcb 4  6 getinterval putinterval
        scm 24 pcb 10 6 getinterval putinterval
        scm 18 pcb 16 6 getinterval putinterval
        scm 12 pcb 22 6 getinterval putinterval
        scm 6  pcb 28 6 getinterval putinterval
        scm 0  pcb 34 2 getinterval putinterval
        scm 52 ccb 0  2 getinterval putinterval
        scm 42 ccb 2  6 getinterval putinterval
        scm 36 ccb 8  2 getinterval putinterval
        scm 54 scb 0  6 getinterval putinterval
        scm 48 scb 6  4 getinterval putinterval

        % Evaluate the structured carrier message as codewords
        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def
        0 1 59 { 
            /i exch def
            /ps i 6 idiv def
            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def
            pri ps pri ps get ep add put
        } for

        % Pad the encoded message into the secondary component
        /sec [ 84 {padval} repeat ] def
        sec 0 encmsg putinterval

    } if

    % Derive the primary and secondary codewords for modes 4, 5 and 6
    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {

        % If mode isn't specified then use EEC if message fits, otherwise SEC
        mode -1 eq {
            /mode encmsg length 77 le {5} {4} ifelse def
        } if

        % First symbol is the mode and the remainder are the padded message
        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def
        cws 0 mode put
        cws 1 encmsg putinterval

        % Fit the message into the primary and secondary components
        /pri cws 0 10 getinterval def
        /sec cws 10 cws length 10 sub getinterval def

    } if

    % Calculate the log and anti-log tables
    /rsalog [ 1 63 { dup 2 mul dup 64 ge {67 xor} if } repeat ] def
    /rslog 64 array def
    1 1 63 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 63 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate error correction codewords
    /rscodes {

        /rsnum exch def
        /cwb exch def

        % Generate the coefficients
        /coeffs [ 1 rsnum {0} repeat ] def
        1 1 rsnum {
            /i exch def
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for
        /coeffs coeffs 0 coeffs length 1 sub getinterval def

        % Calculate the error correction codewords
        /ecb [ rsnum {0} repeat ] def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def
            ecb length 1 sub -1 0 {
                /i exch def
                /p ecb length i sub 1 sub def
                ecb p t coeffs i get rsprod put
                i 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for
        } for

        ecb

    } bind def

    % Split secondary codeword into odd and even elements
    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def
    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def

    % Calculate the parity codewords for secondary codeword parts based on mode
    /scodes sec length 84 eq {20} {28} ifelse def  % SEC/EEC mode
    /secochk seco scodes rscodes def
    /secechk sece scodes rscodes def

    % Recompose the secondary parity codewords
    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def

    % Concatinate the data into final codewords
    /codewords [
        pri aload pop 
        pri 10 rscodes aload pop
        sec aload pop 
        secchk aload pop
    ] def

    % Convert the codewords into module bits
    /mods [ 864 {0} repeat ] def
    0 1 143 {
        /i exch def
        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def
        mods 6 i mul 6 cw length sub add cw putinterval
    } for

    % Maps modules to pixels in the grid
    /modmap [
        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379 
        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314 
        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428 
        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278 
        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576 
        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710 
        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6   
        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42  
        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78  
        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26  
        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142 
        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166 
        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98  
        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122 
        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242 
        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190 
        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226 
        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262 
        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294 
        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304 
        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420 
        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384 
        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504 
        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512 
        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544 
        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596 
        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712 
        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630 
        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754 
        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790 
        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738 
        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774 
        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894 
        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826 
        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850 
        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874 
        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902 
        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938 
        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974 
        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922 
        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118 
        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508 
        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929 
        928 958 989 988
    ] def

    % Lookup pixels for enabled modules from modmap
    /pixs 864 array def
    /j 0 def
    0 1 mods length 1 sub {
        /i exch def
        mods i get 1 eq {
            pixs j modmap i get put
            /j j 1 add def
        } if
    } for
    /pixs [ pixs 0 j getinterval {} forall 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def

    % Return the arguments
    <<
    /ren //renmaximatrix
    /pixs pixs
    /opt options
    >>

    dontdraw not //renmaximatrix if

    end

} bind def
/maxicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER maxicode--

% --BEGIN ENCODER azteccode--
% --DESC: Aztec Code
% --EXAM: This is Aztec Code
% --EXOP: format=full
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/azteccode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (unset) def    % full, compact or rune
    /readerinit false def
    /layers -1 def
    /eclevel 23 def
    /ecaddchars 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /layers layers cvi def
    /eclevel eclevel cvr def
    /ecaddchars ecaddchars cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    /msgbits () def 
    format (rune) ne raw and {/msgbits barcode def} if 
    format (rune) ne raw not and {  % Simple autoencoder from input to bitstream using byte mode only

        % Determine the character count
        /barlen barcode length def
        barlen 31 le {
            (00000) 5 string copy dup barlen 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            /cc exch def
        } {
            (0000000000000000) 16 string copy dup barlen 31 sub 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            /cc exch def
        } ifelse
        /cclen cc length def

        % Create the bitstream as byte_mode_id character_count data_bytes
        /msgbits 5 cclen add barlen 8 mul add string def
        msgbits 0 (11111) putinterval
        msgbits 5 cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits 5 cclen add i 8 mul add 3 -1 roll putinterval
        } for

    } if

    % Lookup the most appropriate symbol specification 
    /metrics [
        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols
        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]
        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]
        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]
        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]
        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]
        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]
        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]
        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]
        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]
        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]
        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]
        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]
    ] def

    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                          % Format of the symbol
        /mlyr m 1 get def                          % Data layers
        /icap m 2 get def                          % Reader initialisation capable
        /ncws m 3 get def                          % Total of codewords
        /bpcw m 4 get def                          % Bits per codeword
        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def
        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords 
        /numdcw ncws numecw sub def                % Data codewords
        /okay true def
        format (unset) ne format frmt ne and {/okay false def} if
        readerinit icap 1 ne and {/okay false def} if
        layers -1 ne layers mlyr ne and {/okay false def} if 
        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /layers mlyr def
    /format frmt def

    % Expand message bits into codewords avoiding codewords with all zeros or all ones
    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} bind def
    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} bind def
    /cws ncws array def
    /m 0 def /c 0 def
    {
        msgbits length m le {exit} if
        msgbits length m sub bpcw ge {
            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit
            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit
            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros
            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones
            % Concatinate the bits 
            12 string dup 0 cwb putinterval 
            dup bpcw 1 sub cwf putinterval
            0 bpcw getinterval
            /cwb exch def
        } {  %  Final codeword
            /cwb msgbits m msgbits length m sub getinterval def
            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def
            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones
        } ifelse
        % Conversion of binary data into byte array
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
        /m m bpcw add def 
        /c c 1 add def
    } loop    
    /cws cws 0 c getinterval def

    % Reed-Solomon algorithm
    /rscodes {

        /rspm exch def
        /rsgf exch def
        /rsnc exch def
        /rscws exch def

        % Calculate the log and anti-log tables
        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
        /rslog rsgf array def
        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for

        % Function to calculate the product in the field
        /rsprod {
            2 copy 0 ne exch 0 ne and {
                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get
            } {
                pop pop 0
            } ifelse
        } bind def

        % Generate the coefficients
        /coeffs [ 1 rsnc {0} repeat ] def
        1 1 rsnc {
            /i exch def 
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for 
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for

        % Extend the input with the error correction values
        /nd rscws length def
        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def
        0 1 nd 1 sub {
            /k exch rscws exch get rscws nd get xor def 
            0 1 rsnc 1 sub {
                /j exch def 
                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put
            } for 
        } for

        % Return all but the last codeword
        rscws 0 rscws length 1 sub getinterval

    } bind def

    % Create the codewords and bit string for the mode
    format (full) eq {
        /mode layers 1 sub 11 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#1000000000000000 or def} if
        /mode [
            mode 2#1111000000000000 and -12 bitshift
            mode 2#0000111100000000 and -8 bitshift
            mode 2#0000000011110000 and -4 bitshift
            mode 2#0000000000001111 and
        ] def
        /mode mode 6 16 19 rscodes def 
    } if
    format (compact) eq {
        /mode layers 1 sub 6 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#10000000 or def} if 
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
    } if
    format (rune) eq {
        /mode barcode cvi def
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits
    } if
    /modebits mode length 4 mul string def
    0 1 modebits length 1 sub {modebits exch (0) putinterval} for
    0 1 mode length 1 sub {
        /i exch def
        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval 
    } for

    % Extend the data codewords with error correction codewords to create the bit string for the data
    /rsparams [
        [] [] [] [] [] [] 
        [ 64 67 ]      % 6-bit codewords 
        []
        [ 256 301 ]    % 8-bit codewords
        [] 
        [ 1024 1033 ]  % 10-bit codewords
        []
        [ 4096 4201 ]  % 12-bit codewords
    ] def
    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def
    format (full) eq {
        /databits layers layers mul 16 mul layers 112 mul add string def 
    } {
        /databits layers layers mul 16 mul layers 88 mul add string def 
    } ifelse
    0 1 databits length 1 sub {databits exch (0) putinterval} for
    0 1 ncws 1 sub { 
        /i exch def
        databits cws i get 2 bpcw string cvrs 
        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add 
        exch putinterval 
    } for

    % Move to a point in the cartesian plane centered on the bullseye
    /cmv {size mul sub mid add} bind def

    % Move to a bit position within a layer
    /lmv {
        /lbit exch def
        /llyr exch def
        /lwid fw llyr 4 mul add def
        /ldir lbit 2 idiv lwid idiv def
        ldir 0 eq {  % Top
            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add 
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add
            cmv
        } if
        ldir 1 eq {  % Right
            fw 2 idiv llyr 2 mul add lbit 2 mod add
            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub
            cmv
        } if
        ldir 2 eq {  % Bottom
            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg
            fw 2 idiv llyr 2 mul add lbit 2 mod add neg
            cmv
        } if
        ldir 3 eq {  % Left
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg
            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg
            cmv
        } if
    } bind def

    % Create the pixel map
    % For full symbols we disregard the reference grid at this stage
    format (full) eq {/fw 12 def} {/fw 9 def} ifelse
    /size fw layers 4 mul add 2 add def 
    /pixs [size size mul {-1} repeat] def
    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def

    % Data layers
    /i 0 def
    1 1 layers {
        /layer exch def
        0 1 fw layer 4 mul add 8 mul 1 sub {
            /pos exch def
            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put
            /i i 1 add def
        } for
    } for

    % For full symbols expand the pixel map by inserting the reference grid
    format (full) eq {
        /fw 13 def
        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def
        /mid size size mul 2 idiv def
        /npixs [size size mul {-2} repeat] def
        0 16 size 2 idiv {
            /i exch def
            0 1 size 1 sub {
                /j exch def
                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
            } for
        } for 
        /j 0 def
        0 1 npixs length 1 sub {
            /i exch def
            npixs i get -2 eq {
                npixs i pixs j get put
                /j j 1 add def
            } if
        } for
        /pixs npixs def
    } if

    % Finder pattern
    /fw fw 2 idiv def
    fw neg 1 fw {
        /i exch def
        fw neg 1 fw {
            /j exch def
            pixs i j cmv
            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod
            put
        } for
    } for

    % Orientation bits
    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]
      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]
      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]
      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]
      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]
      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]
    ] {pixs exch {} forall 3 1 roll cmv exch put} forall

    % Mode ring
    format (full) eq {
        /modemap [ 
            [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]
            [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]
            [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]
            [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]
        ] def
    } {
        /modemap [
            [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]
            [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]
            [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]
            [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]
        ] def
    } ifelse
    0 1 modemap length 1 sub {
        /i exch def
        pixs modemap i get {} forall cmv modebits i get 48 sub put
    } for

    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/azteccode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER azteccode--

% --BEGIN ENCODER codeone--
% --DESC: Code One
% --EXAM: Code One
% --EXOP: version=B
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codeone {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /version (unset) def
    /encoding (ascii) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /stype version 0 1 getinterval (S) eq def
    stype {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    % Basic metrics for the each symbol
    %     ver    row col dcol dcws rscw rsbl  ro ri rl
    /metrics [
        [ (A)     16  18   16   10   10    1   4 99  6 ]
        [ (B)     22  22   20   19   16    1   4 99  8 ]
        [ (C)     28  32   28   44   26    1   4 22 11 ]
        [ (D)     40  42   36   91   44    1   4 16 16 ]
        [ (E)     52  54   48  182   70    1   4 22 22 ]
        [ (F)     70  76   68  370  140    2   4 22 31 ]
        [ (G)    104  98   88  732  280    4   6 21 47 ]
        [ (H)    148 134  120 1480  560    8   6 20 69 ]
        [ (S-10)   8  11   10    4    4    1  99 99 99 ]
        [ (S-20)   8  21   20    8    8    1  99 99 99 ]
        [ (S-30)   8  31   30   12   12    1  99 99 99 ]
        [ (T-16)  16  17   16   10   10    1  99 99 99 ]
        [ (T-32)  16  33   32   24   16    1  99 99 99 ]
        [ (T-48)  16  49   48   38   22    1  99 99 99 ]
    ] def

    % Select metrics of an appropriate symbol
    /i 0 def
    { % loop
        /m metrics i get def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords 
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def 
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
    } for

    % Log and anti-log tables and function to calculate product in the field
    /gf stype {32} {256} ifelse def
    /gf-1 gf 1 sub def
    /pm stype {37} {301} ifelse def
    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def
    /rslog gf array def
    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    % Extend codewords with the interleaved error correction codes
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Module matrix for layout of the codewords
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    % Create bitmap and add finder patterns
    /mmv {cols mul add} bind def
    /pixs [ rows cols mul {-1} repeat ] def

    % Centre pattern
    /artifact [
        {cols {0} repeat} bind 
        {cols {1} repeat} bind 
        {0   cols 2 sub {1} repeat   0} bind 
        {0 1 cols 4 sub {0} repeat 1 0} bind 
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind 
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind 
        {1   cols 2 sub {0} repeat   1} bind 
        {1 0 cols 4 sub {1} repeat 0 1} bind 
    ] def
    /cpat <<
        /A (121343)
        /B (12134343)
        /C (12121343)
        /D (1213434343)
        /E (1212134343)
        /F (1212121343)
        /G (121213434343)
        /H (121212134343)
        /S (56661278)
        /T (5666666666127878)
    >> vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv 
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    % Risers
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv 
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    % Black dots
    <<
        /A [ [12 5] ]
        /B [ [16 7] ]
        /C [ [26 12] ]
        /D []
        /E [ [26 23] ]
        /F [ [26 32] [70 32] [26 34] [70 34] ]
        /G [ [27 48] [69 48] ]
        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
        /S-10 []
        /S-20 [ [10 4] ]
        /S-30 [ [15 4] [15 6] ]
        /T-16 [ [8 10] ]
        /T-32 [ [16 10] [16 12] ]
        /T-48 [ [24 10] [24 12] [24 14] ]
    >> vers get {pixs exch aload pop mmv 1 put} forall

    % Place the modules onto a pixel map between alignment patterns
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 1.5 mul
    /width cols 72 div 1.5 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codeone--

% --BEGIN ENCODER gs1-cc--
% --REQUIRES micropdf417 pdf417--
% --DESC: GS1 Composite 2D Component
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: ccversion=b cccolumns=4
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-cc {
    
    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /ccversion (a) def
    /cccolumns -1 def
    /lintype () def
    /linwidth -1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /cccolumns cccolumns cvi def
    /linwidth linwidth cvi def

    % Select columns based on linear type
    cccolumns -1 eq {
        <<
            /ean13                  4
            /upca                   4
            /ean8                   3
            /upce                   2
            /gs1-128
                ccversion (c) ne {4} {linwidth 52 sub 17 idiv} ifelse
            /databaromni            4
            /databarstacked         2
            /databarstackedomni     2
            /databartruncated       4
            /databarlimited         3
            /databarexpanded        4
            /databarexpandedstacked 4
        >> lintype get /cccolumns exch def 
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
 
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    /isupper {dup 65 ge exch 90 le and} bind def  % A-Z
    /isnum0  {dup 48 ge exch 57 le and} bind def  % 0-9
    /isnum1  {dup 49 ge exch 57 le and} bind def  % 1-9
    {  % common exit
    
        % (10/11/17)...
        ais length 1 ge {
            ais 0 get (10) eq ais 0 get (11) eq or ais 0 get (17) eq or {
                -1 (10) exit
            } if
        } if

        % (90){0-3 digits not starting 0}{upper alpha}...
        ais length 1 ge {
            ais 0 get (90) eq {
                /v aival (90) get def
                v length 1 ge {
                   v 0 get isupper {
                       0 (11) exit
                   } if
                } if
                v length 2 ge {
                   v 0 get isnum1
                   v 1 get isupper and {
                       1 (11) exit
                   } if
                } if
                v length 3 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isupper and {
                        2 (11) exit
                    } if
                } if
                v length 4 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isnum0 and
                    v 3 get isupper and {
                        3 (11) exit
                    } if
                } if
            } if
        } if

        % Freeform
        -1 (0) exit
    
    } loop
    /method exch def
    /npre exch def

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def

    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
 
    /alpha <<
        65 1 90 {dup 65 sub 5 tobin} for
        48 1 57 {dup 4 add 6 tobin} for
        fnc1 (11111)
    >> def

    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
 
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def

    method (10) eq {  % TODO: fixme
        ais 0 get (11) eq ais 0 get (17) eq or {
            aival ais 0 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
            (0000000000000000) 16 string copy dup 3 -1 roll 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            [ 1 0
              4 -1 roll {48 sub} forall
              ais 0 get (11) eq {0} {1} ifelse
            ] /cdf exch def
            /ais ais 1 ais length 1 sub getinterval def
        } {
            /cdf [ 1 0  1 1 ] def
        } ifelse
        ais length 0 ne {
            ais 0 get (10) eq {
                /gpf [ aival (10) get {} forall ] def
                ais length 1 gt {/gpf [ gpf aload pop fnc1 ] def} if  % TODO: check
                /ais ais 1 ais length 1 sub getinterval def
            } {
                /gpf [fnc1] def  % TODO: check
            } ifelse
        } {
            /cdf [ cdf aload pop 0 0 0 0 0 1 1 1 1 ] def
            /gpf [] def
        } ifelse
        /mode (numeric) def
    } if

    method (11) eq {
        /cdf [ 1 1 ] def
        /ai90 aival (90) get def
        npre 1 add ai90 length ne {
            ai90 npre 1 add ai90 length npre sub 1 sub getinterval
        } {
            ()
        } ifelse
        /ai90rem exch def
        /nalpha 0 ai90rem {dup 65 ge exch 90 le and {1 add} if} forall def
        /nnums  0 ai90rem {dup 48 ge exch 57 le and {1 add} if} forall def
        /mode nalpha nnums gt {(alpha)} {(numeric)} ifelse def
        nalpha nnums add ai90rem length ne {/mode (alphanumeric) def} if
        /cdf [
            cdf aload pop
            mode (alphanumeric) eq {0} if   
            mode (numeric) eq {1 0} if   
            mode (alpha) eq {1 1} if   
        ] def
        /ais1 ais length 1 gt {ais 1 get} {-1} ifelse def
        ais1 (21) eq ais1 (8004) eq or { 
            /cdf [ cdf aload pop ais1 (21) eq {1 0} {1 1} ifelse ] def
        } {
            /cdf [ cdf aload pop 0 ] def
        } ifelse
        /nval npre 0 ne {ai90 0 npre getinterval cvi} {0} ifelse def
        (BDHIJKLNPQRSTVXZ) ai90 npre 1 getinterval search {
            length exch pop exch pop
            /aval exch def
        } {
            pop /aval -1 def
        } ifelse 
        nval 31 lt aval -1 ne and {
            (00000) 5 string copy dup nval 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (0000) 4 string copy dup aval 2 4 string cvrs
            dup length 4 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop 
                nbits aload pop
                abits aload pop
            ] def
        } {
            (0000000000) 10 string copy dup nval 2 10 string cvrs
            dup length 10 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (00000) 5 string copy dup ai90 npre get 65 sub 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop
                1 1 1 1 1
                nbits aload pop
                abits aload pop
            ] def
        } ifelse
        mode (numeric) eq {
            /gpf [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
        } {
            /encs mode (alpha) eq {alpha} {alphanumeric} ifelse def
            /in [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
            /out in length 6 mul array def
            /j 0 def
            0 1 in length 1 sub {
                in exch get encs exch get 
                dup [ exch {48 sub} forall ] out exch j exch putinterval
                length j add /j exch def
            } for
            /cdf [
                cdf aload pop 
                out 0 j getinterval aload pop
            ] def
            /gpf [] def
            ais length 1 gt mode (alpha) ne or {/mode (numeric) def} if
        } ifelse
        /ais ais 1 ais length 1 sub getinterval def
        ais length 0 ne {
            ais1 (21) eq ais1 (8004) eq or {
                /gpf [
                    gpf aload pop
                    aival ais1 get {} forall
                ] def
                /ais ais 1 ais length 1 sub getinterval def
                ais length 0 ne {/gpf [gpf aload pop fnc1] def} if
            } if
        } if
    } if

    method (0) eq {
        /cdf [ 0 ] def
        /gpf [] def
        /mode (numeric) def
    } if

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for

    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        /used exch def
        ccversion (c) ne {  % cc-a or cc-b
            <<
            /a [
                [167 138 118 108 88 78 59]
                [167 138 118  98 78]
                [197 167 138 108 78]
            ]
            /b [
                [ 336  296 256 208 160 104  56]
                [ 768  648 536 416 304 208 152 112  72 32]
                [1184 1016 840 672 496 352 264 208 152 96 56]
            ]
            >> ccversion get cccolumns 2 sub get /bitcaps exch def
            -1 bitcaps {dup used ge {exch} if pop} forall
            dup -1 ne {used sub} if
        } {
            << /c -1 >> ccversion get pop  % Assert cc-c
            /m used 8 div ceiling cvi dup 6 idiv 5 mul exch 6 mod add def
            m   40 le               {8 } if
            m   41 ge m  160 le and {16} if
            m  161 ge m  320 le and {32} if
            m  321 ge               {64} if
            /eccws exch def
            /m m eccws add 3 add def
            /c linwidth 52 sub 17 idiv def
            m c idiv 90 gt {/c c 1 add def} if
            /r m c div ceiling cvi def
            /tgt c r mul eccws sub 3 sub dup 5 idiv 6 mul exch 5 mod add 8 mul def
            used 8296 le {tgt used sub} {-1} ifelse
        } ifelse
        dup -1 eq {  % Upgrade CC-A to CC-B or CC-B to CC-C to fit
            pop
            ccversion (a) eq {
                /ccversion (b) def
            } {
                ccversion (b) eq lintype (gs1-128) eq and {
                    /ccversion (c) def
                    /cccolumns linwidth 52 sub 17 idiv def
                } {
                    /ccversion -1 def
                } ifelse
            } ifelse 
            used rembits
        } if
    } bind def

    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def

    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 8296 array def
    /i 0 def /j 0 def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem cdf length j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def

    % Create pad
    /pad cdf length gpf length add rembits array def
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
        mode (alpha) eq {  % Prefix FNC1
            /pad [ 1 1 1 1 1 pad aload pop ] 0 pad length getinterval def
        } if
    } if

    % Concatinate fields
    /bits [
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def

    ccversion (a) eq {
        /pwr928 [
            [ 0 0 0 0 0 0 1 ]
            68 {7 array} repeat
        ] def
        1 1 68 {
            /j exch def
            /v 0 def
            6 -1 1 {
                /i exch def
                /v pwr928 j 1 sub get i get 2 mul v 928 idiv add def
                pwr928 j get i v 928 mod put 
            } for   
            pwr928 j get 0 pwr928 j 1 sub get 0 get 2 mul v 928 idiv add put
        } for
        /cws [ 28 {0} repeat ] def
        /b 0 def /c 0 def
        {  % loop
            b bits length eq {exit} if
            /bs bits b 69 bits length b sub 2 copy gt {exch} if pop getinterval def
            /bsl bs length def
            /cs cws c bsl 10 idiv 1 add getinterval def
            /csl cs length def
            0 1 bsl 1 sub {
                /i exch def
                0 1 csl 1 sub {
                    /j exch def
                    cs j 2 copy get
                    pwr928 i get j 7 add csl sub get
                    bs bsl i sub 1 sub get
                    mul add put
                } for
            } for
            csl 1 sub -1 1 {
                /i exch def
                cs i 1 sub 2 copy get cs i get 928 idiv add put
                cs i 2 copy get 928 mod put
            } for 
            /b b bsl add def
            /c c csl add def
        } loop
        /cws cws 0 c getinterval def
        /barcode cws length 4 mul string def
        0 1 cws length 1 sub {
            /i exch def
            (^   ) 4 string copy dup cws i get 10 4 string cvrs
            dup length 4 exch sub exch putinterval
            barcode i 4 mul 3 -1 roll putinterval
        } for
        options (dontdraw) true put
        options (cca) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (b) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccb) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (c) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccc) true put
        options (columns) cccolumns put
        /args barcode options //pdf417 exec def
    } if

    args
    dontdraw not //renmatrix if

    end

} bind def
/gs1-cc dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-cc--

% --BEGIN ENCODER ean13composite--
% --REQUIRES ean13 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13 Composite
% --EXAM: 331234567890|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean13composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean13 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/ean13composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13composite--

% --BEGIN ENCODER ean8composite--
% --REQUIRES ean8 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8 Composite
% --EXAM: 12345670|(21)A12345678
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean8 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean8composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    % Get the result of encoding with ean8 and gs1-cc
    options (lintype) (ean8) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean8 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  65 {0} repeat  1 0
            1 0  65 {0} repeat  0 1
            0 1  65 {0} repeat  1 0
        ]
        /pixx 69
        /pixy 3
        /height 6 72 div
        /width 69 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec
    dup (pixx) get 69 exch sub 6 rmoveto
    //renmatrix exec

    grestore

    end

} bind def
/ean8composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8composite--

% --BEGIN ENCODER upcacomposite--
% --REQUIRES upca micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A Composite
% --EXAM: 01600033610|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upca dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcacomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upca exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcacomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcacomposite--

% --BEGIN ENCODER upcecomposite--
% --REQUIRES upce micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E Composite
% --EXAM: 0121230|(15)021231
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upce dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcecomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    % Define the separator
    /sep <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ] 
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> def

    gsave

    options (lintype) (upce) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upce exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ]
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcecomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcecomposite--

% --BEGIN ENCODER databaromnicomposite--
% --REQUIRES databaromni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databaromni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databaromni exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databaromnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromnicomposite--

% --BEGIN ENCODER databarstackedcomposite--
% --REQUIRES databaromni databarstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Composite
% --EXAM: (01)03412345678900|(17)010200
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedcomposite--

% --BEGIN ENCODER databarstackedomnicomposite--
% --REQUIRES databaromni databarstackedomni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstackedomni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstackedomni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstackedomni exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedomnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomnicomposite--

% --BEGIN ENCODER databartruncatedcomposite--
% --REQUIRES databaromni databartruncated micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Truncated Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databartruncated dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncatedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databartruncated) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databartruncated exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databartruncatedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncatedcomposite--

% --BEGIN ENCODER databarlimitedcomposite--
% --REQUIRES databarlimited micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Limited Composite
% --EXAM: (01)03512345678907|(21)abcdefghijklmnopqrstuv
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarlimited dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimitedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarlimited) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarlimited exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec 
    dup (pixx) get 72 exch sub 1 rmoveto 
    //renmatrix exec

    grestore

    end

} bind def
/databarlimitedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimitedcomposite--

% --BEGIN ENCODER databarexpandedcomposite--
% --REQUIRES databarexpanded micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Composite
% --EXAM: (01)93712345678904(3103)001234|(91)1A2B3C4D5E
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpanded) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpanded exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    [  % Finder pattern module positions
        18 98 bot length 13 sub {} for
        69 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedcomposite--

% --BEGIN ENCODER databarexpandedstackedcomposite--
% --REQUIRES databarexpanded databarexpandedstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Stacked Composite
% --EXAM: (01)00012345678905(10)ABCDEF|(21)12345678
% --EXOP: segments=4 
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpandedstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpandedstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    [  % Finder pattern module positions
        19 98 bot length 13 sub {} for
        70 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    bot 0 get 0 eq {2} {0} ifelse 1 rmoveto
    comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstackedcomposite--

% --BEGIN ENCODER gs1-128composite--
% --REQUIRES code128 gs1-128 micropdf417 pdf417 gs1-cc--
% --DESC: GS1-128 Composite
% --EXAM: (00)030123456789012340|(02)13012345678909(37)24(10)1234567ABCDEFG
% --EXOP: ccversion=c
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /gs1-128 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (inkspread) (0) put
    options (dontdraw) true put

    % Dummy plot of linear part with CC-A to get width
    options (linkagea) true put
    linear << options {} forall >> //gs1-128 exec
    (sbs) get 0 exch {add} forall /linwidth exch def

    % Create 2D part and determine type
    options (lintype) (gs1-128) put
    options (linwidth) linwidth put
    comp options //gs1-cc exec /compsym exch def
    compsym (pixx) get 99 eq {(a)} {(c)} ifelse /linktype exch def 

    % Plot linear part
    linktype (a) eq {
        options (linkagea) true put
        options (linkagec) false put
    } {
        options (linkagea) false put
        options (linkagec) true put
    } ifelse
    linear << options {} forall >> //gs1-128 exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    linktype (a) eq {
        /s linwidth 2 sub 11 idiv def
        /p s 9 sub 2 idiv def
        /x s p sub 1 sub 11 mul 10 add p 0 eq {2 add} if 99 sub def
        x 1 rmoveto
    } {
        -7 1 rmoveto 
    } ifelse

    compsym //renmatrix exec

    grestore

    end

} bind def
/gs1-128composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128composite--

% --BEGIN ENCODER hibccode39--
% --REQUIRES code39--
% --DESC: HIBC Code 39
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode39--

% --BEGIN ENCODER hibccode128--
% --REQUIRES code128--
% --DESC: HIBC Code 128
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode128 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code128
    options (dontdraw) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode128--

% --BEGIN ENCODER hibcdatamatrix--
% --REQUIRES datamatrix--
% --DESC: HIBC Data Matrix
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/hibcdatamatrix {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with datamatrix
    options (dontdraw) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcdatamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcdatamatrix--

% --BEGIN ENCODER hibcpdf417--
% --REQUIRES pdf417--
% --DESC: HIBC PDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcpdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with pdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //pdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcpdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcpdf417--

% --BEGIN ENCODER hibcmicropdf417--
% --REQUIRES micropdf417--
% --DESC: HIBC MicroPDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcmicropdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with micropdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //micropdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcmicropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcmicropdf417--

% --BEGIN ENCODER hibcqrcode--
% --REQUIRES qrcode--
% --DESC: HIBC QR Code
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/hibcqrcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with qrcode
    options (dontdraw) true put
    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcqrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcqrcode--

% --BEGIN ENCODER hibccodablockf--
% --REQUIRES codablockf--
% --DESC: HIBC Codablock F
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /codablockf dup /uk.co.terryburton.bwipp findresource put
begin
/hibccodablockf {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with codablockf
    options (dontdraw) true put
    /args barcode options //codablockf exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibccodablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccodablockf--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: dejavuserif_ot1.enc 0 0
% THIS FILE WAS AUTOMATICALLY GENERATED -- DO NOT EDIT

%%AutoEnc_erxmsn2dewfhvd5ktdkymdjaed
% Encoding created by otftotfm on Wed Nov  2 22:52:39 2011
% Command line follows encoding
/AutoEnc_erxmsn2dewfhvd5ktdkymdjaed [
%00
  /Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon
  /Phi /Psi /uni2126 /uniFB00 /fi /fl /uniFB03 /uniFB04
%10
  /dotlessi /dotlessj /grave /acute /caron /breve /macron /ring
  /cedilla /germandbls /ae /oe /oslash /AE /OE /Oslash
%20
  /space /exclam /quotedblright /numbersign /dollar /percent /ampersand /quoteright
  /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash
%30
  /zero /one /two /three /four /five /six /seven
  /eight /nine /colon /semicolon /exclamdown /equal /questiondown /question
%40
  /at /A /B /C /D /E /F /G
  /H /I /J /K /L /M /N /O
%50
  /P /Q /R /S /T /U /V /W
  /X /Y /Z /bracketleft /quotedblleft /bracketright /circumflex /dotaccent
%60
  /quoteleft /a /b /c /d /e /f /g
  /h /i /j /k /l /m /n /o
%70
  /p /q /r /s /t /u /v /w
  /x /y /z /endash /emdash /hungarumlaut /tilde /dieresis
%80
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%90
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%A0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%B0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%C0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%D0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%E0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
%F0
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
  /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
] def
% Command line: 'otftotfm --encoding=fontools_ot1 --pl
% --map-file=DejaVuSerif.map --no-updmap --no-type1 --coding-scheme=TEX TEXT
% --feature=kern DejaVuSerif-Bold.ttf DejaVuSerif-Bold-tlf-ot1'

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: DejaVuSerif-Bold
%!PS-AdobeFont-1.0: DejaVuSerif-Bold 2.33
%%Title: DejaVuSerif-Bold
%Version: 2.33
%%CreationDate: Tue Jul 26 17:07:04 2011
%%Creator: ,,,
%Copyright: Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
%Copyright: DejaVu changes are in public domain
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DejaVuSerif-Bold def
/FontBBox {-1712 -797 3678 2345 }readonly def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (2.33) readonly def
/Notice (Copyright \050c\051 2003 by Bitstream, Inc. All Rights Reserved.\012DejaVu changes are in public domain\012) readonly def
% Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
% DejaVu changes are in public domain
/FullName (DejaVu Serif Bold) readonly def
/FamilyName (DejaVu Serif) readonly def
/Weight (Bold) readonly def
/FSType 0 def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -85 def
/UnderlineThickness 90 def
/ascent 1556 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE366EF37D4823F376DD9F7E4CBB15
DA8E93E91E84D36BA5A5B06F3A46B45692ED11C8FC76C0B0B3157F699878E2ED
D89511CBE105EB42FD76309DA91EEEE85F1AED9920648285111A1690C4AE2638
C0601A7DBC8D2D41CA8C4F9DC7A6AA5C51015D8BA926831892381DCA7E61E230
5BB3BD5632D276B929D97D4836F9703461BED94450CDD2660430A0D13F49EB47
72EB0371E38B92F488FD6E19C944811D4AA52CCC359210320B484568E5060BC5
4D2FDAC73C49BA0168FB5B1B18DA73B90B191ADB82B09D7A67C7148505FD5A8C
A6110FC44E016E0BCA5CA8727E32D7CE20AC8674F4F7421EBBE7669A225FDE04
258B0C44618E679FCB9ABD7AFBDBAE825AF06C35A619F50ED90F6AD57F8CE97A
0F39416A5EA6390B9D809081821D81DB4CEFE8D7134C5EB76C13010C0FAFBA08
D415AAC188B18036E5FB2DE31A0C6645063867D5EB16D89559B4F44B0F8D56BE
E53F4313B44A00812E8657CF6F1C3EC33D3D3FBECD050BF2F2FB8891EE47E992
2B76503E5E74ECC4884BA3B4665A3F29E2827828712DA7484C6EEED1A7E80088
1D76836C78D8952A27E9B53834B073F665A73271E3388D98804187798EA34710
576B7F13EDB8C10C712533807667898F6AB0BBD80D1DF8402C7194ABF7672895
44AA3DA1F06793F85BA6A8BC677E5105793E25A56B1FF9C2E1356174B0F4B76D
F098272E811C6BAE1620F1F9F87DD03AE8FE3FA5C7D2C5E08F380DE015AB1563
D62BAA94AA30F34840313BFC85BD23067FBF900674CC81A7365DA9984BD6376E
BA8B9E1A42D02C311EDF679B218B41F084346F2BEB0C06E05A3B7E85B0568C67
C35861B94816CE97E30AFFF44E5366F69729246F4C1979A3B360E351C29A83FD
BDDF79405BA69A5549CD6AA51D903496989ABFE27861448CF976C217FEF53831
9EF801E5D2C2FD7451709370DE212D12AF1DB77EE2B6831C13462459034B865B
EA8FA83A9DE296B4F26E026FBEBF29947C941D1AA655E437505EA06DCD6F080A
B1E1C660A3F01AB1C2E09F25D875F4672031BC16C495F0C3EACCC35813AC4A96
BBCD4632AE26912FC4058EBFFAC4F06A98D4315B5CD829D4A2519C2FA404752C
8EFFA70DF2A9E7366B7DC8B127CAF386695E7DD9FE9AFEC61AEF51A2BA973618
9076D7A9062F7D124E813DE8BA527BAEF9C8585C34637966B710BD51188832C2
251A86D03D07A9DCE8F4FF74E71D29A83650624337709C12DE762B15EDADAB8C
EBEEA7F9EAB26C2BF9799348C16C8AEB2DC1024A85BC2E00490AEC73C9D503A8
D4AE95DDFAD109387DA777DB9830FF4BF11C225ECE0BC6B07696B7B9441B74E0
F9D317762A4DDDAA7EAEE12D127B1F0593E187015AC3DA984A6312972DD589F0
2E9734EE41EA19F8D85E4A0119AABA15652FD5DDB23E073F06EC6AC01802B977
B3D12E057B8F6D53B2CA3B8F457C7819E6733AF633332FB3D3FDF9E7F4AA916D
98B5B236BCB7B2EB1D31C6ED43C0A9507F079F11D0895808E4FC9DE9294B3924
09CA50342329961AF8A7B8B57A4D288A0B990394D885172CDDE336828C5C7E9A
A852264BE6AE1947CB46C3DD0862F0FBBD32320A4A285316A90DBE0C14A45C86
BE8581C5022080D44E19B1BA9FC68D7DDFAAE97D3A4FC85F59DC3DA36970F543
4C787969EE56FF89C7C8F62D0B1640FD2B5839971AECBE8C0B2A0F3D408C45B4
11D81403F06C9110C3BCA13BA9B4E3936EC26E0C19BBAABD1264CD29CBF54A03
BCB7F041C87B293A1904E40AC8208B9D8F5541D7508CCF47D0472946ED167DFA
6FD6DC36047613EFC7C1CD331BF1FE33474F32CECC3F5D06E754359C53D0C150
77E17CE13F78F47442959C4B9E57A6D1A43974CFC633315BDC46D8ADD727058D
047EBAEC3266B9215773BD7963AE764A0FF306EF32C8D8527D30B073692206BD
2D1702D5E69DACF16E052748906A7BAACB812696681A7F9814347ECCFAC78379
49B1DE5FBA6284076BD9A43195E2EE6FC8323E0B84CF97D4D7873323BB96E862
E46E6D1840404216137D3F85FA5AB6F8C2A21D74B276CFE534F5FA3D46042577
4F0772692D65F17C81C86000A99370C24B0915E8CE35A1830914E7EFB9253FB8
1F0356459220E355D4244577C519B406F9AE91F681638DCF9E4D82E76D1D6DFE
17475CD8FF28DACAFB858FBAE2994E849CEB49B4E110A50030F777BE81A26687
B8A3BF6D8C5EBF056B001BBF474DC180134FB646827FBAFD181A79A9A22166EB
B0F28A59EB80C8D6EF2E534E6176D8B832C9D6C1C48775C7AF4A3B85B8952D64
F673C6224BD76514AA1ABE39A43B0C9FB0BDBB1D2B21B27B051605695D907A75
0DCD1BA592785E1AED175C5C0056E6B45205EA417939B3E216AFD97195E63484
70368EB85D6555D5D9B88CD70D3F14F6BFE287F4961D893CE4C062D8ED0668D3
7561C11ABCB2F3153DEECA9EF9640BB138EB151EFA1D57E04DAC81CDFDA92469
F9E6C1DEE4FC0E5A866CFDD14826EEE710FE847AD74FEA8FD14EA894C90ECC2C
4931DF4535E0E689089ED80E9A60E20B6C600BF6D78CAA30F6903E0643AA930A
540C6A14FDE732B64EA7CC61182E69B47EA4012783B1ACCA2703C6AE2E48719D
4A5233D8B5BBD83D4E5A5C4A2C87D4E4319A9618582F906F293F50E21077D224
1A991E18A7351F963E6FBDF54C0D5858A7A91792B9E0F09206559E6DBC1B8A9A
ABDDA62A08E7F52DEF59910559E575F7F5EE060F29E72DB4732479D58DF8DF39
C0D56044CE46DC59FA4E060D03955CB7505505D76DAB9DF9C57941E4FDA6AC52
4A46B69FEBD48D9FFEB825CC43AB1DD27F05C023018A3101AFB5F60462CE8A58
2E2BE01D68177F8F70C8A173FAAD0BDAF7E1081B3673FC5E83D519BF105D2891
172DF407C5A8095EDEDCD5D302B29C3EC07B8797F675574DE2E1ACCDA6AF0B5B
D63BA0D9D20EBBBF04F2AD7FAF614FBA02B0643CBA5E2F47E3982DCEAAD6FA56
59449A8CFBAFDF5A871FFBAF066F314F7D35A19C7D7EC5D092FC1CD3404EBDB5
FEF70420B2961051998C010CB163AB69CCC50AE343C61B2541FCFAD20291B9B9
C20657442A7949159167494E2D74C9012A3909CF7FDB5C83C391E81235562DC0
DDE4D1AC707FE143D6DDBAEA79759AF7E916ABE131D652D8B6035E9848CB0A42
4439DCE8CF66FDEB7E795FABDE5A405E01E397D100BCBBE07C087F2F32E95B67
639E9ED4F404F22426A887682A595C89CDC119A7326154B5F17B9ECABDADEEF0
F098A94661A11E5831349E0CF7BC9D85C462FD8B91E68718280D830A73CD3C17
B36B321DC48CD0F10C1323ABAA9F46E52E434E73FD0BDEE6B6DC510F2E2F0446
37C8D65567F429F7A8D0B800CF2781926F903910DD39980B5CD75FB2BE1E5E40
F17770F4F79F2A83DC02A29E28E0AF799630D06C47151A80737CB2210894B945
69B1053CC9F137880CCD6105DAF4F8093E5056A9A6FEC4B735AA6B1B907FDF66
47CA050F3F7F292FE2328237203FD8568B99E002CAE40CC89D08E3124B51289F
76A77E7FECD0C0B8AD5960D248D10B675BA8502BC4ED047CA796467546536086
4AAC13616234983DFA628CBE962E7BFA9D825715FAE6C0003E1A0AC99A065B25
01578813499FE4824EFA1C3A925FA55DF00DC78E93DC743BE70096146E77FB30
47E34274F95ECE098D5A0BD62615EDA3F9374C3187D1D906E9DDE9F97EFCDE6C
B9472074570AD4F0826BC7C1A7400CD16A787B3F0974FFE1EB6A5F2EE1D52F5E
97BBE013E06E721951905CA797775E89ECF130A00C078104BC1DA4F36BF59A66
56BF3DF895F0A5721EA17D04535F9897722A59B36112FCF5AC8B45025062A961
4014A76852008EBBB7ECA4663671007DB10A780487D8EE067AFFC4F0F4B4327C
D55C345ACFB459AF3B050716FCAB3B8400836958940CB8B1CE9538F930419178
4A45CE0E22057A7BB2BE82A9C25C8E1D8854598D4CD9FDF1640EDAFC48EA5E21
AA47C2057421626C042CEFE62FBF56B85F7289D83A89B0E16423A8406A91A689
2A4E30FBFF37C5DA8C0A9F2EA70314B388E1BCC489D7203B64BFAF4968ECD0AF
6DB1EA8F1068E4EC483630080A93E142D45B6F03118E3BF2AA45FBF8927EB80C
12BA0BAEFA1593B64610DFE2C8F8143995B355ACF60CE20DD0118EC6F1CE4C8B
B8A2DFCD3DF14AAF39C135C96F65A6EF6BB80DFC78FDE7283533C5871C238C89
A3BCC8435788ABBE3E16D9420DAA3384E6BD73CA7BC065D66EDBAF6991651B94
066AEAA2C04CC8947FE1F6DF65104D3039B654F12A62C2F7BBCAF61BF18BAFCE
64A63DB17995DA12E9DC63A0AE86E25F50EC03E3813512E7B52C9E1B81A3A875
1B7B444CDECFD1D1E6EBAD40F6E5C82DE33894F69BA43F2B7FA8413D12C79DFB
002E84A5A4B7D422B5166741E4D383856A40B2FC7AD23B894722B95AAF1AAFAE
9C33773C4EE8CF233CCAC209E22FA3741C180940BA28A7DBB6DB8D49A3B7BBDF
92A3605103755A43CA9CDD482C9F58B9262E82ACFDEFF23C5586F1678AC51E19
289B016E99BB190AA03C4600104F39FE681F48B18A502CD0DF2CB76A18E9B851
F8E13CA963CABCE0334D4DE7CDDC68151F68B5B56FBEE678FC75A9C8C9E32BD3
528BF503841577F4675F2A2C6AFF9112EEF5C848D7DFCEC8440D12FB0D61DA48
62A2546A118AD85CB36B5B0952C39B8F5289AA97D0F6E4216254CA055C063E7E
49D2618F36EC160719B5AC253A5F4DFDAC0A0C8EA09AFFEDF53E459A3C5ECABF
BCDE9967A4A4069844CC754238576EDB7992EEE8406A082F1A28605E8A4551F4
85C5BC88DC2CF6DE8544ACC2392FB864C990285637ABADF579CBA1CBA9FAD91B
0044338DBEDC425588147A2867676D5163A5F21A91588826C4037DBB8BFB85F9
190072D92E9959C80EBE90292172E0786405E3D26E8CC080426CA26819A75381
425315540F0000771DBBB09113493A047661D1F9729657D5FAC5F03D6A6FD280
C52ADF035261BBDB42172EDB5FE230CED8EA98F5D1CFCDFA3BA167226859C4F1
145E925C47DB91215612A00ED889A957F557D2B5692B73B4B443BD21780029AE
B4D5AA5FED77719AA84994364F7A4E1B0866E116F4675AB99FA9787A61CC88B7
8AE0C40615945A49AA6F97E09BB2D55473103E29AA10144B9EF8CACFCD25F537
A7CBD5E0C128A5C5CF9724F473BB049466F725322B7673E6084BA7890CB7BE7F
79AEBFD1595A8FBF7989DFC9B6635AB59BC9CF5A696D33ADBFB151D8BE2B4869
0CD10E006215F3617272B5FA8F8D732B636C3EAD9378398DD9BCE4B51BF0FE3A
80276CD9F2B05DCF7B6262E3453B896EB409B40EE6FEEB8F77DB7D76574770F2
FB07C09BF758BA2F94677B7D95C7536CEFF84861EE60DE79496DE812144B5CD2
CC0CD4A6798737F473066E8CB8FF7AD319233F5725EBE7A1885A08286F35FA06
509BD88A2069240DF5A0243B54330DBA0702C7BA365A40ED4FBA068D87488337
D6B8A49B01A33D0CB7304DF09CBAA650F5915CF01822BD9DD4EB0CDDA0842B78
29307BFD8A0ABFB660F4B858C01A0C1652637459D6D816F39A44BB36F464F6D5
CF812C75DC682C289E0FA63332DB2B087F00E9F64918C9BE0B97C401595681B5
6ADBA11E7E120FFFCA8F49BA4E185A533C640724610D7BE23D55705AEE3B3BF7
46E4D85ECCBC801F6EC84B5CA0BC9E3E17E540756C01B1C4192BB26C9B91BF73
C3DADFC93EE37E675551A292C56E2BF5B93A6FFE68E8E4E4FA1E20C2C724C13A
A6818E25EC2812BF790F25D7874904C2BB6B5D5FCAD78064C1EBFB7F91657BA1
9428105F1C1829F0D7E29359723DBE0D946628A5EA2C1F80F809DFCDAF3F8D05
1AD5C04C594D6170C3FD61607BBB47F05673FC5369E62D3264A16FD88ECBDFB9
AE8B861BECC8202D041EE363A854650A750E5FCBE8D2C9CA4B08565DF70512C1
8D1951924586AD745404F06771645EE0BB2581812A2CD9BB92B547079F1F1544
B817AA0223558BB65D35CC0E2554B3A1CDFF0DBCAC036115ACC2E101DD04779D
1D7DA7C626EA03A2E073BA2DC76132130B5A1F4DF0E05B45734126D7F49B7BB3
9453ED710A8BA282C09691A325F773014BC05ADA18DB26B5E2953814FBE4ACBB
8C414A91DAFF185D0570830CFCEEDE48CCB7B8DA9755A9AA6CCB3E787B46158B
822607B97D7DFDEC3E034432A1DED8D4862D3D4AF2D4B3A53C10FCB2CCAB9E7E
3193A7EE5ED54A58F8B1EC7B78C45A426E330D058CE29B9DFD1C375F33D47A94
92929B5170AA9EBAF61AA7A2A977AB60BEA8748A8653448BC073037F8DA04A1E
1146CD805086771A19A76ADE573451A5A22BCBF0D6A339181F19FBD60BBB7E8B
04C7627E9FDC68EBCD92FB394DC80A7AD93402B93119BD2BEA37B990615F15E2
D1F372EE885859BB1AAEDE284E1FFA7253B2BDC4688FD8CFAB30C1E17237B8D7
2C960315B16E8E26434217AB8EF8BCDB8C2F7706DBB0186A6CB635330CDF1CC0
433BEDDD7C7D7A5C744FE748C93FA63C009B32D4E532BA176D271788738D21D6
FD8DA36148F7335B28849C632B37208A06F0B5025594367389246E71CC07379D
B5684FE50309423615F8E26C28C29A9A571DAF8B4BF622CD4F50CBB134AF18AF
C4CDBE2AD8BB94446086FE93D6960362AFA908FCC2037CF7911EA78C4CE6A48F
CC2E18C95CF27DC1EA30BBBCDC325315865D1073E6B7C8EF07F5A3E47BBE8EC3
12768DDD750D624F71B13D4FFA05D3D8CAA7EA0717F584F5A361D284CC48F56C
20D4B77CF77AD15AACB90B2C6E01D43CE307AE5A8D534203F339909B87218068
07C4B280EB85F467B09C837C252C1E7486E04A86D2A9F714E12ADEC865F14E14
DB2DE27C8BD35600775FF26CC271E12C6719EE4E00576DA30BB94BF0DFD10BDC
484CE123E6C8880CB5BD7AD7C8F6C422BEC958588A7D406CCBAEC4238AA0D5D9
A2ECE770360A69D958A16D141D240A959F59D58589C4A0A0D686D244B14D4689
F7CCC9C4270280D8C45D72F102616EBAEA0C8445E6C0FF9CA58062DEAF622A3E
24E43AC32915E2DD45B63858D38A7F62A3C9E6E90584A16F424CE18375EB248C
7E8DF9ACCF1AA5B6BD55A0F850BA7FBB0E80A8600920D018804D712E93B820EC
F4658380D3F464753D6434A2A9985E8DB1F08A0243100B39A4A9CF565FF9B216
151ACF02B0890CD212138F8D0049FDE1F9A87D1D275972F33932D153F7FBFE92
A4F2807BE51C6CD09D71994EE172309C15E58406E9F016C9CD7700D2371B4DF7
F2D24A25623FB0919A561A8A0FB206B6AFBB97EB505BEB707D168C974B4997CD
1925601F4B9A0F510060E9C3D90C83B298522C38B3A0770AA0ADA9158A2774F9
BDD6C2CDF16E6E31E18066BC3EF96FA6E4452CCEE6FF4916014F0A17F332C36C
21FEDF792ED6B4804CD113FD6C74FBB8BA56078C6F7CD4635845C8DECFA73B07
BBE7B7A79CAA6905D49CECD3549B632110B10D1CF05E62C70957C44FD2199DB0
F994C41173ABB09DDB665765E9C677148469D8A7D570A360AA8D68F720E7D412
986CCD4999938C1194C60AC0FBF1DA0E2B3A74A97E4BC6903E6BA3C278724B25
27774F245D3DB5038C62F3DBEE507F79A3B1272085C4A0F9B78E4B041DAB2230
27F979ED51478849BF758C3203E19DD04A9FA170BD23E1BC82201D2A49562A5D
BAF7829F26AE4BDDEA76E41BEFC5A8F562ADCECDCD6D6DE859F14EBA00889B34
680BD9D61DB322C4D47D2283DBFB189B6578EF999F25ECA2EADDCC7CF18185F0
56EF13FFCD8C2DDE7A60B8CB96E5D1EB0B9563E272E3D2ABCCB7662F664BF785
D6C8D416F7AD733A4AB116EF151F02292D5331BF1D5FA0FF3D467F881A9919C4
53911C7F03FED3A6E0CE5A74D64501B595B3DB093DD42E0D848C5D9668F6CA4E
16DB49502788D2522AD67FA43DB349821975DA03DEDBC693424A1C0FC2FF7194
9E8FB119B21C90975F74D88887461DF29B23AF194E8F983AEEE17A046E6D038B
592F31D9B197F8CEAD85820F5853DF91447D192C61C6E96F276FC34D2809D0D8
DF0356D99ED3DD8649A1B1B360921675AEF8F27C12484CCE6E453A52AD7577C8
EB4BCC88ACBC5A62EA1F054D8C42950B3C29536DCB6D816B53B45385444EE30D
969A1BCFD3A71BA2D3F48A9951FD6B2822789384F7D9EE826C81146E0271E215
FB6C52D696C91C62C88CD8FF8EAC9B1E248D02EA353EA834E1F86079F3BBC478
D2E71F066D3D26FAB85CE144D714421F6D812255D98D2E8F84071C57846B762D
196EF8BB52352C46E79E593D3AED1F7A32042B0CF6AD0F9FD93A8363B2BFA3A6
D05A917C60C1BEB6E461EA4BFD466A84E813657B78B7EED0FE65C1063341E30B
49E0AF725F33C1522522D8B549791ABB8FD762FF7E5E4AEE023DBB719C879D32
0C078A18E9805AC997F33CE3720152EB663A80221FF868772EAFFA628BDF678B
6A122C5D3566DAEDCF5A68D5F48F6260172DAF7E3481BB28B03F6EC80067CE01
220662CB6FC9D8585FE53E837723E7EC88DBC9623EB67E43E583D180C5BFEEDD
FE8A7E2F2BFB0BEC6F95B8C6EA8C10AAD1B220F9934FBCB5253548342C8CB5E8
0FBFBA2FFF1155EDDEFA2EF538083B9CB3E50B58957A46918DADC4502323B2A7
91A83E9FCCE9DB93FA17ACACE26162BE668CF5900DFA554566C03C41627AF321
C8A236718BC41DCAEA3D53308301D2455C44871F62B4374D33A0A7952290BD32
D4FA99376ECEAB73FAA3AE70AF6C410FC2C53240ADDB952B19AE1A42B7F91AD6
01E11727C3F6202CE54B4721D91BE74A1C5AF9926494363A3AB8BF9AB46B48CF
BFCDADF56B75CF5E586FF88F053DF7E45B73C5E881921C5E32CADEE349EBD2D2
47910A3443DDB94D17773DA4060CD7AA7EE7F7C096FFA02F64C2E55C9E6CB7CF
007C5D8ECA333DC0D7A1CBF295B6D42F3F8956FDC4CE39D270600591CA10A787
A564C7F4E3B3177A77FF007855BC04AB79612352C2F5CBC7FA7689EE3492642A
9ACFEBC4D8F218DBD312ECAFC6EF8241C0AB16BD7F4778FD5025D726F62C9FB4
9B1F534912E27847F042513DE9D027DE90FE34A64A4F458E42969AF88BF8E3C3
B00FF268B8034834F62A2E3DA02AD3E6115852071CF23F177ABE43F96D99834C
A4E059114D5D58C58CADC2E8206D36E213BCD44AEABC323EE9EE24FB1F4DBD5C
72760FF255A12AB2E2612A07558C99BA1AC5772D9485976154719D4356835CF0
37ACE47977E8AAF7DD60E8195FC8D684CA5C0606638EC92D22803DE1D2A645BA
3E07E8CCDC0B3270FB95186053A6C93275F496D2E1B38432E567F630F989B8F2
461D9160891229E560A86E4FFEA9FE34FFE1CC70634FD1D12FA8D90CC312E0EE
B4FE0B841878D9695335EEF5D46E4D64665B765B7EFCF638A22D59B321D77355
5EE9D7EC1AC80DD723709E4A20F61F255CF12B7F4C9E7B5A0388AB5D29C068A9
F5C849848513FE3359F4999642B5E10C67F7A1225ED58E111BB73235DD34B0C3
82CC367E275DF521E8EC14CAD25439E8B1774CE17A8B9D17EFF8288E2A9FD25C
F4B0DB536C6E566C23E61366D0E9E9307B643BC5EC8ECF4E48AEAB40B162A85E
59066EF770B66D822509EFF49978B2278E7E49C9B2B57DCA66DF01380E18093A
2B5C2222B0EBF1D6F0A32634794462E06C90DF1FA02E3DDCB6C9089F9E4BDB62
186F86D72BF2695E86BF861CDF883DAE4138BBEF2610417535D4FD8B23D153FB
C0CB034A530A270E5EE898393EA4144EE4FC75924CCB4F3BB592776AC6D45D0F
B799221F3122A5775D8CFB67D6DDE812FD7B85D3D3751C4812F5330251F02E89
183D62B82363493ADBFD189D53E4EDE56F2C90F2C21D41F9FA81E7AE33F820EE
AD8474A7E37DE07B5212C1C2644D6255271B41335C84E5E982FD6959F38E06C3
402CEAC6B709D2F5C724A2E748403304ADD9E3B6ECFCC3C7A7D26021EC57199E
79CC100592B42C0469057EB68E0C2CCBC0D7C54718F308E38C1FBF87C4DD28EA
45171A1FD3648AEB33D1F8CEE075DF54E4663AF5CCD1B2C008A3E8A3872DAA20
7300FC4A04B7B8E68FF8BC83B7293B73604C5867297DDC14A3509F302346F329
985B2E3B93FCB486185E935B3B489FEBEE7056564F577504946E74D13D46D426
495FC909D44E0C3E1A32BAFF8E470693724E4BA14F9D6FFFE61CF92620895FE8
1EA9257C52D59C55FEC5241CDC0D622948E1B4D35EDAEA4A7DBE598D7CE9384A
F4BA7A0E293EB85D0A615805E8B18F228E782BC647A3C8EC743E62EDE48FE310
BE56FD38373087CA34384A5A09E78577F5E5C28D9A09F3EE393551EE67685DED
590BD45AD44ACCD46333773BBD9386ED0C94C99A048B2D9CD00BC3CB1B2CADBA
164FFE336D4D3B4F89387EEF84A36EBB74CE59EA42C733F2B0E7F1E81AB38023
28E207DC20F9AA3413CDDE50A40EC3267579B90EC9426F3F015DF862802A8A93
866F2A9FDA23180BC128604DC225404F3962231350953FACECFD82FBD821919E
3542B33690DF45E473C1D5495826470F3A1F450D1AC2C81C876EDE256B35FC85
F9AE85F4F67AC68356B79A32C8EF2F93D8C34314D2F1EFBB672BD3953376F6CD
CE4BBB99E52D1945854E9A8619242540A70DDB7F54653F2A4F4E6697F71D328B
75CA08F0349BCBFADB123B709C8290B4C6D1CDC771DDDBE48FE73DC9AFE60565
84D34D4F7FA730B1D9F41C84B93052048E1133AF2B75C79E068B36BC456E1266
07F1204F1F0BFE194653546989DAB1D2B004015658624A5DD1962298C636DA1E
106E683BB7527832C43DB3E4FC0B91C99F9EA3E2D7376BC2BCD4B01C42918CEB
E71225F940C7A0C5E1520D33D2E526F96D60D617D7BF6F412F70886B59D1F44E
961B2AE21FE872A47A018A14325EF5814CB9F1D658000F9A6D0BEC145A3555C9
F8D21121B132CCC4BBB3D0F0A77E11CBCD9529C73E42442B9B075D4134CEAB6B
9795706D703A7079A9ED5E6C4DDA6A7F88C9DB135B112EADE2AA32E0418B5027
04DB152294CA64E64059004D8E17EA918C2FC51C0B4B9B61E99DC0ACD6F51C17
181BF302868264836889EB98763D0BBC0B519A0328385E43119DABB5E909150C
7F20B3F3C1FF3FE9F08900C5E9897130C7BAE1C18E62922113FDCAF672286C8D
A1E6D5C8DF8B7744C740C8C120900D9C6DE051F4E19967EEB137E941CC923A4F
F6165F320742173EC76EB39875945207FD60831681E59CF308A0BA859E0FC685
04B9B3F1F2CFD9EB9D7612837CC07073DEF3868E3CA23772CBA46690AB66838D
A3C1059F220D5406D976F3FC5B3711BAA89D845582C07CC4DA3FF3C27C1FCA9D
8F5FF2340C72E5720FCCBB321ABB50B5C6606BB0F3230C5A69BB0898EB5E6BC3
9951E4BB6BF674BFA91069FF829035B240B6005BC03FBD8730764D12F4954E34
DC6BAEC8813E3675C256306A3E2B5F6F56ABBFE1FC07FAD8542975DA911C65CC
AEE98C1485369647E4A89B2E82A7139C613786507233335A0CE77DA6FF6749DB
F316AD729DD6FE7799919B9FAE85846403C25BD40C8FA2F0CDB5B31C4E520F7E
8AFC2806FFE098766835159164CAA71C1397547FF26974FDA37B9FA3B2BC8E00
0A28A9A46A008BB3DA49D4AD66D58B3F2818DB97152EC48B058F59E58C2CD405
B2AC3ED771DBE1A922D6DED5C4F0A27989096E316C147EB80895403DFF370199
33F9BB595C8F41B23ACFBFE1B555CAB62E1C4E555D92677945F82AAF1A5DDAF4
79F5C27BAC92012E8DCE6606FCC3B79341CBE1604C8DDDCBEAB3F2F1E29E2B6E
E55EB973F69847AFA49D971E81193E80DD4AC27BCBE8A791508A5011134334D5
FB573182E315026D8E3F2CED177BAE7DF00B87E8253FA9477DFD4BFE92BBD43A
E67FF79340858E78DAFE524267885AFC39B6D1154D14A71DCA60778F9A093547
B33A92748539734AA0C0D13FF720EC320AEBF17A4B45836D87E315A3C53C253C
362D04884D62EAB2EE9908F222B73D4F64BB0815415BBF78CDA46AA8C0690194
90DDB92DAD96DF1ED313C94918F40D11A6D2B9AE0ADD81D202DBD02A70D829D6
4717BDC48F8E503BD8B51571AA87AA6642772918EFA4C6751F0FB04F585DF360
C792F2CB32436D71528AF2E51F122DB96C388712646572966299848CB69F6130
164F9657DD68D23BDD8E2CFED57952A1BE26E3051FE22553270FC27F507FF941
1392C49B59ADB1CB24F375C22B4FEBDE1E3B8DB84C8FC4CCDAEF0C16A9677B7A
2A3B7E440A3F1BE69215CF2839121B992A041985E7B71357496F114C655426AA
E1A09626897782D6BD26321C6C453EF3BA69F78B15392C0DDB685D93A36DFF2D
5D74C23D3D2B079C4CEA01DC3438CA136EFCE8522FD7DB85DF65E5DA9BBD2D07
3A400E7CA0B870EE6EBF02A0707CEABD8970B45F358227EB312ECA31CDBE9471
25BC9469BFAABD0AE593CB97EA86F2328BF82FD4E2D564DC73260FA82EBB7BB6
5C8E15CAB1B7CECF82BFDECA8B6120EE20A0487AAD74110A338E7125BE78EED5
319068344E4330ACA3403CAD8B8427AE66927036E62840318511F46B0E7AD9B0
0B33D1D7071FE6B6100A15BA246764ED89F7500B393E531E77C5D38E2FA76489
3C50807F9FB71336C911E3A9CDFCECA42400CC35C16CD72EB20B3C90FDFA27A2
E85088C5438123F2CCD94D6C828FCE1A45CD0C677E6524767CF6BEF1C12D4ABB
BD70C2E52E80AB9A71CC3FF0A4FCB3B2F24D7BD5A6991AE319D33A4379586D40
97FCAED8EC4158F543627F3A876E3B269DDB919565188D79405EDFBF0471C621
B33A67E7C5FF67BA7F0D17120A169D10C833EFBE2427953C2A836364CE130725
E58E5CE89DAE200B6ED48724C585C20C7473FFC1CE3FE9DD6C4636B1871D4825
7315CBD32F34B40511E802443E81475665B10C984708119D64F63D54D877AEDD
A0366E3DC296862B6C3ADD1AE321C4FBB7CDC332B7BDB6CCFDD7AAB5C00E6391
0286D0EF51D98C44DA75E3C94217539AFB4E5E6E11F3B5754F984A0C28E3ABBD
86FE951531E60B056D40F32AF7EE30784C1D3769006F2E08AE1976F3149AB109
A3D7B3B35809AF358F9541006FFFE0BF89F3F9D381CB388A15F879B90C01BC2D
312BE6A9FF2DFDC14AB2C743DB05CAE9D5F07F6F8F8FA6DC4751AC7A087C66B4
8FC161AFB61FB4E7F55123A44679E03ACFE47638762F7E9A6A108BCF044B22A2
610880BB063011A19FBC6D656A4ED2E5B8921A98BFCFB4CF921B89DF1A806F80
FF1071F4244FA7FDBA9706D1966245FF4FDD33617A3B9726DA73FDF9A60EF73C
75E4E531796628947D7F42448888060AC6F1A7667CAA53B4744002A92BC42A37
7D06F200E859C66E109FD105A5663A25424B00536CE124341504CFC0C2D12CA3
9B58890977D4A2CCBB6A94E77E2267F720110FE9FEF533C055CBBEB14D368617
D66C2DCF7189649E52F055CFE1597C90AFCD7390AFEBD3E9D64E0FE609AAC40A
E35846C29ED47A7FC2B75E897A2D63C7DB722BF93CE006E3BD7CCCFC660C4E8C
BD81480C16C977F96DF2AD89D66E6F499E3F887701D6CC903C1F84255758FF27
A9378CFD1B653B9CE7614A74FB3A1A86408756FF96B951BF70589B6EDE63FE43
B38670C1062FC8BD123038540A19A3899C4393323E2271FCA27FF1FB67D7FF57
17F07C001A1D3150F3451F600733C93155728031613B7D6CF2C7C288F31D89B4
990FC2A972BA35C460A7859DD27CB4B23D2BC60BDD99EFA7169F944D4AC0DA98
F6FD0D6BBFBF9FDEF79480446ED37D20148961F2DF2AD0B7AFDEC526BA62C38B
01FBCB9A56E41FB7F566D32F142E9477F1EFB414C7419657F7736FC85411B63E
7E89878FED6C3DE58515F4DB3BA9D7C8A10FAC71F04FBF47042D236FB3D13B84
A083454C60D710A22E37570A0B793B809867CB7B3A9E7D03CC6EC349DA8E3CD4
73D4C1D8B63624777EC82F3389B1A6B8F8BED51B4C001B4103EC54E130BFE9B2
74F2DA5CCB2F4FCE9B19B7B1996DB237D3701D8315BF6333B1F9CD14C2B94E6C
6F2BFDAF3C5E0E5B95872B4B09B2BB1DF1BCAEA153DF376986343AC61A47BCA0
0B23F3E21B0A14720E5D5CAF9FB1C2DFCC17F50F800F1833D83CFC62A9CA8AA0
7322E485CE7C3D4C0966FAA43D21C7A62A4E106B915578D127E095EEB126C93D
077066A5993EDE7CC09DF48F85B65734AF5D05D87D3B2D7551F9B16D8884E25C
8D5149EA8C25A2F408D6BF1F81CEA3E4979AEE51FB9DDBF770F81EC8625416C6
678E6D5E35A76AEB63C768C80A18DA16B68FB7603BCFE444897A76CBFC7D6CAD
57010F3C578134F26266A6AD77802E175A1DBC45859D339463E1F44E99592C2F
99AB949D716E55D88E47257C1FE183AF394190B777B38BE4E64B5E6CC0E25431
7AEB3CB18F61C476F2F92E264C729575398C43F2B5C76F88D0BD969AE5206F85
C48A183742D0A48F64AF4AB861DD357CCBFFF65A7A0B89091F354E87F986364D
1D48EC24E4D2B6C1BFC28E7B0744117EFA301E6BA7B8802CBC6D2715026243A6
83FB01F22E79C5808EB0CC781479916AB968204D34D67872954404FF109B6B43
5AB07605A14FFD6C6778CFD5900F0758E46D371EE38CD7C5B0E8027B3E454587
FEC2F1A3A01449E31F8FA4E506C6AC2F121EEC34A1B7864A997E6CAA66AFC294
778FE68559CC2CDF4DFA5DF0B7AB3FE21A76816DDCFFC8699A5E4C809A648F5B
90E17A270D094F0CFA64F1487F322A8C10412E9C1BB27D8580F30C8A53FC6F8B
065C026E1C4712985DFBAE3A9DAE93807490AE8F1F598B619C5ED0F36B9D30EC
B1BFE6610F9E7882FA2A0A9BDAA4A713E07E5F88227052A8DC70576FF045799C
D59368BC66C802EB0F6617691CD6C29EA97ECC13192AFFB17B0E0CF05CE05240
3E0A00CC7DEF0580404F24DC0E7C15A36E3CD036E4FF2EE0C6DB21A50296C1DD
57D91DF5C712E0BB3491FE84A6315E3616D6768197CAFF4D4247A42B73C5CF09
CF1310A4556B85303FD55647762A37AEA91DD324C8C3C1D54C968E8BC306CD64
BB9C55B200F32DFA59A7A26D3FFB5C4B33735967D1248C0541B6FEB8AF1680F2
2C4FAF9BE67416E8CC21ED92AFA2CE859965520AF2707FDE38CFA3B7400D5341
E9E6EB6D56B3970D514C3F923B45A27193D03BC1890F825C71959682D6568BC6
FDFC2BB649FE1556FD17C5D6FDDDEF7E68C46BC4414B198EA2E6D5D45DEA45BF
9C7F28A88B2E7A2F78DE222F6C4CCC5795E282C94F1E8A10A2268192E3A58AB1
66749756CE307E17A5353CA2DE7AD572D347FCDB5D230E0BDA2627E21F7FFD79
B3A39495ED2B43825A3587903EDBBF76FFD3D7DBD2F3D76F8E68601C11FFD1B7
F263ACE99955136B92D29D19BBCDF448D30BBA4C457D9C9EF178A8ACC2748BFA
7566FFF7EC5D1254FA331F9D38FE7144D37CABE844FB6FF91756C4D4EA83906E
6D21CC14E617850C2F6E4558BE71595AB9DCB1B9A5F3A59CB56F9BB7E05C36CD
0DE61F71BA60039DB209056E29229E48A37670D0A236743053B1BECB888793EB
34A3001D93406F6BD08BD08CBBDA1545BF2C42C095771A3786DDBD282B417C5A
27AC9D86D5FC29BDD962F90A2482A8F0D6A9A658BC138E23793D6F3BBEE1AF39
338AD3064FE1794651B2BEDFE58D448361C9F1EB8DD3B3DA38EC8846B4591B91
78B27E1E79A39ED44C782908BBDE16A26FE51445448371DE3F075EA67F4A45E4
747441F780A0CA1681B7DDA445E9B4E0BB9BB5C3B9C022A2572377D9AA6E5EC2
2A7373B701639BCA947ED7647B749F4C1646F45E00FBA2E3E0DA1852D71DFC42
3A6C43F35B0C0A2C627B3642F04E2B2EA266F29B57B351EE5948D08E8DA4C2EB
DDE11171C1BD26CB02258A0A66D87230C61A82797016350FDD8F5A142121418E
D435D8EF6E23B3F5DE3DCD179A37FD745E2490454D4FEFDD9B12DA394FF35F49
D5D137625631CAD2D6B6749605D65DD1D01B8650B389A73CF784CCB0200C014E
D5179AEFC6EE6EBE14244192A60DB0EE3D66C0768CD182C5458E277A79026A7D
73F6ADCE9B38DC5BCA6F788F5BACB7DF23AE9DF62B9573AA50ED01590C22DBE6
69C28BD09DC0F8890D21F41BBEEE4A957F46B9AFE64D405CE1D9DAA43F48EC10
7198FC2A9BBAF27BE6C0A2FC1C1BD5084C37DE5E6AE9BC4DA9913650E36CA327
72206D55B9E8464FF35E5B2AC5264F99CE3017E51C8DF4F82CABA4CC128CADE3
D54AFC085219BF236CC093EA82DB9EC67B8E44EC96CA2888B8B1415CC0C12201
10DFDF7DF0BC842B04DC7CAD934076E4A63589C016834A06D47ED6807DE6E669
5B7422C2672D5B319029BD4F51080B022FF2F43685794992FF29A0B74AE1A2AB
081BECAB07138E099C7A4CA7896B790B3ECCA0132DA0AB750D5710815A64FA6A
6F16F313D1F7C524C89B8DE03548A80CE6B07E1C5B7CFBAB175A9064D56AA983
18F927BC5413C809F8A91D28C18D930BE04F1144762A6379A51AD38647F9A23F
48A1924387CE328F0108D6C2DB3501F86BBED991A951BCDDBD720D6FF89EC008
D8DAC7D5BEDB859D4639819F97EB87DD1777412B1CBD0EBD045B9EBD57EBC72E
C920FAC9FFA98B01B2E6326E1BB09F615A99E7206498CA9E3E0CA1B16CB50398
6F9D39722BB53933FFFDA91E906F4706D957010FA31E877F0A2FC6164585C5D7
BCCA66B7D72F73F939421DD3A65494EF576A9229802352B69DD8D0DCCA65693C
D4CB6512A1467BF70D957AD8DD1B267CB3F777ED8C48C3C605C4FA4477313831
E58B331058FBCEEC179519C059F4D50D356DDDFFAC302AAB7AE180CA51115636
C92F8F30677597E587FC41E5C04B4D71EAE22E9AB830108A138E760F42415740
33C78F38630591CE5F32566CEECAABDC2E8D190A39F50EDF95E5CD7B60375CDA
DD748924CAB63DB38D9A824EB7606F4BFB7B4160623AB5E559807FE2972F95C9
FC9FEA4E2C915826432A1E3303E48B9E397EFC3424EE2AA4D198BB6D9CB8A64B
682A613F36614273AA8B5D6275CA6B4B0FE9BF7A10B800B35E73D7DCCDB9AC0F
B1C801F27A290495B9D33E8CF31C5D103CA1EAA06A3BE038A7FE70CE5AA279EB
B065478C5A8B6C5EEEC7CF994BE8DE8672207703D00D9E6A2484139542DBFDC6
3493D8B9EF33711947B65B0C07BB7FE129ECC0D55955EBF49DAC8DDF427DD8BC
EDFD5D15F53B69B3258BB81E248987CE1A14766F76AF88BBF04AFE1D0108BE4C
8F5DB698E081FD5E431E713D3FE047C727B263909499E455D87412DECC667F8D
B576258F9DEB16B52CD8232E2BB8D40EE21FEC76772B068BE0633D26BD02D19F
898974A0BF0515018956A098FED59FAC5E06F30EE2F085B06BFE3AE025A0542F
0D7F681BFFDEB194A2E03372C07EC4D6535417772E66F4D60EC31ECF0F4808BB
C4AEA4881748C0A2F1F9A03CCD80180FC64BA55DB6D86E691B2CA7B82F4ED280
2349FAAB0ABC4753D785E1D0E5068ED5F42F2186618ECA4318D684C85850D198
A66AD2991F011A878BC86753A989AA0B58031C35D267D135532232FE5F02F3EE
B5DA8E4B3F9DAB8924BB86A7B1E2DDDCB2BC12801C4A8ECD0B107CB61A270FED
F98CE5BA1AB235E1190BA23732E42841B2BF693EE38C51C48C374BA974F603DF
4E0C8BE81C50F1CF9F68DED94E943ACCCD35893686E88F8F127DE4EA963E2263
DCFE557EA837042CCC330766EA028CA0FD447F078A79B48B1A8430F7C7563E30
6B853097B47852B119B428F14D2F881EA0D64F3BF02C625B92D884416C53CB94
E488CF084979890AB29EEAE0A954A77A254CC31833BCEF1C875122BB3360316F
9612A29FE93C9E784860E5049231620237CAE20EC767F184CB10DF209525EE41
0DD0FCFDAC68E3977C4C730F2A37988D9D03CA305BED5E3FA72E84077CE76799
4941E9A5D75A8FBBEDA2F3FDF20CF092A7064D3233150E265FBDF3BC254C83F4
DCA56A210069B8FB7C41FA5ED0E97D14487C05FF5462F53B8B701389AF2E6E37
2DDBEE44AA952CA42668A93FC84298A55C5315BAA8ED68322B16C6B986109CE3
81BE6E0F8551E0D21607F0082339FA96FA33678BB8CF50911D06B86C9256C311
519B3F4AAD5AC4DE679C5AACA4F9EEB15E1397792FED212A9B5E86CB221DBB7D
F956A4BE1571615EE886BCF53DE5C0151E354118C14F4D152725A5ACCD0185EE
B42B87A7B6BF4FEBD03132F9075C271F205407839F733C32D7A24C782DDC0930
59E1F19DC7286BDE84468B0A81C0DD92E3E329CFC4E2B36E704F5A2E99A7CBCE
619E25D48F88F1605CEB7402F291711607AA51CE0B606B10C1FFE63DCCBECA12
B839EC2CBFFF7FC9AC13F612CEE0895DAE24F8B63DB23A8D041AF820430E7DBD
90AE63F315756957B10F325D4EB35F1D0714A30E063355596A6CF7060DD19EF6
6DA5E780DCCA30F180F8DFB0CEC463B740CBA274592C953BD5A9CBC996C9AE76
5B71717C60C4F18F9E167389023CEBD2F0E3EB90F50FD11EAB33AC00E6B615F6
F492F8D3AA12B7E2928E87443D6FE0697589D375DB8DDAE50695FD089F6A8914
9BC0AB88D400A118FD9DF6679D980EAAC6131940026E3C2297E197FB8F125E8A
6A1FCEF61CD2A5097CCF506C626B18E1CC6E4CF7CE94A7EEF8762859353E43AF
38D0D4E667A80166DCE11DA849E99BE97280ED370D6909828DE61CA45D557DA7
7A65152F19C026C89FE4A47F9DE9DA86D75A9D8F3F2D71CD8B62AE6FE12DD1DC
46B921D8BAF03715FC56E9BCB7A041849901838D0A12D47F8BCF5CC5768C0AB3
3A10F8273B83C2DBFBB4EF256B7156955121EFD5D365D36CD0C12D6542D9EBA6
F112F55563444FC3D79F4B3A2DE76FFB0F2F0056228FE28DB2DF160599E3A945
22133D8D22A09F7880F8A51B77F4804B3E1CE5A9DB30AE2068C84EEB36853B0C
68D2C7608E594F9BEF7C5B7D407536CE997A9F85A66612CF61FBCCA5D73C7E31
E979FE162AE7904B4F931C20D002682757152A2BE256F305BAA5844F29A78060
45871AF6D7D534C89BE5845CDDDA0862D116C3E50F25F6AF33E8E354F8922402
CA313F30CE2B5C0D3E1798A1A62A0A6F8E820ECB5FE4ACA6A493180E0EE2BAA3
F13B59EEB1F57DFD4ABFD20D4BC6325B8C959BEAFBAA092CE32C60102BE03781
96A107DAD0FB7702D8563BE8D49099B46F4A9032FCFC5AF1CF8742A92AB81DFB
6266DDA4031A8E608B103688D2E860B9BDBCD50DEED50CCE1F67BC159176BB6F
1EB52D699348651F043D4A1AAB5F2F87A57D5BFA308354D2D9D706A9F8DAB063
527D8E974247A8299D8F4BF422EFC489C6A256FC5FB2E6BE409488EB3E098A4A
EAF3CE1FC15922E4C382719288A1F2887A3F1E71E49A160E7007DE13A58C5F12
F17BF083290CC4867949264F207EDCEB6F5EC0C552439FC2EEFE0C3A2FA88294
4E6E8DB113CE928969F6BE3E3B8BF2363B61C1E7227A2B57BC18102D4483E6E2
3CAB9F3FEDB7F6F85F7F266D95AD1FC0452CA116399E3814C8F1813D7168F76D
420E78726B258206004BA387FAA8212475A8936685E0AAD3A215685A828CC8BB
2BC61D42A9ED984B23B6B29C6FB2B8487C2466496CD53654AEBEBDB8C4C3A06C
715F56B2AD5157F99404607C40AD8B4B3C3CCA3B6DC4052D3D96A3CE36F0B700
EB6704E48BD3E0A0E2440AA422D3C9B3F98541C5E6704C90D2DEB61A59B82AC2
02DD67593CC09B3350E40689A5BA6F5AABF3E7053A607ED723D145E93B12A799
B9D0210E411564EF88E75FB10989D6115BF34E660434E53077206B06696878E0
8B9B431D5A66BD297F621C92AA4FF0DBA776F5D2EDEE67DECD48D820E73DDBF7
A967735EFEEA89C68E3509FF9C728ABC3CA66DA2890FB3B6009E065B8E2B2C8E
7CE69BB1C19239790F6B0B3DD6FACF052D2E1C0EB34672AA7DA9EACB8C621EAD
3929CA3359322E25A5E9FF521C76D1161B35DC1F3DA652834955472F18F48049
1EB93BA36677DC12E47FC03B333A7F09E8D2547F6D8D16CA42529884AA712979
396A4CA810A650915DCE8EE5BA9CE7675F95102C9C04AE30EB43430F3898F09F
CAC9F334426B3BB3BC9B1428BDF66FFC0D419508D28368D77C3D743970540D2D
FA3C80BB7D7E09A12CFDCAE0432930CFC34EF4F163924B43BF6CE43C9140AA5F
8FE895E4093068661A68F741E11B0E4BBCDF33D30383BCD329DBE1B0C05ACA09
A68FCD560B3DF5EE5FFD826E4297FB433EF36C4D4B4065D2AE5F9560C3190AC3
88C4D02E161B1383535A46DCEFB473F04A08E9A86C68EC648A214D6F84B5DA77
87192271A15130E0812C23E0851E4D2218F93467C9046615DD1433ACD2308168
F1841D0C155198B329FB463D8E602E7BDAFA02FDA142C52EDB1CEFC22E44808A
443683C071262B58167617019BED0DD554AD31AB998F5821BF8419DA37184E62
0C8C9F2834C6AC70503BFBF3F5EDD55AAEE853016CBC6216396DB2FA2311A06B
A71B710CD836079F5D3F069B788350621242D8B1E236626AAEBB93945B79E668
142F32A60818E661E1454510BD9D6B538A2D6729F308EF10EDC419BF3A54256E
363F1E05B58EBCBCDEF8F92AFC1924FF85BF0BD5547FBF0ACD890470A9AC5C4C
1360B02B1915CF48CD487607D1822E244D50E2009F58F3876009CC5D804B1539
16371ADF8603125004D0C4D76669DBD8FA9A0CFC2D221EE4C0BAF1C49F2B4C97
855C4AF4C0E9655171298F07DF376DE565D11502692B32233A518B48040D40CB
F94EA8E15DF7F0D97F71A4F4A5F9F4354B5BF2FAED4B00F36F2CE5F46491EE86
573CCC6EDF9639E4256570975B25C6C1F06CFDB2FD903406965F146BAF053E97
74866BEC3E3CC34E053C9A36ABD1DF474C6A051E35ECA99C22F4BBFA0E2B0BAC
8739A434D12274BC7E475C56DABAD14F32804F0747A3C6E730E025D48CCF3F58
64E1E2B38C83022B58077DB66E40182E035B080F1427BA4D250DD2F37F1F6FC8
6C27FAB6341E6193DFA98800C31CEA9AF82AE2AA5CA952A079E1E7FFFEEB23AF
2E20702F9888B531CABC31F73E1809D293E750E5311B3C8D1E40676125C5C463
F511124CA3AB6700E6DDD452C60EC1278EA80C5FABBA6B9E98418A0D64DE523D
2A6D64D19957837EFA1C39730568765E65BE305F7BD75F43C6AAB7520FD896CE
AA4303C754CDB848EFE094551015629711BE7B3BC62F7F0C2F956BA1A8B0EEFE
209AB8431BBBAA5E86057757808322DF216865D48A37338B689AF6978D929610
EB3B5B3F86179CB516D72D60E4119E2EE6FE9C5D91EBD571DBDEF885B59E0183
80F60554A50A66A7F0E606D1ED7577FF45529994A69620AAF3D869729A22714A
5F0E7DB43CE31215A0DEACBB968119BB8C5AFA6648411B5DEB230DEEF8E09DBE
901FF07BBD26B3297B75E73D446B752513918E6AFF3A56AE897E4A08910F452C
7FD271C1B9BACA52194DCABDB4284E9926694F6B2056997F2D35C37EF36DEC95
AF26E9BB0A3268D8053907081825CFBBBDD51B9F39B587A1B492786C5BB4226E
A3FAE0B1493FF24DF6998B19C2373607493EDE6BD9E9151B4B704964E5695E4E
519B8F99CE696523CA0CBCC50DBBB4EC8284631410D4156C420D073AEBCCF37F
02A3ACA687FBB3F42A7704BBD690823BB001813B407DDC79FA28FB845E4ACFCD
0160136BEE30A0B65C649D50AA82A4653649B7CDCA11A1FF27AFA7FF189A7DD7
EE7D89A99594E1DAA5D7C29EB2D84E38E27654D2EE0880E3730FA073A68EA7B6
BEB3D8CF73C66752FAA10DFDC5F5E0141EC96BDBB7F712CE93ACE28EE2BFE7B0
5DF7A01BAB43F14CED19142764D33FD6BD4601F84AACA24EA8DBDE4FF2094B44
4A1AF803E9EA9F974327FE718F7BC939A05EFD065090894BC8200DEF93B057C7
F66A818C04DA9BEAA7E70B4C0C5CB3807EFABFDCF9F836D144130971CD71DEAE
81B54335F2AC0799F32A0BAFC0A4A0232A71C7313D8B9CB50AE03AEE952DBF1A
FC9DDFC00853D9A2FFA247A7399B354B0EDEB8272D75E4EE205D1975F8D47A17
98199D542502CF3455678E261DD2E5776CFDD336DF8A6A8120413945FD120302
CEFC029100F93F1BACC89ED4BAC0C5A0DDEF52F121996E2483E9C4F229D01C41
C15D5756CC52CA9EDD64727BD3BE976D4963BC8855E5311B3C8D1E40676125C5
C463F511124CA3AB67043BA48C5147CD646223EF5DE660A82E05BA98AF862C17
1DA971CDE9629C0B16424CF3609285DAEB0115E4AE580162F18FF86AF9B2A5B3
E2A8E7AD8930C9777AD0ACFE3C6AEFB764BFC86DFE3CE4A2AD2F1014CD74242A
B1D2213111B6B5FA34108CE6151D158AA7D6F4DBE64EF22552F35A5681980B77
285AF53F0C37CE00142A96928058BECEC64F1C0C61A3CA481CE5D74B8D57712E
5A885C51110B04D58B74C3A4A0927388A736F8DE5374A7A85761913247E7CBDC
CD90E10600663B161A15DB54D1C7DFFA00DC03B613D3BCB3784407905226AC4A
A63AFB2153271A619BC67D712BF7CEC27CE0B7ED8D31A29D7F2D8B1FDE3D9328
96D5D3D5EC77EE31A5F93D7942A15FD76D42433533A897C24862EF358A371966
561054F7CFB599116AEEA931F9FDD3391E0E2353DC2EA171E90DE5650A0B05A3
65378685B85A9826CBA11C00F4BCC269C84755AA3848739C83BEDAB386C9B13F
C9996591ECBE650E4B886C45882289CF2A52934FB7764F3556EAEBBA2823E50E
918719D173F4FBA16DEE1DF371A889E06E4F7ADDADA74FC3FA9956F75531F041
61B2C21F34CBE80DE6414361901F3DC2668C37105B253DDAEBC5CE6923ADB723
91186BE89E1ECAB22C58A1678EA936F6804E78DAEAFCF1C10BB0CBABE5BF2E6C
34ACDCDED7FFF4837E72EE7A995E1C02AF3247216D8F96EBD8D1EC18D48FEB29
E968BA8324CB40D1DAFA83D894B657908A112B91C0E426E316B0962DDEE91AF1
8427CA61F1FD7081F840EF22585406A4E15FB18F6C6A2C175D46C65DE3742773
7C529217CEAC76483D668221C3D21B072AA0B8373C97DDBFD7445ECA574E695F
084C94FC6DAAFF2A9D3F119E9C9E53EEECE53B2E1E5D976C33A4C1B9D5384F70
ABC8F9F74EC962F3221FE6604E9706868E3BF3E6247DEC4D4ED775D6A63D4310
17A9B4017D9A660E62AEC1DAB9EAB216693979A1ECE4F39F192B2A2CD3C1D603
EE3527EF55A97594DCA76C102390DF6D9D25468C1E44FA0E0EADDC2F49417F1D
CB2A88AFEBF38541AD1BB12E1C38C34B695E681E5425F1DC528F6A3183BF1695
FFCA78165621EC8AB1545057B8B80E04623D0517232107B05D32C2DE49274D4F
87B7B77FFEBA7F649AF87AA556523AA6991F6EE897A83F5FBDCE77697C7F5246
65CD2AB7CCB157D88E49686B62D5B59A806FB807693E837663D92A3DF30AF50B
62E4E7F52FAD916E268A701EE5404CF3ADD7D79A33AFD79FA67F4C37D2663522
0FB98495B2E4CD4729AAF9B80ECC6C9548E773C04CEA127335272EE8EDF83B37
DEB70C29F9F799B710BC75E0106F5F94BDCD5EC3826DA19468F81D49B58699EE
E0CAF3C1BDD39D1C1AD55DAEBC24CFF24B73AC507680ACA37850B30D1BBCDD12
8AC48359893723B5174171A9CE391BF6D85443E394086F1DE6749FF3C63BF434
85903C00361D3E72B126ED17CC167AF714716915D5F82F3B9D3F19A097847947
53076928F9867BDE88969AD8C3C443D24E1D49BEAEE01747C25241C75A3E4E60
231203840F037B4146F2BAB25A95E1B0429A0F9DCA3124F20B8B48A09E2463A3
88E3D7498A032F336C94C4D3EEB224A3CB3F59C1311A1A7B1350FE59D7CB6F5F
ACAB7DC0FE53F7656E408CDD8A3C8215D594C6B911EBC9EC787C2924D1424C44
4B9D6FDCD0195626B9FF52B0C6D520B2E52302597BFF0F12D7DF5CE219716715
073175A6832731D40F4BBBA3557362AD0A39F29E7E10E5CB785A177F6EFE88FF
AA20E0DCAA36935CAB6B0B33BF6749454448F36CF72B5D3FD84E73F22023C63F
EF39B8BA4E1BE7CF15B83C7F0DD201D74FDF7F448889F2CC1668F4801AF118F2
1548D17AC5E87463E58BC4780AF14EBBF5C9A3DEBA24AD6767E2C75279BCFBAC
46D8224E8952D9A2129ADD20EA5D10BD495D1151F4BB20BEFF60640B14C10DDF
06EA99B3174459E7BF82AD59FD366E775F2BD8C5087ABF905A86E2C6C10C1694
F3526F0BBE8E4F5D2E3E50A44F9AFBB3A238B7DA900CDF822A47616498009EAD
A285A80C440A6FDC9D19E8E4F78CD805598AD98982F30654D4CC6391D45B0A6C
D0716CA475D96F399FCB8C9A6F621F2D21847A702489B28CF62768651196F757
C4190F854C9877E9E4121D68FB545124ABDD73C8F7319372A033B10F327FA3BE
68C541EE8DA5E0A6923FF60DE8BAD75EF13EF95252B3DACC2D14B70D0AE365DD
E57670F0CB5FD9AB0F7B3A0929E777C5ED85D8B6502C2D4180C1C5F15E0F0B55
B5AF9FFC5ADD3D2B5BA7E164B1EFEBA8338B6F0A756CA29721D6784A86F3E686
70240CACC8DF1040ED981AECE8D13DC653D59255F868EF158EDD727D8FEE3A43
73691772A120BEE77098BB898BAD2174919A5C0F6C696A120E2380F15F664122
CD4E69A92200F83B2FD8472C2387DB5D251F74A635E519763C2B61D2B0220454
B95BE28FC0E42FECBAABAC04219E6DDD321D530054F71E9C4A05055899D6ABC5
4BB7B8EEF7DBE525F9B7AF96610253A72E63479DBFE0FB8041A873898332B98C
BB697C0FF60AF2EC1488ECF4468C5BD8FFB970A1896646B8075BBD6B7FA756F0
9A7604BB684B29637429617D4D31C24CF968810067A43B3DCA0C54978C821D33
E2387721A0554EA68CD2276F23985B0041C332096ED8139B220501E20153395D
1F42AC25F006DF4A90311E65E76B8E8C995DCC595125912F12542EFDA8975940
9514691BCCBE799C9F485827AB10332BFA0505B5EFA4F5C59CE894F491974C0F
F0D79CC68FB1A5DE7EF8497F2B33F713338DD48AD94D0DEF00E25E76AEC5B22F
D073701F4AC81ED20EB82747C47F18DC85145900305F3881436FF5D5B24B2300
5C03657FA91B02D5E8D679C227DA8E320509D12E41FA74008E7919F1710B910C
1606DDE3119DC7F32900893A100BEC19E13A6511D4EA600B1ADC4C3748D7D80A
6CB9C78D821B3F22045E7CDE9AB12D3014B692A1E516B0350CE3B1F6940FD726
32318CB05F5C32363C2E6CF8AF8CFA76772D207D8683066FD5D51EDEB3149604
BDC225ECCEA316CDE8A62D377AF3CE7952B654A51A1686B5CCCCD5FD1F4EFDE4
4CD22214DD1C4B36E9D2644BC0C54B53DDFDCD26CC37435060F4600606D37D3D
9AD4CBA3775A2941761F9BEFC4C4F3F399B9DE9AC0FC29C0D363FEB468FC7AA2
DDBE2E708D27D89164B12BD8BCC7FFC85F27BEDECACFC93D5466237119A44710
846BAF25856CAE90E571085583C56EFE30820F843FDE8245A1B955C697B458AE
5A84C84EE56FF375413CBCE47BD576E1BD564F32B5518815E29AA555C50F42EB
FE44053CDD210D0B56FE83C743AF9E874B4582F941CE4829F25F586F7F1F40FB
A36FC0BA0AD11FCEA627E5B5F803550EC981A723C049F756555B3B0FD80F6C1F
37AFCD9810D2999AA6F1AC3878603C87FBE4DAE8D75745506A5B1F7CAD17B19B
6586B7AD65710937AD6D43FFB1EEEF6EDC9D926940BD74CA853EDF0DD3C87A44
CCC45375708CC2549B083ED5427FEA176A8B925FCD7A66D90755DDF6CB50EEDF
1CC0FCBBD0A771CC227AB58DAA4521A449EC5149F221AF294B72DD3F9088F53F
F0B590C5B4BE351B09AF0B8F226E7BA8FF9DF51BAE7EAF3FD1BDDE2783FC05B6
40F70A32A30B9A343D6EC5BA4E7AEDAF6C31325150BDA10798C467F67B928FA6
C536E666A9C5BD07664ABF977267A90FDE8E53EA4CD365F7945B828EB485C618
9376D142C467FCF8CE5B7C05591C5E23D9EFD74D3BB0719E5495CFF6B2E8841A
70AD5ABD1FE1B381341F1392B855A07DB9D0159CBF880C03EBA2E892DAD588C2
92CF217EE9248272DFD4225A15B5870B918516F99A0723CF7C9D9CECC3AE6658
4109AC50DCA648CCDAD46CB7EA3187974CF5905AC2F010C63B766545136BF679
1F0540B0624E1EAA8ED82D05A1F36B1F1C307C517AE6365C7860AC6DCF688028
88CDB04D2BFB067D0AB62D6393C782220F303176908E48792F8E04179616FA98
F8DC65055DF24B166E783F8328C17935ADF70E6BAD54F155F476F58EBF32903B
19094A69B81E87A1F0A23B661548DF097BC81D60DCBFC55FABB49C27CEE4489E
FA38FEE401AA76440DA787182D21DC73104C9F42912AC46337007EBF8D9D309E
13E8324597F729B6B9A8CC3717AC41435A8564854AF88B698F5930846C43681B
66DE1DAB4B9076805038F8ABE126E73C60DFFD357574EB649E7AA56D6F5B1D24
0169B575BE023A42F7B2ED96EB9BB4116C93FDB3F7A7ECF70092554CF5ECADFA
A1E365744DD03A08BEABCA7B5262158F772C2562C7C0D4D263DFB1971671F7BE
E4A9B638B55A35E405F79FB7DE1DCE97A42825F6D7DF53656BB78B5E02A8628F
317D6DA60FE975107F5721A9D8AED0EFA62E478D85FA73F3AB5E1B0030C6BE01
81A0B8125D0650BFF934A017D2860708FB80CFE206EA37E47EA1BFACF78189BF
25444E3592DE5B1F31BCBBE7B7970833698AEEA4C2FBC789A52A50B1B54E4DCF
607171F3F68908339C8B9D873F9395D05C65591FA9F1BCF3BE57FF89D779DF13
BAED5221B76089FBABCA990EF4E496EF7F5E1E97E3836623AE7C6043C2B49D34
9D662B13311943408577B3768643250CA66630344A3E26762818D59CDD878DEE
0DECF2136E09AF227B3571298692D941B7173296A4B0A91C20C4DBD82ED4588F
08BFDB8FCB655FAE79B45D992F99C0827CC9B44DF6281FDBE32AFC861092823D
32C4C66DCAD7C867ABBA97DEEAC3E6A8F4872C469AF291497AC7C00265E843CE
9FB023A4F07FDF34F7706BADF2C0751015539901EC76AF497AEB392AA20D4A45
E3F0E90EB3DC5975655A0D7DFA2C61ECD9C50367A5263E3EB2244B4F865934B0
84591B9001CC5E4ECC5DE037787C7958605BC34B0BF2D8A3097F0BA7206EED8A
A6DED3E29689E31DD28892BDBED34345F0306C282AB1D828CD49DB6EFFCC4A2A
68FF68DD7B0BEA989D98D4FAA8FA5F09446593CB0CF00CA3FCCC761D81237319
37FFF31AE7E25D9EE20924FCB6E714BD1090FF96D5BA492E89DD9E9B8A0411B9
DBC9C13D346DEF5E9A82E42ACD9A53CD02DB7DB0CCDCF64F0CC8A0820FAC6F13
4A19FC5A64636E32B6984F28228F7C0B6244EFB14F5FD6875680CB2BB7277F94
3CE4B9A0A1DCCCE6FEDF4F1E22C9D7B77E9C9F48583B13804A176CFB235D2FDF
08655A485EEEB73171A15CBE18606C5F081E476B372CC0E862621941B3A5CEB0
9FD89612C160B65A0FF48169FCA3F48D68871085ED023108E5CD37CAE2D34797
82B49F7834DDA42B1AA4E9F7128DB9A5A2A538E583A3B0C5747F40516D845A2E
D688F4AF5B93FE134201361789899A1D4A0FBCEA2A68358DD61648538EEFBA3A
D849DB1C8C436C748B82F681219D7871A89D01664D86B5A8FC90350E9662F12F
A36C9259B835B557D807E3E47AE0B53FB9B40D7882E0831BCD8EB738A1F72354
762E6551DBA754A5B6365CFEB938AD9B7F92404C891919B24577CBB0BB5AB7C1
E8AAEE0971BFE801A3F4208311A4E0F27B8245D6B860A7F3B22955E7A0E13FCE
52CC7467E64DC48FB224F1D39DA900362572A438C6406E0BFC3DAC264340F21D
760A99D96294CDDE1C7676F6F03EFE2FC3A4CC5FBD5F4229EF847A2DC438CB79
32E5B802528D6D195F7533D2D363108464852D662582EE574762ED2D84E1D203
D97F1BCDF8086A066B6963C2C2E5D1DEBFA341CDB02FBC4C7D4FD228D6FA697C
67982B1D03DD760B450656150A8E454D0DFC6B40D1ED587491B6F79C7C3B355C
607292BB40AF9A74556DD0E61BE271080D93AA918D22738F31D4F7248F0B4968
031B23319C185B9719ED40146AA05372EAE088E310BC5546D7A2E444DE353669
03741D58A63EFD491E64356B5AFA57B356CF730C4B57FBDC542AB4A9817DE58C
CB0E8D74D42B7918A5848C6492D3C7DDC4A584A1DC4725B4AA4078F56C17A79A
C44915D3A0BE3C9029C1F46A9061AD2DB3D2B8D3D297F5FB72A739F215737636
4B05F7E36F2F2879852E4C23151CC928D70BF480EFD3B50E51821AAE981D163E
7252334C70CE449B9285C20E55460650B1B772559D604755B170B6898A71AE85
B504EE10287231B58F4E8F4A2A6AAC0BA6CDA1D23E37B89C1BCA53E75910D599
A792AF70020D3F89BE8553CD0072F021F20E2272740E31FF5F4820B3BA262D9E
E0DEE500DBF8C33A6317C4423DEE901E2547E51E064769C11564AA9350025FDA
C664E28A183009103C7F9608FAED77B75D20D162FB9969955218BDD7808E9BC4
8DFAF0BE9D27AD697FEE675FF1D923FA2C72E19274A6F5DAAC6A9ADB14D5D69E
4A6DA8E8FD6AC0511653B564B8FDBEF0F2B46DB5032A829AE1FF6A261A58C85A
E1953446EB97186FB21E65617203DB12109F38630E9AC48EB2AAC52C2D1FC983
687154D4016CCB4BBC252F13A7D0963BB0E8D662FF309B991AB85CA5241179EE
1FDBFEE4E91A34A051299CD823899B25410724CC91FB6D1FC8F7BB07FA067B21
616E6F443EC24F6CA13BFADF584A1D5E65E9ADBBFCE827E84675550FDC90C71C
0DE9375833D970C404D4674338CD3B3C2959F860756793A873BC2583CFE72874
131D55A88837E4621FF6605D52C8E0394EE843004C5DCBB08C27417890DF842A
A1ED4763A9E9671D86824B0CC1AE585C7DB03DC3987CC268CFB4A81F3EFF4D99
B9758465789DC85F90086D5AD73F8AC7A2C8AC436763DB53C4FE300D96657AA6
8BAC542C44DC36F31D6E11A09237FE588D049D609D3DFB1B68FE333BA2F5470E
0D436108F0E814A9E57DBE277222210404B6240F148DFD3D639B25A7FBAD1213
9A660553F6A9428E2D8FEAFA68D4E93978E6E59810F2CF3FCAA7758E9EC9292A
9048F05C8CFC098B11D4F31A4CF4136CF75270E195BCFC4FC2DDD5A578EEC6DA
F58644CEECDCC12F72B2395C010A7319DCF0DCBBD8E788E7FA5F99716D44DBF0
EBFBC96B195F28AE08B0DE70FD477B246C5245F7EDC6882ECC0227C0B831D822
0A0D3246F56F5FF8D7CC38ABF44B15C2B3E43CC7C57037696C3D99360D346876
B9AF49069F08268D1D8A3F44D7B489A9F5ACD2F5D70522B26FF0520634A9D6A0
B5DE2E70DC54E91F6C5CDAFA71BC1F797BF73C152B4A543C4D2C6751B765EACD
CD40CE22E7AD3D7CE99A30DC706D653BD046D6F664326B851B0C7DD41C425626
28CD8882F0B53FB01F0881975A35E2C054BD3084774FD679A6BF0A62BD5CE043
94FCCBA3B7ACC3F40C64CD5BDFF4C05F27248263F5590B913BA6E8B5E1C5CF9B
4966A461335177C6E42D15B875DBE5F2A8C83E0B17025796303B98EA97AABA7E
78DF5950E4747A4F1746B9579D95EF0ABEAADFD429715B5CEC1F4173454EB024
516C1693D61D67939BA788AEA13283035CEBC0ECF06F27E753245883E7E2A0C7
AF01C5EFADCAB83088AF9FCF731A84A94457E9379FC0DE5B6EF0A1C62B3C3C9F
5A379912253EDE233B8F60827A1BA1840CFBE70B04553AA968BF9F8B92CE11D5
BF9775296567E119E5B852DBB3EFE577870E99EE4A1DF4A7B6219BE1F6B0701B
DFAB5A83B4D38F8CF6D90B64C23EEDB764F7FB269F693AD78FB23D06A3FD52E4
A12575D58730EA5C6635F52FAC5817129C4EB9D2892A956CEDFD0DF5D8CF151D
CE35C74BC65EFE1ADB5018E6FDD3C435B3378FDB4C735A6EEC0DFC80A0DDAE17
40DFA2568B2F040C9B29D9745B77D91FAF700D556186B04CC79A7A856248ADC7
A436F656E466559F5BE50AB8A6FD48192596F92F01A2D4837D5C619ACF19C60B
4B4358938713FAA9AD4DE1804D93B9D3CDB180D96BD6EBDB9F4715BABCD5B28F
5D72A7A62C4CC7121AC6D970A4CA7447B37E0FBA6BC76D2D7D50F01CFA42972E
51151CC7F530F03432644BDAC249A21072AE202E967CFE0E9D5C6169EF93DC00
0F981F8C631997
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSY10
%!PS-AdobeFont-1.0: CMSY10 003.002
%%Title: CMSY10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY10 known{/CMSY10 findfont dup/UniqueID known{dup
/UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY10 def
/FontBBox {-29 -960 1116 775 }readonly def
/UniqueID 5096651 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 15 /bullet put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A581BE543D73F1FED4
3D08C53693138003C01E1D216B185179E1856E2A05AA6C66AABB68B7E4409021
91AA9D8E4C5FBBDA55F1BB6BC679EABA06BE9795DB920A6343CE934B04D75DF2
E0C30B8FD2E475FE0D66D4AA65821864C7DD6AC9939A04094EEA832EAD33DB7A
11EE8D595FB0E543D0E80D31D584B97879B3C7B4A85CC6358A41342D70AD0B97
C14123421FE8A7D131FB0D03900B392FDA0ABAFC25E946D2251F150EC595E857
D17AE424DB76B431366086F377B2A0EEFD3909E3FA35E51886FC318989C1EF20
B6F5990F1D39C22127F0A47BC8461F3AFDF87D9BDA4B6C1D1CFD7513F1E3C3D3
93BEF764AA832316343F9FE869A720E4AA87AE76FA87A833BBC5892DE05B867F
10FA225E233BCFA9BB51F46A6DF22ADCEACC01C3CD1F54C9AEFA25E92EFAC00D
7E2BA427C25483BA42A199F4D2E43DFCE79A7156F7417ACF78E41FCA91E6C9EF
B933450D851B73A6AB6AEA7EE4C710CB5C14270D1674FA334686653793FCB31B
491E870D3C2BC654D2C1DE463EC9BA29D7371AA1078800EF93D3F66263A2EBBB
F5723697BF7448BD0D2E301544BECF497FD475B85DFEF52AF4F8F8BE445CABE6
019318806D10C5952157FF8F8286C1EE701545C8F60EFA854EAE66835A2046A6
915D395F1E0366EFE0C0391583FE001FF16D82A2E2DA5F57754A2C6F69306E36
356ECF8EFC3F1188AD6FCD2427E0580C97A5B69B4E0E09B85EEDE142F5ADD2F0
5DE51D6DB72B127412A0D57106C19CA493048A4F815129ABE767D51715B1515D
9C21067CB5BC88741B7298C83EAE36A866DFA87D8981F179B1C31292F56BBB64
3C430779468AAF07C8A8B4934E1E775FE3F35186BD1FA6EE3689C1C750678AF1
FBF9B23195A124C5C991FE670AC0C86FD39D2B07B9A319E74EFD498B45820252
720ECDF7294F7B0B137CEB86D33BFCEB8606985A3260FD669E461C8BE94216C5
D434FD8854F44EE66E5A289A9F9E32BC36AF645D53F96652602BAED418C8D726
BD04A1B4617551FE4DEF54083D414F7DCE004E6BB2DC9C2EF7CE232B254BA2C5
7DCBD36C2072ED46FF711F121A701E2284BF1B718B3164382B8F453D68FA0377
DFE106503B8401D4DB87F5402A3AC9A442FA060B0610A9524D530C7157C26B56
AC970FCC1D5655FFFFA39246E6420CF97D08ADFB7B05822679BD40C638DDF0E7
A97BFE8918B611A145AC965C203F1428812F9D340AF499B3A915B22BE798594E
0F520109FC81E452180AE45B170FF999C5FC2761C6CECD8742A5A6FC97F16743
AD4EFCC6572A6D3F3E4E330C5CB2FF6FEA48A5B64DD3DBE943BD9918D4A18E18
CBCF598AEFBB6AB3CD2CBC9BFD6099272F6543F3E532E0E21E614BD2880B1023
0AC234CB705827BF016DB84E00E8C255FDEFA0101A842929540B7B4AA8A089BD
5EFF05B72356B6BC3727817823B5CDBB1B963103000D7F2A4E2A1472FC3E614B
5CBCB6D6D784023173DEFEBFA8F9ED87EC1A0A9EE98CA59CFC964CF943DC683F
E9E00DA718C4425A705A69D99988EC6F152525C790912C2E46A2381A569424AB
54DF4798BC2D7E7A361E7991641D4B756CE2A7FF4A2848927092C59C2C4B8809
E13AB84FB6B111E680D7FB9F2FFC2C5C66B0B501E4447C2E46C10E2F6124476F
A140C404CFE2DC9E0199BF61E035CEB481D438139A9630934E541D261FFD2906
4CAD99E20655FA746AFB81EDBB5601F5FD6B1D6832A01D585E2C55053F6A7378
4DAACCAC7608DBDADAAE732D66B3E7F87E79756337C1A961E53A4651BE7C77F4
038B89C87F650C54A2A90EB7F1D525BB353F33318551EE8D84A6A83C718EA5A4
B2AC0F7306B1E095819B87015A90CA3ED739B09061782C28CDB36BA4BD5E5308
5CBB70414E4112193DAC4A1FA30996327230D1E021F3CD8115E12D239D93FFDC
B645910EB29E40D830E7BAF2DB255FD7C4E776557BB38157917D993EAC245837
A3B515147043574157B8342D829C7228CCEA843ABC89D1785A9672A5923FC4CD
2F3FF27E6FCACF84E2D3136CA2C0FD3EF1EE7354CD04C38B5FB874553646ED2D
CEDF7E362EADD04B18051F20A8FB0DE18E152385B9D05F98A3A7EF177824E246
455ABE69E2F700EB78185CCFC07E3B4C6FA301112528D977367D30D0D5D59EDE
FAEB706DDC970A9E296236C725B2B55B09B9C336B8E23CBA5FB8692D56F33B03
16294E5FC7FAA42E96395A57CE51CA8DDD77442F142E2E576B778373FB31C81C
16840BB422CA827E30A81829648BDF1CA36700EA32AD888D097C1FE0A05B2D9F
483AEE40269DF09AF0D1AD3DF80C45DDC59C2A03FBB661C79B87853737C6D352
67626B657321B16198DBD6DB98A092F17878AE4698121E1006E53D6F9B0A3BE2
3FB68828EF854A0CDBAA68B37ABCA6AD4A3D809AAF0BAB1697A81FE59C98C472
1E33CD70A75A22C249DD11D76C2575ED3370A25892A16D2FD569CDA70C130770
93F493C7D47D6F9A5424A7A542BAD726BFC3AB225DCEBBE6AC4BE006F8C7C0EA
051424B08305BF2D951AB2986AAFEA04E078CA79B399585BFF0F1ADCED02E15B
8765EB6BF6A8E4D0901EFF2C3AA104924EAD9637A35D877E0C51A3C37DA78CD4
8643C8CE6DCDDE3F116A6C2390F948E5371BEB5AD2E87B41C5F01FB5C196C436
6E256A88D082E3F46E4EFFBF605B2EFF1E9D9AD5EE4DDC323A137CD9451EDEE0
06F7D82898D71FAF2362C0FCF1F726F97F820305B7CE20728CA08C63575083A7
84BA28B7DE2B916432475510E274C12FFD1660A717F51DACFDF0A102D85224E0
D6DB607BB72569ABB8A7BC6A10354CBBC01732EFE35B72062DF269CB25EA3DE6
DC603B04C90C5912D2C38D7A5ACDCDD3F6F116D884F0D8C528F69D5D47BA20DB
0A9E585C7D8CC3C324FE8A1DF150279F7E8FB43BDB720E624E5E9918032C02CD
8020636AE5C38DA2484B7F4B34163E0D0A561B43B80E97746DC05C871AB620EC
C5D47101ECED4A7E25F291184BEF8B80024AA7BB456C1B83A907652B331DEA34
754226C39C6889EBEEFDAD081E01EF8FE47751987667836FDE4C8BB8A3FD4406
1E643B4EA37BD370734D1A2DB17C2F4B74B4ED75098B433601F75A88C9A37A05
CCB157EF6E32023BFA33973F3E655A4D58289136996FCFA61EEABD70791B6523
1FF5DE71AB8A17038923118A5EED8D59C4C58D246FFA9BB26472346B40C8741F
153D19CAFF20DD2A86C6DB89154A630FB1761929FC3F0448EE2F089C1C953E02
905BA8DE75D101A982A611056C4B237596C10951DD98BAB838B742D3CF7DE718
617DB72E5268583223E37E029D1C8FD3F1D21690151F76B76C52C725CA135CA2
8666553E863CE188BFC9B99AF56AC2DB5BFEBEB12FB563D00244EB89E478657A
98AF2E1223C1ABC25A4500E8119B86EB3C26B8A2F3505A3E5610F89B7C34E278
53FA0A54A7F46D84A35EFEC36AE660A9E3C37EE3864106702DE5AF6C45ABF64B
888A4A51323138CE77DB935576FE6B4824B6942DF80625098CE1B5B32B234F1D
052A9D6039697118A9D793793775D8729D8574A2E74D7109C7B7E23BC5E2E87A
CA8E019203952A4892544E1AD3D4EDD22971611358AB230E9A2ABDF00A288501
A01B67C42B33F6B78C39562DB50F4663B922D9BE0D8A150311AE44B83C1F129F
07337323E9A23211EE58E16043E127C6F9574019179F5635648A011266677B56
B5D0201A4E1470B952A1579B57AB2329CD4C615395023C653F784D36B5EE3672
10D191F29EA508CE84763CA4CE7C2C5229E38E241255A5CABCD6C7CBAED901A2
CA53B5E24111921CDDF83578D33D463D70EDACA0E470D8F592303FB6BFD68B4D
3F3BE2D7C5EC8BBF10C90111A33E205F2649B56E8443F6FAA6C721C66575AE12
D4C40F1F46CF9E9DA675AB5D5840D938780CD9E4AD6736ECBEB6A4397613586F
849B51048AC5F9405E03E14540A5E5582F61CDCDB57EDDF95A8C6705F433EE16
648F098C03DED8A2AD94AE3DE202D629B9422ABB031318D48F2C85F9DBFA17BE
84708AA3B6C9F81F4508F7A5CB7B6646AB8722ECF817877B77D473F577556DAA
2BA0ABACFCF5DEA7498C47328E873019A956FBB250FD9D8885D21D368FA70CBD
2709D2DA44EE7A9869963EAB48789541906DE49FAE785ECE1F18A22C7E7ED204
9768896B78E9EB7A2BD6EEC1B26083940656ECD689D92942CC8AF05CBF82AED0
B45A7DF4DD7AA6526FB597322560B9ED3087A65B5EEF1371C328A021411BFE3B
D9B5088B2F1AAE381FFED52D2D1E02CD0DA78683E3B06171CBE94BE9760005D7
135893D7CC2DB097F6AC664D9594CF1C650F84DA80D2EDE04802DBA33CE3DAFE
EB7A37E8AEFA4FDA6252FF21E8673DD98E67124D5DBC7BACF361E57077B71939
C1D1FB923E4E35C075CD1BCBE0E80DAEA1320D55B43EAB45D9B26C366B278782
7519FDC482D98839BF0DF2E7C3A56A1C1A3FC0E57A75CA414F6536C1FE8EB7A0
4ADFEE3BEDA0F53BE8CF5F64230784A797133E8CD46BCCB3BF38BCE38A73CCE2
9E073ADE792F7128231DDD1F63E6156ADB2609C200837C2E8A2D93D2A7BC9171
050C709A71E44E32B1B03C92EB5CF1D3BAB1C38E027DC4ED9AED633D98CD7486
3F773ACF8AE332631CF2ABE6D606607593FE862ADE31803964E3F4DC3CE3A271
C76BDD95C87CDB3B87BC26FC7A16D567EEC62E6FF0D471B4853DB8A94D4CACF8
843824F818083F10E88D52FC4253E8203292CB40F1414AE7E51DD7347007C342
CD70E8E9F2D2A13D71213B841DDEAAB208AD9EA644591C15DEB084165F9DF24B
B91D3BBEEC2E34E38EF16A0C3F00700A7BDCBBFED2EC0D09601AD6538288DB50
3478B051B5E16B604A0341FE621A58718D960D699D3FAD284310DCF54EB13175
19A75A539EE98E804AEA24689D3540F0F12951A3C01FACCE9A7BAF4D0DAFA946
FF65A4D2A4C39969607272C6886F44E90ABE27CA3A1F12A29D9B32E60E8E34F0
17C5FE43D0E69A99A922D98909B2BBCD145E59A5E7F5426B3988F73B09A525F6
8BD4915663C1301323180E760BE81CB874B020FDA3AE63340E4261E4F3E4949B
CC0966BDC4426190BE9F5D77F76A72AD925662E5FE1CEF9CCAB68F0BD33DA003
F11EB91AC4502FBD6AE48DA0F9D07C35B96B103E379B8A83A05FE728F1716194
1F650F75BEBADB2E3810388F3E2DC7B19F1BA9E32925F2FD9F19F4E8701F3E4E
4069125D7C401144740691E7A460021A47B1E27997FC1DDABEC5BD0EE0B20194
2D579C7D6727AA124083242BDA46D8E116E2751C5F298851A62B60AEBE82A929
9B9F2492BA35690D1EFD16215B8EF14E7A3803B93C28FA41D971B05B6AF3B593
E74AD1E68A5FCE12A86E63B78BFEA87D3949FD164F12277A4688BE96356791CB
8671C49365608F3EDECC109321AF92B4C29CAF073DA3A7D73E913D0D83FAC5EB
BD884D4C686056404DAAAD6F82F94F803FA1FB0DD8908D1DF08FB87A8BB83027
04DE0CBB1C6FEB6B517FBD7CF065120079E608CE41893C2BC96A347826CCDFD5
C69E161217F2127A59F1A6F22037641613F191F22D5B4CDCBCC2EE5615623404
ABA7BE6C5FE475481615B2AC1A2412E54688DD21E44CC9AF5F16E634AFCA389C
4D740B7B51BB141BFAD1080E7C726C1606A28ED492E6BDE9F800EFACD1513909
84E98CEB6A0B7A2A6F3E1D1DCC3B2552795E0932673E59ECC56DDD37A1D52BA6
C3F0E905978AB568941A163F4CE3AAB5C5B16F86016EC47BA6F3F7AAAA77C3B6
09C8C3ABDB6D514A76ECD37C37AA88B5860630B3406B494F7725975596F84777
D9CF48686EC9C5DBCC1D78513F591C7C10AB9D153B3D41426B7BF668B0D04503
56BCB686258462C1DC61095724B9F3312316262FD7C1AEC6E54DE7E5A7BD8EFF
035299B8FD8A4A7B0F51404F4A760F4D8B4C0FB7A32FA4B2383AB6E9C78FDEDB
FE6A5788D38A6701B123630C2A6D820A684166FBBC83DB17069494FBD411B333
CB37E2491C5BD035A33867A6D3A3D420CC31ACF43AA07182CAAE67E40EC63663
B678F71D4C6E0EC3A0AAF904CD3AA66E0DE5E3CDE049E94249B39A1C06E3CE9A
F974B2484BB2CDA14282B9511E505B3C89F9C802218AE40D1A7541335C5736DD
CD565D4B9F4CC78F3A393737EDB4FBD0DA299E21CCFEBA5478EEF013F0552A8B
0BB11FF46CCDB784E8BDCF730A16363E66572049E42C695886EAB42A9AD9094C
B635DF4B5B9BD9B9AE8455DFA3EEFC77653190F9A8B1E93B7281C2A21EA7DDA9
33484745BDF7E3DD63C7AC66C286C9A5A698A5E4D7A91710B7FF943FB23609B6
4B442F83CB795788FAB5E9CF3F75D5487DA26170E4561C7941C910B088C3B86D
F844B0F340CF82786A3FCF347048463EBD2006281A816627065DDA6CD4D3AC5E
2024BC96C7D896381BBB567951E7A1F29D4E95351298B000D29E5F3D0448CB5A
CFDAE1BADE9403B90371C3A07D208948AFA022A69C519434B6813086ADF518D5
88E0B92072A44BA1B3EBB630A13B7AB90992E85B6D67361C8D96F3E0D826FF37
17B67E4B1EB7BADFD98D7F4FD17BECE740ADF13C141EBF0A91CB105DABB32FE0
55086D56A0D358841D15FD349E6B95512E4EDF4C430216FF85C2ABE995E4B40A
A6044CC8820AD885C07E052B3F91C2E9A1D163BFFD210F7BE95B923E2500DB50
2075106DB541C267BD450B25B670CE80BCD068D4DBFF2D82634175B61FBD3BC3
406131F44C7D6F18D375D1F2270829DDF29DC14DBB58A30AC193245D18DE91F8
AB88AB548D8138605BB5A50073295534E314366E26665AE70482B890E4101D6B
60E4F3B37ABCA1346DAAE8FDB8DD9C832EFF3E73BA470E2BACE7B8515CB43388
C27AF99FF9322175CF8D4947E6B3846AFF5163E972156847F58A66660EC8A3A6
5FB47C9F637B4CBB4C73B6A080B0CF6FD1E9665E92032540570FFCC747C67C50
822811AADC404BC7ECD1673E8AA6C3A2F1D82F39430B58C29145E2F1B679C46E
94EDC711883F1E4EA84117A54757E8895A40401A26E1437B39A2F65CAADD6E02
D71FA8AF7453668DC613F326A3344F74AD7AC67569AF399385500ABDA5EDD3BA
343CC5EDD4B558467626850E752B9959FEF1454E53E7A3DCBC2255AD8F6AB4FE
894455118A61C58840CB68A925ACCAD75CEACE863D806916228F0614191A1CD5
DC9BAE256018615AA3725834519449B0A88B4F396654E74099C007930ADB1327
DD119BF799FE3B0B223E1EDA04FE2DA7A1C879143E1C33B6C6344F4BA033AD6F
8E88C33DEF1977796B454BAB2494C930F492A518E8198C708A75FFEF8C49C324
A718AB59B889DED521229E741FFE53F98EBE88B0405AD523254FD3FA4BBE96DA
DA1C27C1C979A0DD4E61C3B1F4C4DE01E42F1C4435EECFC02D97994BC8AF5270
E7CB1458D76ED0229C5FFB4A23B8716018F9050970895D51722CDE8F2EA3D947
DFF374D84915D5C5D16463A6FFCD079D1ED416C4347BF831FF0C4ADFB61295DC
4D5785BB0852BF472CFC97EC174491CAF961AB90629F055E75DAA6D9898E8653
5BCF379816CAE46FEA62E7BE8E9B953466E51828172C4DBD0E1BBAD1CE28B5B1
02B3E36403BE80B49A47446A6677FCED438F01D60EB10F478C89528FA337D0D8
88D3FC123C076507ACDAF783A9A6E24ED73BF24B6E0F11C13E532DE5F70B15A0
657F5ED27D204449A841ED19E01432CFFE928E921321113780D036D34F2797DE
D4459CFD15BB117B5C9745EF3CD2B296D91FAD48C80B136D94476967E255F808
AD2B5D522ADEC64176833756510391815A1D4A8DA1D0AEE7CAD36A1D161889F2
3347D5B6BC503300FDDD48F594F391D5FB42C42113C538E707C16EE24A3F375E
7C506E8F49CE50FF9DEF3B4A4C1BEB3848EAA3477349833BA22D2A9012287D8B
A8C4CB4307A1188ACC0E6E9338E1559BE5FAFF381BD82A6C71C267409468B3C0
2C1A29F4281D565836EAE57F680490FEA4A952FF64C8CD11C377C294DCD1EC25
CEFB2B6DCE959D0208F85B6E32E9B44FD455F9B134A5306D95EA29F37BB8B86D
9E592159338E1293F449380E13C21AE42E692F6C00B521F7AB2F32545952358F
0D39246DE215D0A7EE67F377E81F9E65B25658B7FD97FAF98C7EA9161530404B
62B9AB7A91C863095D5433BB06F9A29488DA84D58A1394AD7878BB27E3CF4AF1
BC29DC64F319758518AB652F9E8BCA586D3D2021CA860F84DC0A2F61A93B6B44
F08A7F7C5F36FEE9F5D450D19F72C09580DDE2B3747D8A1054981BAEF31D6C42
040D7D5F37DE6DE019849E7C7754DD27E9511F9A9AFA4FB727695444F739448F
3D2021
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: DejaVuSerif
%!PS-AdobeFont-1.0: DejaVuSerif 2.33
%%Title: DejaVuSerif
%Version: 2.33
%%CreationDate: Tue Jul 26 17:07:32 2011
%%Creator: ,,,
%Copyright: Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
%Copyright: DejaVu changes are in public domain
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DejaVuSerif def
/FontBBox {-1576 -710 3439 2272 }readonly def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (2.33) readonly def
/Notice (Copyright \050c\051 2003 by Bitstream, Inc. All Rights Reserved.\012DejaVu changes are in public domain\012) readonly def
% Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
% DejaVu changes are in public domain
/FullName (DejaVu Serif) readonly def
/FamilyName (DejaVu Serif) readonly def
/Weight (Book) readonly def
/FSType 0 def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -85 def
/UnderlineThickness 90 def
/ascent 1556 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE373DCBE8503A9C1BDDCDE3976B9A
FF31FADC784CD99E8D913C26819A4962BC428320D924CB0D4BE15E2EA33CD98F
3A3090D3A2B1C56F2D8E679576FAF3FC1A79261690287D7B9444B1B4E36B6E78
13E34916336239067A606618EB045356D480135F7C325841F7B5598118DE9F10
DC40B14F98881CE9249D25473504F621ACEEFEEC415938B11B1EA0DB33CD14DD
BF0F9224FBD2D8BDC80385967061093CBA04EF9F2CC7611612A7B40A88C5F557
0EA7B75CAEE65197D76E2EAFF968FAFF7C1105A090B0608803BE84E398A71073
17422E75FFAC10C7B78D88AE4656E8670F0CFE203076E26559330DB36E3DA818
0A35DF5545775638CA918D7B724A11C790C00416AB08EE446A6726C97D3397B0
0314EBC91B4BC45217722F1100A3B5EBB57C058C16BF371859A9BA53CBAA8070
38B0A8751C786BAB5043C284D16223CDC59398518D50ABF8F3285652A955C253
9EA5F707EBCCED2A37868AB64C6DCF6546DF5654A7B54F720D9B626D88F2993B
DD32706AC49259CFBC2FF04BDCC56EEA526E0250565FD845B7D4D9DF3EF185CA
AE724EBF1165BFEA7D20DC8F30D93CB8B4BDEEA3F37D794B6F6219DB4A85D9FB
331D84CF11D7FE9A46DDE1E08DDD898CE5599C6775CE143CDCDF73E2CD7FB751
BB4EAA22B3436A8AEE73B93CE71A7D64F9875B90B84A0378482C9093DED58B05
C7FC1631E35F7232D1D25D8FBF8954E5B33866BA86201A7951ACA6FBC88A1E74
4C3366072E854BF5305F61AC3C4375742D1316DFD48181563BE1E496980FA645
76EFD0EE2BAAC777BC8C22A340435D518C58463A49E183740ABE3227853E7FC7
0FF9AF7E0C63759864AA2E1BDC9142AA9CD24BBA3364285DA21FF67D3E0D37C4
2371062F5BF8F9EAEE120490D6AD034DEEB108A6B381109035EA4DDDCFB2A005
553868AC67E1E940AB513E1E41FF5F497F52AFA059C626D779AE4ABCC120900B
AAEC4EBEF3BA611650539FBAFAFF5443EBFCCEFB2147917E6A9F644B0BDFDF21
97162103433B454905ACECA48EEDBF777AC02AC4BEF34869642C9AD6127ECD52
12AB846D1450EAA29C556BB121C9C4AC3C940F1EB91146E0A7F170C2333880BC
6D7845E32595B2F9E2050D2B8D3D75F2AD74231D87A3C5991A3F5D1C8456C9A9
5A35F30C2F37FE3916C7DC06B77C08DE7E6FCF51FF4D26EFBDCA16B5626CE6C6
F7EEED4FBF4631E830A06D7A8D86790A680C47C2D1DD26BBBF1E3CD527980F6C
4739C00C2EC20CE1F46C903788C0226806023D73A86D4B8F95B72450041AADC1
919AB52F2165758281D989454CF561A84C97860B8D2A85B146F5805A7CE00D16
3E3C34545135279298C54FD39A960E69814BF4066F589316BA47F8F8F30C27FD
032A2AA9965B0597FCD470D69B9CB4E0E6F914D5BBAA4A98268E1B4DB4900ED7
FB585D63C3DF849ED5FC9B054EA6AB0149E04B8C4302D4A56D8A347EB5D3D2A0
E12CF7E35C8772C5B1A6B545E61F3171CED2010C988BD5437BC3C9B4D5254B36
8E4DD7213D2FCE31DECB963AE3D31F9B35A4A6ADE35ED5283961517E1E2E6E31
7BD9FDB42DBDCE82C93C71126926B9F8E9653E25F47EE74F4049290AAE529429
CA03557A9B8306D976E5EE6F7270FED4449563D2B97615D16887455E43D2FF67
752CD12DAAE57248F81B9FD153B122DB2F44289E5B8296A1093827BD3E127C20
31A3197B4C1A3759A381AE2CEE579A8DDBAE510AD6C9B3C7841540C8D2A499CD
1E377CD81BB642DF5F3B367E903158C2DFC11F715B047748856573801B26A718
980D36AF645F7E80DFB78EE950A877ADC1B84A0EEEFF7499D4A4959FA1BA70D3
DE122C74E2D07F135B33442DBEA6C0F74720F9A0B495847BA1F3896EFEB1048E
980F5A16B50B723A3018A5324994CDA85D9EDAC3DC42794B09481A7089CC45A2
C18A54AEB9CAF270DF2858636E571EBEA7BA976FCE899416BCEC92F4A7418CA8
0B35D3FAA66A46727CB1A0BC620E1B14489B73BF349741A5E15DF72BE6E28527
C05909C897B6B2E47F0576C92BD88F0DA00F757B2FF77463F8186365B317A5F5
6D23B74D9107E2A2D5C2C26E79D6B96DC6A65760E4501B14D3BEA359ACD21A40
8C8EE01EC592B1E306F1F60C17B04C13E3C20E089A6C6BC14BF893C29F61FD23
0BEEA63DD2B6CAD25A911B562367CF82E245712F148827033F3F1C0D11122E05
FE8BCCA62B12230255B5DC112BE3E6B0246E8E14850278761A368889725B0171
CAB9447B6774A330A75974BE76B05ACC3FCB47F4EDB70BC19AE14556EEA6D6A3
1AAAFC7466D2B9A4B2260AD20B602268DA0F0CC24BE660E5639866C9187A8803
98355FD303D10FB649B16AA3285456246A5A421CE1E955AA105D51471C5B7C47
2985E1E00DF456B3876946BC49E0A827E41BF56FC0CACB7842FF8F2DD10AE4A3
E1A7699603EFD017803E471242D6B97C538102B14A91222012637AF1D8DF9A0C
2937A3D7449E2659C0CF7CE35C322ACDA0B29EA3F63DB6F525E4813DA1C73AD0
398BD2FB74B4255299C8F0B0DCD7C6412EF9C5AF0A2193B8E0138EA71C81BA60
59BD057359ED3CD47A324CF587A4B3262405C9E753315B7B157B3DFE0FDA0F71
6F2F2927609219F27B108EEDE1127CCD90ED4FF3CE3E82F5B333E4833BD3A126
5221287185860BD79689DE66AB4144D73A3B10D7A3B85B60A60745696FFABB07
F44C52D830C5CE6089CAF571855A5086B98077A1E07CFE95B30BE896DCDFC069
0BB5B0D5945B3F7F124B923C1FAE68E5F5D9A868EB031F7DA4409F4AEAF38A53
5D931342ADA5ADD4EF1810E41C156EE20CC477571A18859AC3A74AF5B4B003EB
4396A0C3CAA4D0722AA10686F262B7DB8A7B1B948DBEEB188FC1D2A797122B9B
78C1F92F5CCBFCB72818B1E1EA494A80DA0121CEA84B511618E9D0552CC3784B
DB595B1F2C787A199EED810BA309AFF4B63059229C6E306C0756FBED2FF26246
33953D92285348D38BEF6048018106FF6776432F67F7002CD76005E64BB1CDC3
E641C66533433157C6C959600AE0F4280FF4D463AE1D9FEBAD065332B3168C04
6DA7AC6E66F4A9A08A98ADFAEE4711E4FD4268E70CBC5ECAB6F8601CE65E911F
57ECE585FA39D8FB6D93C81F3D76A76D288134981510B78B693DD292CD282FE9
CC3804E23ECF0BA98367C4A7DBDAD921F1434838F6D8E21D133D13A75ADA846D
0A6FA8A0C1230DF428AE05DACB2F34D7233D2B33A9BFADD6D0E03029FDFA95D7
0D991A20A5A862A7A728BD3A8C878491E7A0F1AD7105B1B506801D76818B60E0
B04DDB3EA71A2791D4F3FA5E7C0703FC2C93C5EB02DF2EEF2B6C8D74033C21FB
251F854DC13616E1A9E22445B6CCE04A1CD1C66E50757D480B56351386067E2F
8A211131C712BFA8528235F1A602CB799F8D564C18FE7483103E4E562E889010
F219C1F30B85B78F3F32CEAED568F0CCD395AAB91442ADEA8174064B3EFF00FB
3086E4DDD6B1E84342A2B831D48E2F2EAC65A47427A34CD7C577BFDA61214110
CC3FE5C892B5667CACE7D67677EFA1AD43755AD8904E7C063B3859EF3391F075
F1080F6EE2B9567FD4993ADA941FBAEE9A2A47EE9575E4E3DBDCBB617CE64466
DF58F9DFE73AFE850CC222FA0ECC9EE2613B339BD8F6E5C846DC5141E642FDBA
58B0E8AEEA84816E8C9CB947FDD259B1BDBBBEF73390FACCC79421C4C4A1B01E
FD02A87D5B2AB39A97E6ADB7DEBA6F71E8B9C7D44A7AE32D16398216F197695E
B338006CF423A8A1D0A5DC3C2F4B9BBD9F47D4A2E8D0FF7C231496DC0E7B18A9
E13B98E53AF023E7B552073DD8ACDEEFB3D9D98CE75658B632AAE7D5BE89FC88
7DAA7C4F66B334C15B98EAB0DC869523D3016D45C4650421070C80E288C095D8
BD20CCD0590904EDFB01DFEC8E166498AA88D85F018F88977566E90F777A07B7
AD566A66879DF69139B6BFD1D0F81E00B74A4510F9FD6A2A878B065E6F6972A6
C313F8AB65E7623166F516E7BCC1142485B1D7835060C4F1E8482AF90DAB2654
B101FCCE14EFAC729B2C55852B56B996BDCA0C4873159D3E14C519414E56AD37
F194566008ADD04E6F2B1FF9D34913771FA40103886020036D883325FB8ABE90
84AE51432BEF7CEF6A3BF6050234E293FC06B0A33EECC3EBFB023CE14335714B
E65683FF583E66A4DE2F139EBB8C03C5690130C97973AA4D40CBB60EDDAEEC1F
233D1645D12BB170645AF75534E6DCD097F61B9D2A3F37E0199EA6F2036B2E5A
C4ED2D34BC4A246581E688AC225AF2D19493BA76745E38444432BBAEF32B9BDC
7314F560168019A6F03BA39258C66B75A776640E8857C06877D3459E8660198C
189B126317F7ECB75B7B53BEC994D15C7E8F9C6890ADF6C693EC660FF0E46355
6ED6DDE7232D310BA0A33BD624933FB07E9F4A0AD7075DB073E1E6AB862B2776
8E29E9EE9740DA1A76207A14487FE4908E0DD9BD52A507764E05698324842246
C4DACB32FA759D59E0E4307AC105033A4693565FEE55DE922B4A793278CDF446
D8AEA79FFA606506C11AB66C6DB01A57DC9D5241C0FF101E99D7F264AC03F3D7
EBDF63DACA30FD7A97EC5E907B5AE1E208616803C2A3895FEAA6D3E81CC7CCE9
DC65529319EF2FB6093C41BDE285D7311454AB232BEBA4BD853E4670D3FED784
91C5BCC0FCC7585EF3C780EB6F53FDDB689D8794B812D546F288D2BFA376A854
04060EFBC17A5E9D0768D553B8792AAC122676581B4E4A578AE336C782CDB43C
3101700B30EB242227583E1D2FA256DE82AAD35DE860AE47D8F44620F52A1F86
6F9A2A07B2C81998DD05108FAA7B4D2433FC69F6E6BE010930461A7741DC302C
47137EDAD3219B5666B66E854965AA890FB3B482092485AE32E93893D228BD31
BC4A8D40A4E3DD8957217F9A34A4A711EF4BAD7B866DD4B7F12DA30B7D90C1E3
6A102E81FC795B09A320A26C5C367486EA986F31F6F9450BF21781EE559E8B85
F3B91B40EC2A66B8B14F49F72336FEADBD079B430DA38C6CE99FD4A4D6AE61A2
6916BE2D62BF28B50ACACF7F481A489A290B93C713016B7F0D764AE2920A82BC
A6C8C5C3A7310D2A612183F9EF89D9E89B3E405D192BEE8CD4CA07ADB5C26FB9
B660F77444E7EB0E8060B4EFACADA1878554CFF107B3B4DC9548FA4F52E27C26
3198F0AABC32A4DD17D054DBE4E9C240E522B8A5A731BA48A2D0164CF3504EDC
87A20CD4B3C6CF732FCEACD874F5F3F7F7CA9007433FBE2CD9D38CBA349096A2
77AB3AEED6679964D00AEE7B64D2897ADBA76D7827EBF4108B6FF9E4D7F9F426
CC8DFD61B56FDC2B4D1B52924D30D0DF716D58B19C1C70C429B23F6913CD1B65
55A42D3C7AE4FC81FCE3802023C8E14AC54FE3ECAA816890C27239E80ADDEE21
9768A4BD1017B83B6B0DAFC7F9C21F0923F6ACDEDF20530C23666C134719954B
666BD840165E01DEEAB372E96E5AA1A5D71063B34E6169968FA34ACDEC564722
109C0FA96E09FC2BB8B0F21537EEA7EF11619C1905305500915A807023AE71AC
518D708D372B7436676952806740BE067904B136C2B6B3BD8AFADFD5B5198E3E
D7FD2E525B35E90E78E536702753E7CC21C77863B5FE169C931C76E589FE0F23
F301633CC8A51450E21552CE44696F0E7B47A4F1C6E320D45009E02E7A37259D
8AFFB9F861420BF86287D0099FF9F570AB6A3A61DAA92A2FA020AB1A4BA1B68B
1153BCCDF7803BE3B4AB6A7EA1C6182B041F9AE7F6929633114AFEF487B4F3C0
B17F538C6D5BCD4C8792261DA2F7ED6E5D05FB6EBBAC1981A7DBBDDAB8B9727C
3E69B103C8FB0CD8900E0DDA1AEA5FEC9984CFE63E6282D2D488B6512E37AB4C
C00082B1878813DDD71BC6F707AE3878772EA5EB39E689450C0CF01BD753D418
5094C1B5E21AFF4CEBD076109AFDCFBA7C2F5A4A00BB0AF56057B7CAC8F3B1AA
277E909915B2419C59467ED8B07EF8416F674E211667D27028B1B2D42B4EF7AD
19A6A8FD6B1DF7BAE4A20B7E6C77D8EE3E2179672B4DB7EFE7106D7E06B2B57A
7E1924E88BE11DBA732FA150EDDC0F7A2E3A71E45E0226586217A2F44A8C30DE
22622C63FE21DC29ACEAC586BD8D6405DDE6487C9DA3BDD2E9EFA67589526BD7
BEF4B467FE1728EE77C1463DDEEBCE9A708C4B99F05C7E477B42BED5DB587A18
46AAC3780DA493ECB76E8AD025D0F52957099F97801F17A5902516B261C0B147
B5F64BC49170CE57667264CD351A6D32C26E47484CF1B078EB23F318C84FF921
DA05CA70CE688C8FF59843D691801C17B66ED70B9E5A2E33B9E37E9D2B266904
4BE108764DCA10A12A221A1F1E752D00BE3B85631F391A7488692A48F557075E
AE29FDB85B98A508973695959EA86B5E662D5C279C6909C295B6186236EE9F32
20EFB7BE5B501E69F13DA5B5027FB0719DF9411C388E15BFF65071B4BEA4C29E
2D0955AEB9C3A68B5508683BB7645A406BB57A1C2D4BEBB7DA991A994DFC7471
66C60182B9482737775272E903E75D1D98B0A62DF47F5D09E5797208F8881442
0FFCAFB89430EAEAF9D24853495E5659E98CBBCF3F5F0145C18B32F88C79AAED
E51FFA07E218F4941852BEED3661D27CB425253B0BF5666728D2D9A5C6BB9658
ED7CF8E6B37848E73F70F44CEABA55CD71FD2D3690A55A31A21CB9F3A4C0E998
8B53802399B6E22D8BA9230C4D518855DA74741A249103EEA2CB59608AA9C053
DE43015176D8B520374F1824C0BB9210FCD2DB74A70D8B82BEC9A24508A20472
139C11D99BFBE3F19706594CE9B9D31BC0E18B58A73225FD3F61C1E77CE3FC89
452957D4D4F3706A4B08559B7AB839B3A131D4F8AADC0405493BB9F1D7D4EFB8
E992AE5C11033B9E4ABEE0C93892C18BB56A3EA67F673743657704AC8357A9A0
98AB727A6C3E07427732318FB475CFB3118191C68AA6ACD8B73AEE7AB5D764B3
1A3F2880EC12A71DF8A3DE3783BE45CE0A1BBC429BA4DD33C317914BE4EAA81A
3191CE33DD5F7CEABFF720D4619FC4585FAE13F6013DC2AA19FE6D266B7C736A
8FF114F8048FB2AC67FB9E753C3FAD4DFDE9A6DA80A5A1CD6AA017C76E6246D9
F2A090096A286D38B7CCCCE08F4F218EE72C0452046B01B3E6B31A58989FFADB
0A795D2C2C6D44A680E566E753ACF85A4CFD49783FA209DE6960549AC18C1A41
B238AABE015B8881191DD23092F6D53D5C1CD68EBD038E098D32CB249E7AD49F
AE659BE3B79EBE269ACA32F86F59B0978B9B9383FCBD4D2EB8CE539FC07D9D5A
AE10EBEEB27C28AED5E3C9B39C6A9876779CD7F22CD75A3E296079D081E4C57D
4AD491BB00CE0BB3D6183C9AAE641E41A265C666F029712F83299C4DA83926D6
17401494E30EDEE101787C102051375750570CC8FC4EDDF2C94B08B2706111AB
7D342E8BDAE2843DAEE0AB50F6C970DAF12DD6C9325BC57B6F77FE77AE27ADC3
41D18A7AA33BA557FA8C21536C6CD50F6F4EC0EC1154AA360CC88559E381028E
090BF48869227D89E2465D88BF22262A06AC0CA4EECC03D853B86EE9D6D64C66
C1F1D1A411866221201AE726E3CC68B6E130AFD65411C4B7C3FE2474E6D2D038
63B5BD758A2D1C866A284B6B5E9B8662D1E2E85D8173A9E474E7475D03534B62
650F556ACF90B5C581CB81A633552B83867BFB409BBDA957C67CE6D92E2DB149
A0E0992E6C0E12988BD352C289FCC52AA75C86F475BDE461576FBA75F032E16E
1670467E02BDF2109185B29027A6530B88E6815A0F338993949F3C664470AFB2
592B5485D9EBCD6D81115175D675B22BB386849388A89D09865F4E10CF10F9A0
8B1A43F576ED709EECA9908C7332AC97BE9EECFD70936E6A2CE63F646323E354
6D6A29B60E86360C270404E9582D61CC0D79DE6CAF69F35F72117A3C1FF486AC
03EDEBBAED08984504DF932243878AA5E11F657F898F5FB67AE5FF5608C53CB0
DA138A7622A931DA293B082C862FCD5BDDF45F1FCDDB633D81E7CD05AB901B83
EF45364D29A1B73A0AE437A04351998F897CDB6778149FD68DDD49E05F5F34F2
7A7F069E5D755199FDB77D13657D02E52A6C3105BDFCCA4B178B537E767BBE4F
BD48E560F0266DB89B4FA8B46E5F007BF49BC41020FFD4241B3230E538EA282E
32087F332C0BFCF3D479E5F6E9C23CD986609AB5D8AA5752C845DEDC25045FFD
C7FD0F06829558BC0D1CDCDA2DD829CE36C293C763F39D565A6412B22A6F3ED3
A26B7E8BAA8EDB383DDC0BC6740305C408FB0FFE985BE91866A30F1FA46490F4
E08CADBC6A630CF69120219F655356979F2F437560DD44CE1765155844D33E82
D092F5C4AEB66AF2DE8232840E48BF886FB5F6AA3237A1DD9B10C3B9D69BA764
17E1094E6CA8FCBED908F8CE2CFC49E0FAB07E55E03F70B669447C0F30DACD4C
B655E9D375A574E4AAD2A41761BBC463022A70EC865850D63CF5A8FA807E6DB6
79CE7AB34D66981384DC2E6373B4B4E0722BA6B0DB3F404624B08A15A3844381
1942C7BDB5D967B9E25C7CFA39BCC477B11F1D1501BBEF79FB4C447648F858B5
1CC1C6157F4D067C6FCE61FE3191FFC5F9433FD42EB6948159BA5C2E1D8C2C45
06EDA9D317515EABF66B268AA27C03278F02394F4611CEA11A59B78B90C463CF
D3A3AF636279A8B02475144354DC5F63288B1C652C7CCD3FEDDEAA415F87B04D
FBED3D19371A766262D2B317A81C502AB62EDFB6C4B0552007ED672902C0442B
2AA0975499658F95C1A379458F0BA1FF0F4082E99F256E9EE2EFA48D3CC905DF
C1F0B625DB530F738344876FE778DEB924E72BF915F8414F26A1B130D8222AF3
27285EEE2B6965DE6C2AD23DE41E5EAA0820194285B989A91AE3E38C3E820594
82A227D8C1D8AA060AEFFF5EBFBDB922A67ACBFFD808777D94D4DF4EAEA6F6CA
DDA71CB62692E2F0F0F5C896BCE1F15D6E4E2E5C16389A4BB624E6739FF79C08
4CEFE2C66B6960D398E8FBE91762F5AE1EBBEB50C4C7DF5102D234C3E4982E8F
D46234BCC829D5B63559E67D12075220AA29C07E4E41D9F915714714AF73EE0B
16F574AC8B12D710EC0E33235BD496F9F0FF13DE5213A76DA4C36F60C6AAD9B1
47C49812878567F0B9ED3B2F8A06D09ABCEA26638023DCA9CA17D9C7CFCA83ED
CEB8BDC1C7688F49C2D2D49A2E484F785E5349532AB7AAAB6A46F3B1CB3C8363
F90EC4C7E54213423128291602FBCC202CC8046A863DD9D15DBB25BAEEB33F50
13FC35E489763D4D74A017746A46E65BD481FD1E35FAC8DD2AA5D68F772B34DF
DC1D4CAFFC19924CFAE881A0CDB97ECC0A37891A6C1BB8746B83419B91A5D161
AC509ECB17B24E3809E69FA5440699C478B64F6510C4F142273E41080F96E12B
5ECDD90A75C11130E1D31F69DDD882882DA73424FBD627905630E24F7681D79C
DAE8E49233910D945C4C2B2FF10EF4AEAFF3E0CEFA6AA03715A469FFB1FD9C41
7BA929FEC9A34813F7315679AB2492D1AF81ED16B26727D684DFEE3131F6B2AD
C8931320183F6814CF2E5E50B51DA8DCB44D98D66F69BB650428AD223CAC0FDA
9FABDB33E7CB1E028178444F7A40C39D57DD280BEF8F41DA2D04A2B72C22F279
961C76B2FC92C5FF98AC7333896D63A15AE82CB273D7B4CDB0B068950AC5AF1A
3E08EFDE7F966867A031EE7482CF188E75A3E7506347511D63BF9703141D9559
334AB5D00BBBB6BA3D4E22B142C6A0A7D3C45AC7D42570A895331F50D7232A5A
6A7A627BC2049CBD9C9437108824490A14ADFD413FACAFEF3051B755FD32EF8F
AAD0C67DED00D6F797E15C9538BBA5DFFEDDCD87877FF62F1314C1FB14B9D438
3B7B626ADFA759A872B9C5942F03F06D973CDE3CBC6CCA17520E1D996FF28B9A
5981FE062CEE32075A4D37ED00EFE24452C0499CFA0AA72A4AC2DEB10EB0C1FF
F311C21ADDE586DA19B7FA084650A09463A8A6B74D4F29D19DCA62D4134140CD
D4C43929093ED0DAB9F7CEF491D059875704DB3EF493E2C5641F2AF6B8D97848
82DC0D7340EE4F89CB3BE51AF2881C904D1A050E9D6BDF961568B0F2E655A10C
C44FA7B0EBF5BD13867AA1BE33FE467FDCF29572E61DA5B58B25E68F672D36CA
2DD1CEF12E5464E77BDA17702346D28C8EF565F08BBDB2532DD971A7798ABAD4
53B71811B029717AE30D41735C4D31535AECA2F8E425773AA8DB51A5570DF4F3
9E9BB80489758DD2EC6C054CC30C7E20CD07B0F66743BBB400FBABA9992D4B76
E83104F4BBDBC90A2BAE8E3A164A0A36FF806C20CD35B40F91469CA2A7EC71B0
3D28590D91CE5ADF2EA97D469288BBF4FE626E822818423E17A2A41BD163196D
6B40294DCE0825C67E8294F3E0C7C0D6341E8815810643DBF2022096D25A9F95
FC59DFD9B1085053C42ECF7716A7BCA4E98299ACABEF1E2626F6BE4EBB017B06
0C7E7ADF8371D5579AEF39483163D4027D71F5561DC49504C051D60BAD395FE2
E7D56C84071892EBA73C2C783BC051BBFC2D33ED2B6041CC4F8D578284CE94A2
D3107E01FDC7CE03D91991C1D9C939BCC096C30BAB1FCB8E8E8102F898A157BD
30BF14049CBFA03E518C8B40072EB37DA67FE62DA5128E273661EB577436D7FB
73A7E1B3DBFDEF39D66F614FFDAD81502A19E0BD113AFDA34A69A5B2A7A02B92
CBF745C771EAEAF736B509FF10D8C25F04D34D9A4D7768D70CEED66DC14E5477
6640F3AC1E909B3AA701C46A33C8819947F4CC974710C6C90051AFE622C977E6
5C76BF485398FD363A245B156DAEE34B8C23D1204C4063ED52CCD988F88E5FFB
C1802B5148796FD3D2D0EDB14F14CBDD781583B94A466A4A8A89B1BE6918969B
355B4EBE1346BCDDE9394C7125AF7E4BA52640AE2EF355062E04A4E5BDC05845
FDF5FDBCC38A2A0521D620B6120DEE636CFE44422195B13D9F16D211A5CCF14C
E27B9ED5136A150B174362A1D8F4E4DDD267420D4E02A72C38CB456152B59AC1
6D34F2FCCC91BC35D76640FCB87B049D72D7F66ECD0E4673AB7185BB2B7138D0
35F88D62DF9EEE8B0C3320926A1490B63C8B665673C1B9B67D38E9CC6F2A9D6E
EBD706EA6A9495EFE69064E4DE131651579427C8555E6113D541574B853CCB15
25F2FD1B2547673A62B2922C19EF228DB457560092443A7B4E5D08576BE7F01E
89703F912E87DDE05F2F7AE89A8547382BE13313A579725289FC9CF8B4829C6C
5B51B43430ABF676313F0B9100734CE8AEB4ACC4B97AD2B8A33D53539DFAADBD
D6866655F2A646A23C876669EF8A551FDBED262FA4B31303963E97D56BEECE5F
0AF696B107582CD6AC8C20AE9DDA4237FC21AB407C23EED1BC8C98C00EBBDA4D
7E041A37A2938F1AD2814E7E824A5D748D08613110E942B0F5AF49313ADBF9DE
A3E81F54D885547EAD0D1A4D932E0F9B515019A86DE9A221D4D9BB64622DFE93
28D9158D878AC129BDCABB4CB9F8E741355C5372E82C474E78EA4F2DB529A3A5
055F00267D640AC0FF6C36916E5BB58FC9005C544BC83CFD49200DE9398CC607
B6A1720979B7DC8CE9E4AF0272CAB6DA13783FD6CDE3930FD35A9B08BFA3DC2A
F470A001E078E3F0F9A593D9FF6C3228909BF258EB313478077470E575E0DED8
50150EE79C9AB534014A43B3C3FD2A233665ADC7F96A3DD408DAF1FF6B6716DA
CE6C50423DB01C363FBF7CB853C0E3C61567629EBF131C1C698385E5AEF63FE5
C57ACAEFFCA669C4F29440803DD698A7D3A495E757B1A5B0034F0C121A00E8EA
DFDA0DCCED2F7895F7C57FA537A09924B77A2FB723CBC616742505D00869D380
AB21EBF8FD3D99E6A2719365A449990B421201CB15DF2FB86187CBC133B77CEB
78EBDDA2B686162477119E165B599706A5DB2040D815A8F3172AC1EB460A78BC
7C9BCAB488229228FB17FB62CFED0839125FA9A57CD13F4FF73D5CA889DEE063
EBA87FB86A4C5FE4EA5FBC7F985DDE50DB555A1FAAF3BC75004DBD7D8D92AEC9
5F5F5AC69F3E71E5A29649A14A36373AEDC7585453B2EC2AADB24F70268201D4
3053CB8A36F8A492CEABEEB9115DDD9FE9D529BAD49C53A22D9DD4192AE7095B
C8430DB76E554C8C5A543DD35CF91F9CDF9D4CF1C548B4E97EBD91A10F9B1B30
EC216A663078E8A16117F7658D032FF70FDBCCF1BB5AF47B10D8AC0CC381798D
58B73DC234442514CFB2534D61E4B9F6F65E67B002C24A5BEDEBE4209A529ED7
4982E320AD36064C3D6FE6580EC04299DF722FF2ECFE65ECFA85CF82B58E5F29
E54B33EC930815DD2A8A0AA2BBCF659F52D1AA055AB3CBF73495811DC34A2F15
6836423F9E792CB7C220CC5B8B1E65FB6BB5176A3645059E998F6A72AC4F5775
C2A63C19DBE904B0597C2357ADFA9FB502B303849D8664A77003C7B6E2472B74
F3B7D9B4216996393C821772980B491E802DC10AEC6FD659718819F9BEB96317
9AB8375B6BD37DDF0BC04B20FB0858203131F7D0CD5FE1DBA51ABEC74B6371A3
09BF8CD5A682E0E7442DD4B965611DBCFB47E2948FC2AA034FCEB495D96DA0DC
5B972997413847759AE17595BC649A7C28158A8F1D40A222DD325ECF100D42E9
50B8A8BB468D59B6DE4B669F4BE1E94C841A968C8DE9FAB8FBAF5723623C81E1
82CC3197678FF297EFE332CF0C0E12D9809E62D40D93E74A4E81E6C123E1E8A2
044789CE6E202DFB791EA4E2CA7E005C0FEC9062248BCCA578AD2CADB867DDB7
FF0678F77B4EC3D70C60358C5343AD3C151BADD40C366CC21F4133DB808147B3
98243DEAD2F072807B87470C3B4DA29FBF03E097E722B268816FB3AE78D94F88
1F92392656C9DEB496966539FB5B9B30AD23FF9BBF01F5BF09F458407C4BD4C0
80D003196E6640D027F11DE5E11BA6FEBA93505EB627470CFCF25D070AE2A8E0
DA1603969F8D10469A0A1154B0248C2D95E2027584D8DEE7DAFA269949ECA539
6A714C72CAA8C116FD970F83CAFAF158D8261243615C04004D6F1E0CDFCDA60A
4F4093762E192185BDFFCE7F9C40A3948491FFA17FECE59D345103CB03226F48
0C486C27C0F914E665E9D8D06B135D3D678385BAA5BDD01337232B4F684D275F
EF10E1C8DD91E5EEC0D50915BDE6D5431809F175C7567728FBC797A6FE0A000A
DEFF9D4E4A6F5A61321D503CD5A3AF5BB79B644D4A5FA1F043C18F2C41CF197E
A99CD68273E33B9DBC42E7F16D7D2227CE71D79B41B3D1B903183B0997BE3AE9
5EEFC68265DCE0913DDFB35CEBAB888FAFE816E06BA402ADF5B4C9E3F9B88D81
DB2DC5A2818CA4A9C48D5A07A48D0F7F849C787650EA8EA9D7ACACA903CE98EC
B9BBC4EF0A118B1F4F3FD53A7A6377DD356CE4A0B6895FA19B4DB7D08BE15D2D
D70DBA264B0155D20E4449A9F7E43ABDAF8301974E4D9D5C7F658F45350E234B
A3B367A85F0EAD2FE02354EA062F61ABC7EDF542EB98666B64E1343F2DE6EA1F
BFF91B8A7425EB74E4DFB379E10D2F0DD013DCECDB5EFACDF2C595CE6E4D30C1
7221C9AAEDDEA0D7D9071FEDBE3E5D6B051F6A2A4DFCCFFA6A440F8B8E82F321
65B3692CD1D8D3023DFC9947DE3D25856330477E4AD5A1D01237A6AA9DE054B0
D70D7751C8C408656144B67FF6EE3FCB420E1C391734F05BBDEE6AF3F9E65593
04F2C08F7B264ABE93495C131E39DE3CDD0460A90A4E6F6247A97B1F88CDF0EA
E930C606057397302AC0FD8A98EF57C582AF87BE6B15CCFD68214B5C9DE71801
A06843CEEC7CBF8BDC916288619CD30DADA55BB2C872D55788B804857838E55C
64EEF8FBDFFAC08A9B5DFA2D0043803A7D2FA43389FC4AB81436324B5C68A193
337A60B875260EB5251BCDF736E518F764495958A3BDF785B89FBE436B134ACC
B1960448FAC5811FFCF88DAF53E8AA08B4EAB6B6E29CA493B4BAED63333BD48B
EF400B1BC800E9E47AA7AA2346D28CDEB614F1B10369D89E5E7CF8E4D3C0CE6C
99893516E6B40B410EB5FAEF7CE733096C118FAD6E3DE12C26F79046B0C3B482
A10B221DE6A1D8483C9E9BFB9004F3592BE3FAEC874E6F68CD99777D85108FF7
3FD1A7A909C0CC8BAEA28A08F8A12C4E66BE98014220B3699180CDA676758319
39F82EC393EE53756FB5995D3FC52A063DB58B675E3B64BE14F450268A860A99
2177B40BC381F0D0F9FB310C86AB0584F93EF310DB48E5148C032F103E053FE2
2A555EB7144B50EBAE7226D54F36851C7162A333C7B18785ACEA76659EC5EA23
A1E47315C4B70EE19AE599D101B7ECAFC15E923DBE62640D666FD45267215A97
7AEA0DE3B9AF38D9C7B95D83B9F86DDA52FB2212E6FAEB263D11F7F843F7C2E4
E3AC1ED4DCAA4A65894954F7ED52673D714BFDF571C68DDEE5CE63FF4032A117
A4B9C1FBF5AE91EA333992DE4188586E4BAFFAF75ED703B3DD49F3F651F4FC6F
FBC1D9AC2EA9FFE4EC08A60535FBB0B188F4D0CF953D44190F34637417E3FFF1
044D9D04D0C6EA4E4E8E135170E3F2C2D264563D428DB12D573C18486B602BB1
8A2E493F065DB0F34D309811C709E99F7E2F754E531FA417B50E0C1A028A9D2A
8312BA9300CC8A21FB0707FD0CFB80D2FBCF6C52ED1663AA562355D65468DD2F
FAB317D304B576923F655CE0E70963FF40918317341C1FB6DDD4A9F55691358D
8780F518A648E31D8FE70A15B977B5C33478205C1DDBEFA08B68BAC825E2762D
4760DFBE929FECAED1965F488888CDAC563864951CC53E96E22B50A01C8CF86A
D9BB6D88B5425C7642FF8AF029D081B4DD37F47BBF29F46DA4DADC3D4412D369
E859EB177BC36CB5F9091B806B8D143AACB084E88B5168E1F7645F6BA6223EB6
1962FDF418C52F5DBA5BD73E0B45B5E0C4FC38FC24D4487D6FA522D21A3BD8E8
E904B9DFAAA15094F4380B74072630F3C96B480DCD7D076F85C80DF78219E155
D1BC7DAC17E8E1CADE85E38070D814A46DF8DF3B21D9379FB377C2CFDD8D8E44
C5D2D5B5434C0F7505CAD8C255E2BCFF39BCC379137B49327871EA80F461228F
DC92FCACF1EF5F27C53097C2B945869B113144E671E48555844C7C2ADEE0D341
3E4BDAD7A847E185117A40E71DD2BDBD60E048521ADC59A6A210BBC21055ACC4
BA5ADB3B52B921706AB0BD7C9A72EDA466AD4BF9DD18CF2B449A77ED92CED200
1C92610CD8BDDC4126B7E3DA34D76A2D9E4337F248AE52A1FBA980B4FED3B97B
3C89184168DF8B2632A52385DABDA3E7673D3A8519CBFDD0B5E03BE728F07395
CA5696A504579B80715F8D6A1C716B4E8A22D9670147D23A2161BB84890735CD
5CA95EF352422B361558BAAE9AA28A9115594C8E041B4C5BAAFCBDF5B3F16DB5
A709143DE6523F89D8444A4F94DF36EBBD0196CA4C0A4C81882CFA15E1A540D8
521BF5292D0309CA88E51BB5E9CFEC1B01C2AC849C08090458E7B8510FEA0C4D
CF97BB8D139A28A9ED8A812859BFA57F098E51955A34EA5384DD4156CAB5258E
CE2E18AC24D4129C349441D1689A14CE28FA864561D350F44F8163E342D5A656
9CECE549649453F1A6817531971095901B1FB517726F6028288B8CFD78ED47EE
C9159C5E7638284B6171C78E41D094F069C66405C45D93F9B0C0129F1B7C8E99
F86316A7654800820EAEB556E5601499A16C66407742C198A64D777A6D86494E
3CCA3C9B4046A60EAE37B582985D34C33399CAF7EEC98C76EF27ED5AE03D1E79
7C9A5FF707BE874A1F4AF86766B044D99F56EBB98E3DB172E2F22DC62C985AE7
2908AAE312988C3D04607F48BAD9D91798614FDA8DF61E231FA372FD47BB073D
B7BF08B9385A711E8C47465655B1D6535CD0986DF2B90EAC8DE844247E7B52CB
516FD369131A45672E9E6F9BAE2ABE4AE0125D437EAE557FF33C472C08BB2B5C
F0A20ACD2B7622A1676AAB00AF23E23C31C8547809218BA873735A2757C5966A
B060499707907AE99666000FD882FB1CAC0CB0DC2F851EA57A063D36CBB9CFDE
B0929DE44BAABD37F957B4D821E168D225F364D6D85F2222DFE421E2A0944D8A
032181ABCB040718162A34C1842981C9B088A8F0C96C911CD9F5EE9A4DEEAFDB
257AE1D1ACD16D5ED62B10D646C2A1F830C87A48497A6408A45D674CA013CC3D
28C520EE3600BC5A5579C1042D4E9B963D840F8288AA90BE927954C4854E20F6
E238AE80DDA11F851ACC96B176DB7ED2F9C36052C49B49F837E8673BC765497C
6AB5104EBC4CB841F2093AA87646C50955CE00BD7AD18574129324F7E55CF493
6BBAA6ECF4016A2F3AA53D3EE045AACF57E3124C3795121827D9CCDC190A5942
28A594E5A223120B919E99265F1668EB71832DFEFC1741070CC3362BDEA36A44
7F9097DAE72D4B729CCC101CD4E088E9F20FAFAA6BF7FD74DDA202ABA0230C2F
0D3D103F84C3E55BC63FE73E91CC3AE18A2C401A2DB63B93A295B5EE3166824A
AB901C7C54ED5AF7DFBE33FF74E9D77807816318061CFD1B1A87E3C2B6746703
65A117997BBA9FDFE9C3AAD8A8E120140CB8432F49985621FDB21BEF60B7D491
A2F667936EC32DF4F060ABCF1D4A8DEF5CA7B144EE7FCFAFC7E80DDFF80C3283
2CD000B0AB0281C7CD4FB951E70363EB1F9C2EA807084A6F3129BCE63AD3D4EA
3CC638A37D8B988145C09407CDC0B0A99A68699125B352380A01321150BBB357
9B09355CEF36D60E59B864DBA11637B5003B96364D3DA2CFE05FDED854D249F5
446906201CFC7E25482BFB7DBD59E49B9EE17EBA2352DE294B85359AED50977F
63153C37B9F6AC4FEE4483EBCD38681204C7EA27F27CDE7A65DAC0A611C86B7D
DF4D91A4F1CA2BD56420C30010458A6C5302951F7259B4FFC73942B718084F9C
91FB78A5B2358EB24EE13100DC50006D25817F5F8C0501EDB62E5F4EEE765743
A903767911DCFF14F0C4479C144AFDC37E4578815D57A5C611A5B33BC9261E45
9B6D0CEB04DD223A8F57FD23BA5A0F774C4211F8966EF40161A023D09BC67B4B
CE5C1C55F5406B9B35C719240191D57EE7FA05CC5B2486E6D6F969B43BA9E720
8B8C99FF66CB6BECF3FCCBF8577A682DCDE6CC8452EA1ABD121E20DA24B101A3
5887FE40EA98A12CD3BC984FA1819200601365AD3624DC3AB65F1AD9DFD6B1E4
5F1A6ABF0206A21A5D832F83C4E75C2180FB5866EF5B598D4BADF2DC126FF7A0
5EAE519FF13256A1DD7079F8414415E9E0DA621A43FFEE9245F9AA0EBE0906C2
378FFC0B770C9DF21F9F40C172C566B1582E8D7C2D0ED16B4BC58AE9CD5EAEE9
774B07A934FE20C93827B8822791C134B126A742B796404E8A6A4F24C8168C98
FB11D10613A10343543F4F0EDA40E4BCC410D1C5E9168BE0A987CDD038572703
F5E2ED84A4941811E70B181D40DA48BDD8BD58BA17844302276A6FE777538FDF
493350BDB294E5609CFBB7FB7762CCD428ED155751A877D87E84591C50EB88D6
50A226E068F161491B6B9E368CC0191FD3EC665A0F563B55F2738B16D1FD97E4
15393E6B62F58F9DC86556254A8A71F70C86C1CF1F67F340CD115568D556DD65
FF12DF0DD89998E5B4DDBA614FD05F7E2D2E39A8E797DC888B65AA9D7D2AE3DC
264C9B58E9057C7C31ECCF837941C0D957856350661189F7EB8082ABD4364A7B
1630CA0BD0232B69280A39586639D8E1C418E04748B104D2FD8D5FF81D006ABF
646D25C4A9B937FAD5CC305A0836C5CCB188D1E4902CBB38AF4DFA01B0AEE3AB
A7AF04C8CC4C6FEBFD1A492C418E90A879E70C1FE775325A6F5F655C8BE40FBA
59E649B7EA3F170A499EF0FAA08F318703B8139B8EEC22BEE2E8A1A721E5A28D
CB5D3CCEF1B7EA560346347B43A543D52D3F0687A49751BD7C444B8F0156C0BE
DED15F61B43914C6D17D103833538BF0717532E4799F0DCF5D2FAB1DBBA602BE
DD8354CC9AB3D1B01DEB5CD178D85E3DC41AE8930680CCB4036C14A9B524F602
6F3551AB2242E0BA2FA4BC0C197562F93DE35FB61FDFA5A4C78E426D6F68DFE4
2F76B2FD2B16D81DBADAA3DF3C2ED508A5547C4B8B182CBE2C1828ACEC6A28CE
ECD551D569C78B57FFB59A6F1A07D391ED604FBE708825C7BA991F36C587C30D
3C96BFF90097DCF8288C2D95E222EA6F455AC5FBC299780DBAA19D657FB2E8AF
3DB3E40BE9E22D7346A518C7B6B7476856841F1D6D06E838F7245B1347921D8D
93659EC8BF5392F8CEB910BB59940BAC40E626D5E1C7A474BA19F3AFCAB923D4
52957EFA5E03C8ABED884854242913773A08A5A4ADA87D3D4B8954D01DDC8874
6908EDB625B9FC645E4AC52C7D61E01C7084E3A0161D14E6B6923D472CB3620D
B72303B2D7BEC29A113448784AB49BAC0E8B4E338F1F8AE37057DE0BC5B2799B
4A6B62A9C9BBCF1FC02739ACB47548193347AB77051B3CE85340294535D4C10F
45FBD9D0AD5DC07343C220FB3EDC22E56DBB5C5C335F34E93E59664EF122CC18
469B39618A3C477A9F536037569228CBE7DC96A21117F817B607607F7EC5ACB0
6B9F3E7088164C19E3380ACC2FE5A47F2B2F394BCF99217F8B0D9DA2575100A3
3E0287C97F91021615427B7572E807F03B94C5DB326FC1900C1051A12EA0AF63
D45D80F3C249CDA375D6039F7E33C33B3E6BBBC51039331DC4E3A4C1C0DA714A
D9D987DEA45368072750CAD0C9ABC3F49106C605055A705CC4D79163209A2105
EAC6577EA6EB45C4EF9A4878ED27E515FED0D26FEEE69602B2BD58D1402C56A2
C2166A0E4EE6272EC1F39BB7E05C36CD0DE619404C88B132590E7B126DC20CE2
6DCB6113D415C1560EC3077532E0E981F879B79440CDBF6CC14F198DBA7A8E27
E664B94AF73074469DCACBABC2031D1E1CF627EF67DA4C730FA8817294EFF9C8
9AB74DC4418F77DB1E4218E3084DB0024341A7BA745D8F3DF3DD0D5AB028F2EA
A2595C2E72E76448B6CE2AAB25ADB6B6B2AFF57F0B294EA1065F92D50162CC8B
F51020AB411A3A0AB79B9C0736A907417A24C0489BE85952A6776CA88C806DDA
31F02A874E135B483BC8155E7DAD9D85DD27CC7D9729CA797863895909DF66C4
9523AB41242F1D916ED69D1B7FB6EDC903C5AF76128546E89E3B58A5E519F34D
465E01301F4C9ED01BAE3BB56977F0E8D21158CD18F6523CF7B636551B01B4E2
4F835FCB8686EA2EF7E9C1106573674F3349358E9C9216B45B933D0DE9BDFECD
4A17063BEC1E0D48AF25FC82593B1F43C7E2B5368958C7D0CB63554705530D0C
93443F0FB9FC74E637DF7A7C47091724D0FDEBE946261BB9611DB2291F2AD258
5BF559E6BDA1685A288C67B158F34E426E865DC8BAA0362B0DFA26DF487B9900
F842AEDE6EBD4067C5B549E83AF7B999BBAA32DCA143B0140D6E0B528CC121CE
D1CBC64BD28DE9517C0A6C2F0AB123F26F44A44A50D3E4011D097E2C9FCA76EA
5A733E314F1FF6EE52C5F1163105C6081F9765E539AFBA3730306A316F2A64A8
F469397D214FA4A1DAFF1C0954F1894D9EEB4034FA39274D2EC964B32F3FE6CC
7D57FC95F9E51FC473410F96B56B11B7BA4B3B0F935D7B9F858F0B4E780A9B59
F3176A5C5AFB83AB20AC92EEBB23628EA6EADE7E631618F48D633E55A4DA9421
AB550DB7F4EAE4480FB4E80D0BF82E819C925254830DA1CB099A6C6556E70EA3
FC9218AA9AA6EA2A3CCD8551CD1AB6EACF00E8F0CF90D4A57FFDC9846F2B53EF
7BF3B90C59647E0D616764F90484747EB6E236A366D8046477D04EBE5475082C
8522639BD02BF782F79CD875F2D2745418BEF87C629DA3E3C211A89E16DE5B0C
372EA8DD01647B9534D08DFF5C819EAE2E32F3C52E50821BA233B7D90D3BC024
CD432F8281B538DCAAE19E5F27E7F18378BEE4CF8B882439A9092422F8550342
E56C98651609E284BBE73C5C33EA8FB20939EFAC81F69FEC9D92AEF953CD07A6
3AF08E403DB837A6E6EB5B52549B010FB206FC42AD1B381CD0A181E59ED9410F
4D901B9CD2061595FB27C9B17150D659DAFF754BAD59DF4558D2D608FAF16668
DAEAC6BC165BD53B96D9931193F4613A542FD6620D00411E5F367DEBDA867E26
57828356256B69B89D275EFFE5BE187666E879F2ACEE148D55098B00AD714B16
9DA93627B7C3F503A17EE9E03504AF1268BA20621368DD7980ED82688D2BF4F9
861632EB43F94C377753D001B0349E0457B6F863251C667912F605356788B310
59712DFECD2A63DDFB39B66B4DDCE39F3E590823590CD7C75BBE8B58EDC2F1DE
95A4B84027DD9CC23388D465E53466FDEF6E490BAE13116BFC8D8A92C7D46E31
8C46F44703B645E263F8AFB935FE3468186ECD90E2F15FDBB395191E6C465A43
DC438E60940A1A7B10FF68354C043DFE6F770C564FD78021246F0C2147B13D70
4C0067DE90B53D9163DE84922C1BF194D09129E2021AB9B4DE3C8C0567E70FB8
EE989E3ADE06BE1592DF2A0F06B94E07DA110B5F7919D75ED4E693B16645D354
E54ED6C97ED4F591623645C9927AACD8CEB2477AB747178185C8D31BE9570527
8F9C877840C7E9A7149C40D1DA8536AF51BD0187747CEDD0E102071E2BA4404C
BAFAF99040CF04CE4DB5A8C71723B13CCD771B8D108B7CE405504ECD699F42B6
DEE9D130BDDA2C5577F1642F97707FC865779AFB6056DBA877CA9D4971C41D44
17079D2DCF09A015677D777BDB40CD67106B82A197C0C36D4D35AF4F7F0875D4
A77395A3D68622E26A491ED0063B799CDFEE8095FA36EB42FD653E6153F3542A
BE4754AE3929983BA6E0A977889F923426DCAACAAC59EDE009D49BDFFDAEB985
6A46D359FB4E1D5D000D2B822A026D57E5E0A4FB5A8D08B96311C845ECA7BD37
0E0044982540AA5A754D1EA8407725FF461106D38F4EF02848023608C1267716
1CF0B983931149CEBD1D03B9EBA49C7009564214078E4A64A95F3973DFEFFFA7
1E4E74EA1D7CE4898094BCA694C00877E6BC65EC82F51874B2838E8D2B8E98FC
6F6185F7C13438EA9AA5461BFA944FF176E2FD1A3FB8C8FA19BB685C7DA55C5E
0B9F021DCFAD0A2D99517A35BC45189DE3CEAACF4F9348EA4A516E4F5A8352E4
17810A48AAAD3EAE66BBEE79E19BFFFAE2C18D37F725A61174D35E1220F9C763
BB0853229F555A071AED3C0D409CB163EA4EC26EE2F867AC5947D650638EF15E
932F1B9CE429F3850ED936A4BEF78AD5281F4B5075BD1BF8DF1D951426BA4EB4
992B5A523877A7A0EBFFE4B993617095E813169F68881E5062A25F890B494BD2
65B61AB7EA4EABB4E952B6F2A20051ADCAA1AC7C1D1426B688E5CDF0E2192521
ADC7B5CC653471381555A3213B871E4D537100C4D81842BDF8F4324B6D4F8235
8022194410F23087FC234A9A8AFFDD8600E51B9CB7BFD9DADD995E6E2033E6CC
70BC0E96636EAAB676E725F9A9FBCEADA2194F7BCF7AAE569CEF156BEC782E44
613FC402E8E3AAD1DD61DADD7A1FD82F0C2E744CC3B65B5D1A9494C920B4FA5F
D6B15306114179484431F2E22EEF35925DE2302E8F26BAFA9C8B162D982EF590
2192B3443D2D595F3A3E6DB94D42D2EF8BFB8514BF6888BF540ED710D8616D8E
DA82DE6BA704B529D187450DB7C071527D97CC824F55F98CE5C578A52FF470E1
24B6A09DF2E99728206629B227617A2BA68D430F1E8FE6F40F1E0508A72AC41E
E688184BFE6641C0D34DC5F77FEB379547B8FDE43E4E692B8EDAB13CF5AC05D1
1A33F2D53EE268EABC6E456CB3A80A4AC3F89150597FBC55DFE6E64783412A62
5BE41A41B4E83E09AD7127BF672DA7C5F38BB09A5785BFE8588C946F09DABCCD
5FE74AC5D873DD41489DE95B4DF76423A7DB7ABF711BB0C7C703843BB4FDBCAC
9919F7D23F8A75F6D1464A7A8025262B1C95F281E6CE4DDC65622EDFA8E6EDE9
A47DA62658B43CBCBC5E8F50BC850BB70534647A4C09D8B5EA9DB838A16A02ED
EBDA7DE269640C43F5923329E440A4BC1282B989F287F5C2DF8A0C667CCE4717
B7070B93080400E25D70A165C7A910EFC22046B4494D36D844F53727F4B65D85
450357076A1E1644C74DAC6FBAD49F35764DE6FC0B0215E256C57F1D3F3B7588
222674C1BA557F639F2EE9C0FA967A222A008B72B95440914969A1F2D001A5D7
C9A8DD908F414BFAE3CA1C359295C7D2967195AFD2D94BADCE1E96BC1E1D60E3
76B4E430431F049992647E2B744E48AFD6442C87CC67C268BA8DB757B85BB9E1
37D94D7E59E41E835C62B161701E73234DC803CFAF7C88ED35A539DC0CEFE2A0
098DCDD32D50196DB55BC8463033C452199674674CABD55602A2234943DC1C61
7EF756440F870DA4B121321E887182873FD7866F5F8415EBE92E51E7FF064BF1
ECF54472863A43FD9895C72B839A36171E129FD3DB880E2C8522639BD02BF782
F79CD875F2D2745418BEFB806F79E332D6423E07B092D8E28E4B265AEAF52EC0
46FB8E2DC6535B2BBE6757B9B29A5ED1EF6243E79654FB66DA31F7AE1F58AE1F
5CC02281429B33760498C875E933225EE3575F9FD4EA6464FDCD319496C15859
CDC7C18C963EC36A606C0EC22D17904AAF144001329CB3826EA2E43905EFF702
7AF9017AD7735E1F131F51421F247B70858877C03C1100D8EBF3CECA4AADE5DC
BB3F0CFEA274EA0CE21010E3AAC8487C9AED61EAAB9EEBCD9C390AEFE114C833
0087D781F89AAEE65768260F32987C3D98A712759EE22D9F51DAEDF587381665
3E5215E436CFC35D1EE02AFA30376221ACC298E23BCF88F60EB7177E9A86D766
5C53D66C8744DB5881A2207BED1F3B5D595DF447CFF84370CB2812E8DF9C6EF0
F015C8184493FC6CD54786AA02B897A5ED4709B6DCE7BB41A81A21F8A1EBF76C
4C80396D8E0239BC3C5A5C71F0CDED21444EE372BA55DE7AF1986FBD7FE6830B
885C8EC5C9866A2A07325359C1E3356119D1E4BD658E9EB5C64396D14E541FDA
2D3188E0CDF053585739C74104E048EAFDB5645F4D2BA74C6450B3F8A942B8A4
B8C07623DC3C8D72AABB37E704926A5471C3ED727BE7E559B6E54B0C7A64D4A2
C86BED217A492BB8EF96B9D0B8AD794FC37229A534DDDB4A6EE1F2FF20C2C04D
FC9F36C8253C4346DBC11A9D851DA45DC2E3311C85C93E8E44E6D65CC7A570F6
E1AFC945D3F71A8D77FD3AAF7617125268046EA711B5E4CC2C47C602B56FE985
561EBCF74DD0AADD279F095AB2975A5DF7A689ED97D7896893276E071E1016C1
E67003A22251C5CC9E478821EDA9FDE18036D39D5F49FE4333CA08BD3AAD8300
AF341E92446E39E4D60D543C0750D7195150F8B2AF92DFF7E113E18F1BB31594
F476D76445B4E57E8828BFE2F21ECD8FA6935F9367B7EE0E503AE7505C3FAA12
0817F59CA9090C11E7FB967904D7E857CB98BD6EB89A039185AE13AD4E96C852
2735074AD649CABF39201AC87C5F855EE5DA523977FB149576AEA5549B61C547
5A088A1A03711ACD7355594B806021459FB6F81F2408C14547174B1A2EAAAFDA
E8BBB54C9F7092778849B98879F958FC9B336E15E8EE3C004041C4EAD85D6E7D
1FD1EBACED2FD439DE9ADB1786283C4EEC972AA3F26BE495B9D01C314A73CB59
54C6D639CEB6F8A0A1F4D9414F1CA12EAE42EC154A2956C5F3ED914CE6A93F03
186A29C6856BD44B0343D48E428C5E1888B32E0B820A95DE4DC41FE8AD699701
FC2393E4C219296AE558CDC72D278609D9426C10220FC1CEA674D56637B40767
9812A0890AB08ADCCD80A0254541A3FE4712B1D0739BEA5B0586EDC6E621B390
3FB71AB68FAD4E316BD62804CA36D4619D8880F9594606C9F70AA43390728A70
1FB14B6B1700AE32B2163E768AFEFF5E808B3F760DB00C4DF1F7A259E0754A81
DFBE97B8C11D95DF2B43C2C1B991E045743BA616B17135CA6E436B3DF24E7DC6
AD37137B49327871EA80F0250E58792A873B5EB6DC81FBDA19A36259EF716988
2666E5307B51148B2CF46FC1B7F2B149EBC1EBB02C3344E47E477C1429D85F69
09DEF8C451A5A38F6A1656BA93589BEDAD3680158B6369888E88F8ED19C4D792
FAE7934D34342FF91B3D0D6E79725A6692D96DAC83BDF3942431B1F19550A337
E455DCBFAFCC8413D1EBB0AB672BD01642B36F01C6710BCC3064B3896E28AE73
89D260CF03255F5C22662BBC2003235CC96E832A27D6D3F9F1E0D7C97207497A
A5676C08828D7CF593CECFD951BF6DD21C37F6674EEB53294C36C60F1F06698D
3E30BA3AE10618965777CF1700323489C7DFEB4B7AF909F18A9D03092052ACDC
8353C95AAE1E7875921684BB0FA3EB65D1FA0A8B14AA35A3A38930B1009E63C4
D6EECAB8E869C01D1FC8A46FD3A7F768D29951166E7842CC737495F33CA417D8
27C75C6F816E62D99AC232AC9B5F97FE1B129C72793A88611B76777B2EF6EC79
522E8C2A743A530180BDB27DBEF1A92E0A0456D103AD819382A9EB1E201AD6F5
22AE5DBEF379A1F1FE5E41BDF8E59075D83082AB0165E1AAC277FAC71FD55A54
90C89142F2844CB7E6352B01A0743D7D28A289F5FBA009CDD6A111CD7D739BB8
D026A27073FAF66CF529D8F9233B2279D201F6E6DC038F5026DCF2F169805580
F4EBFF87B92A0E4040F9F5A61B5589C61ED5EEBF32FDFC699847D069FC2A6567
1D66EB451A5D4394896CAB73A2F2ACED52AF9D066794BEAF0EB7F7CCFDB1AD7A
FDCAF519B4CF9F2C38886DB3187F017A780650BB4DAD4B0FF3779D39D39D1205
9B64E8C6097B5287F8F46E2C3ABA05CC5EA4891FBEBE1B6371CC3040EC6230F8
E1325D300A47F8F2CFD4533AF48969765A8C9B5AD83AC0C067C6CD927F6CB16A
458D4A9E00B6F7B3A139B330A88F86931A433EE1E658465D07D69ACF535AB34A
3DA01E462840347CA2383599D546C489AEFFFE5C3663FCBD0D21CE7A03F7E477
434893D83B6FE2255AB5E36655C258A0D0E08570126F197205F0F4CC8FBC839C
5E143239B9AE4EA34B72C0BBCE57CD56EC89C8549B11366179359D75E5186F00
E6D9305E675EFDEC5D3537B9A0B4DED81C9C8CD85C0061F791F4490E66AB92E1
E00C0ACC88E0D508F51DA7D95D762C840DAACA42F8E40BEAFF2373FA73866C8A
62E5F5197BAC93045CF3C06DEFF9032341E87F3EA0B41C9A0217F8765B69ADA3
F104F5F4C154E41ABAF87212712491974F992A51166264194AE7ABF9444B3AA7
1CC18EEC797D1AECC8753EC70EBD50946DC466372BDC947A1DF7832FB07E9B75
C1DEEBE4FD9CC46DECD9721A38148ECB005AE81C29B9558652694BD9F7D7731E
7CBC8713F9370A09944A97D7EE142A9B6145E35A71FCE3A56210FB0850584088
C9548979A134B0FFD3D53CC8378C2CFA9FE3B582D67646C9526805D46A27BD4B
64387EE6578720B86CC924A4907603791C172994D08E031BB7D029682F38FA59
34350239FA40B774D39B6DC2CD6528EDBE048DC46D9D2180BDB32CCEDD8D886F
B9CA20BE6223F1AD53EEF33F6792D5BDA9FB3A389CEBD97360B8D72F93AA7C20
1758D178019F7AD3C5C3A8EE082DAADCFC407CE921FD347037BACE35CF171FA1
81CBC99850269D0DAE3113B30F0662AC3C3E4355079F03C32BD3D73749B89546
4FF803437E172D024B22B0CA5BE888638593DA91A601B6BB4D42C4F9891608A3
7D10CBBA6ED9B817CA185C2078AA2C41879FB8FDC95DC18CBFABB91D2CE0839A
853A30811FFC76EF9E169261A1635E7F0D832FB933046F05B037E8CD077EC06C
62E83653321BF703BA48DCB31E0CE6C03CB98ACC1C2C296EB68A4425B2845A5D
D305CCBFE8A779E06D688E97EBAE8CA0A27C064095E4B939A2108828FB5DE54B
7DFB732772EA362F8B4CAED6A5411FD62882232EB696DDA68F3C53301B352C8C
647ADC52BDA2C4CCF1D0B0D587CA026EE9EE3E00999E746C7D9C20BE86614D1A
012740EBD5FB399FE6B37029689D298C9D8B458BAC8C0E12B7D4864C576E438F
674E0516834E283BAAEC04BB4A63172A702AD6B8AA51D1A8E6F62F04439CAF01
FCBB5A090D6B90840129CEE80B0046E22ED2BB8AD68DFB681CECCA2B96EF65D8
05C5C535C3AA85F954A6D607538DAEAF606F2EBCDE6DC50EC555E99E96080D06
721AC14DBBD83974D43339B30369C3FF1F5120C10FBA7E3FE595033CB393F74C
23A675A7A28BBF15D3753A1ED11261958A898B85FA2CD9A2309950ED6C6BCFD2
00E14C1755CD34900B1DB5E07B8ECF26FFCBE3C8A93E4FCFB6CA05DF3E55398E
2D778D29C42D4F28483EEA489CA46D2096546D8D0DDC7AD53FB2D22C921207F5
613A6F0B8AF8122E73EC2372ED0CC64FFD79CA09802FC8C7C716BE3095F1422D
0114B5037226C13CD060E0881D20778C9B7E0B74250BD0F9006C43C1B9E78EB1
63735B5EA5375B603AD4DA5F1EFA448177523030CF9AD45F0577A4AFA61A5A96
4B568B421ABD90CEA63E22D672AFD4BEA55287A3444334FBB91C352421B02905
1D64F242940DFFB0202193968CB8D3BC04FFD354B0FCAB2A2FE7E65BAFDF04C2
094A6D210DECBC6016A6425B5387EDD4EA314108A182636F9588D8171CF17644
DE6C735A30DF89E694B2D0B2A6489DDAB193897561C343FA470892273FD519EE
CAB7604ED634EBBC26D56403F696E1F3FAF46A2AD1F0D4BB40CB37C23BF49293
1118A79393BA7BFFD785AE56798477229543EBB8B9696E30ABD07C3C36E87F2C
7D6F7DC8529B7DEE1F0BA9E578D468216DD1889C315C11E86A95E1F2F324C77D
9DD7697384BD4CC3688C6F100E09295F8459928E179F36143CDF9E3E3515DBCE
FBF5EDE7E180C9AD3DCC0441280B057464EBF4D0FC9AC991088D742D84727A63
9A8FA36988576341A483863519BF6D9E56518560CAA9F61D95670F435AD39BB4
F12677D9BD4DE73FA819855FB6A197685FAF8F857D006C8C2CB5B80B9C78E839
C85D6B20D0A1DA4B13A71197BCA01C56770080274300066584390B82DFE686DA
7DA54004ACE56F2C4EDABDA24C1260A28C917940138EF4B3D8D5C2A047991359
9D0245D99312C0C2A06D16CED8FBD49D97637BB16B3436BE8C15137F57F1D438
2AE8472FEFB2DEDE09F304BD818488DC7AEBD14046C1C6B3A198DC3EB96CDC13
4896C561E0E8D3E34FFA4165B8598C74AF35F805631B2BF5ADE846CDDF1DBB43
879AD686E2DB58DC49B9FB805160D28C0BB112421A92859C333145BCC296DB6F
FD004C51D1C643506BBAC0F7C1ADE477E498583BF414890D5358F9716864717D
F6CBBB2F4AED42AAF1E6CE60AC84210054AE4AB3549002B46F39702EE1D7D9BE
F29A70197ADCBD48EB4DB7EE8F3076665D9AC030977A8E56BE8D28BB909CA67E
88669221310635208F9A92413EF7EB7C39D64056DA558DFDE77976782DEBAA21
94F3D7D11E0ED60CAD817D7081B7DF36C12B7FAFB9F9B5792863C308629E5B77
BA1A829C66D66E771A376EA1465CDFF518D7036D7D88AAA269781D3ED38276CE
A6CE4AD2C150C2B74887ECCDD2B4A5E165B09A7A11C1AF06543AE2A29C5E01E9
53CC21E2F830762F461A0CA9BA7F005498BC70C535389394617C0D3EAEC5C2D1
239DD2FB661E3E3B51D8AE2F167E5B06A8116D23198440AD8942117031FD75D7
0CB3BE2668D6BF90BE614636913562E7E765DCD29970E3DDDC5D53F25C5987FB
9292DC43A8EE1B87F6C5B6EDD7163D82F1BF96060320DB4AEA46D8A4E1D8AF8B
8E7EF6C70E87B433DA38C4EF49AFC25E58963DA8342FC8485112A1E58CE31758
BB2D19A7424D9700C509D03E6B7BBB7A0A4486123A6487FBADA30D4FE59B5696
B4BE4C5B366BD8C7BD29E17D3D36EE78337536C75AF5109986E62BD1C1047E8D
799D2C82BCD6A0821F6CC8F541903D07D2608927F1B30C622E4D6071D160FFC7
EB81B80B670615CEAC01943A674B9C72A01C5E9D8C2DD5611A49599B8E01857B
665301BCF30C5282E2321D54E40112D137181BE2CE2BE25AAFA86A100404774A
3E168F1A1DA3F1D99EAC0CE08A622E883AA1363FA25405744C68698221A53F4A
2EBA466C5AB737DA87A26679CB38AD7659FF47FF2A4AD507F34A0A9C4E95DDC4
EDCB19F4B6B6154C7180A61A33FD39AAD3646ACB663A36A4EDF1780427AAEBB0
BAF9182A81AED6CB5D5CD15063A9B7F8FCC6B334407D604DDFBF13A81DC3B09A
5D90CFC792F21F0720EBA612ABCCE69E6641F019B2F56573EF52F92749ACCBF2
7C150AA8DB53ADFE173B84F8D94FE7F02AAFD391455020B671BB765249CC6C85
C9AA5BFF3B2391FB0F74AB133109946D9CE79AFF300CB14F7AF2D90DCAD3D25E
6F8B4F43B0CD80C64BC44DEE64113E2B4169499F8A73ECCC38436642C0E08371
E6AD2744C82E54891A0CBDB353D6D679A4BDE76883B1408DC6FE7FA5F6498AA7
ECBACE1E972ADAB3D9C45009B224EF60C12AD1A48CE708294A748B469F647F4B
683C42EE90A9C462FFDE1ED292C9551871CEAE18C31241FD05E95C260C40067E
59BCCF56618557ECCB09FD4F8BD59E978CCD82D57CC4AE08570E4864B4691482
4AA03D54C8D666921E325C33E283807ABC964546FFFC3CCFDB7A531C67FAE8D3
1DE7F796592551D5075B9AC1791641E56D5BE00AE9D9BEEFEC14629AF962B950
FE084C0739DD69970E4AF4DA67F744BE7CB34C2C3A0EE646E01E9082C1EF7EA7
57EC81E32DBA3C3C6A238054349A09A7A00C46C57F1DD1E0FB3C5AFAE899835D
F35565BFB8D97A5E042AF98882316469141597A5EDFDB3A6C08D5637BEBAB1B9
A72065C53DB8D4699A3A5AC6A5DF954BFBEEEBE49B78C2FABBDA570C28403E30
E1A5C8B94393827BD4743BBC05979A724F30B6966B93285BE2383DBB2D16D0B7
DFC76B9E544B8BA09EF892527679F44C1F39D90597C3E5FFCDBF53E2BE6FFBF3
CC39D67672FBC9B3989A3A12340AF474C94B7FB19FAE8004FABB3842CF0301BF
FC2D17BB6D3C1261C8447D19FDD0248649ACE0814F0E452C97B825EC53E9DA96
030F7B9763C9094C872C43C0958AEC5FD4296BC318A86CBBC90BA7066C9A8CDE
7B510131409045B96505EB4ECF2F73E9F9BE0B15947A2980FD1A946591D4472A
D665E043025A8554D702F57940E426739BD87CCBF18B87EF4D6F947789264A4C
30685D87B84E18CA0229289838B46F38F5D055038D24E805C1F7DE80818C598E
7BB29441B71078DAC6BB07B7F37C94737F8A1A57C6ADA417E3DF92D4346C8F90
5185E83AA990338977156CA6CB9BCBD912013889D35A0B7DC6A0976A5A6D4F82
2AE2232079EC035D252652FE782BC0E5120D699E091905CBB610EBF4D164BAD8
8E04998CE0AEA2992F9CF07D4ED30149E9EDFDDF787A7FD090541C7C3E712AF5
681739B5D2A970AE9037A27EC54B5E89150BBCC4B6C664AC5FFB9E3A293C253C
9C01456758B49C6E46BF52EF47D27EAD065E11E3B12997E9CA2287EAC559AFB3
5D9A3FEC0F1FE876FFDE0F9C3724A893B18181FF9FE0F570989BE1F476EA7540
E26E0108AF1A2A9BB9CA334229E7EFED6A2BDB342B169135C7BBCCFB45E6E40B
AF7D23E650A2AE8D83371A6E743EF49E66CB16ED928D4D5FBFB640780FF67B38
16DD2CE979C870A3CEB690A36FBE72B080A9ECD966A568184D91A5AC4C0C21FE
C0F33FD5C532418A29FB6462D907072F84276CE4A1636B38E5449FD300852FCE
A3AB54BCC8F09BE7E7600D688FB114901C4473CBB045B3EAC73183AA9CA65E12
990DD9A52F0D22F8AE4168A85820EC3D598FF0E6DE5449CF3442278D2D2BCBD1
77ED8281048C0CFF111DB1AA2B01A1FED6B2CF809B960D842475E91B4B2898CE
DF8FB7EBA003DCB2E80D58127EB35537932045E1207DF915BD6D4F90E26F5230
465EE9CC2AFE3DFB24B442D2F717B65FE0555F052E7BCF53C6CDF5EB30C86A69
5C6879424419A129577BB9BCA4759D77D7DE1A643A638594FAFA683DD6A2536A
615431AD04F1C9E6013BEBAC4CAD99D20E08289F264AF4C068C369AAE5101A93
4A3918D83FBAD8125BD82BAEDC545F5E7DFAFC1B1171FA097A610B722477C1E0
963DEAD06301A3F85832EBD4DE3963A84D2306F0A31C3BB9E4C641558B64A090
9DC3105E011DB69020F4F82BA7B6F299697153077390E9AE6A2495481B419BF7
B9D6E0404E2D254C4C2578BB1D507A7960524F605255EDB54D4EE891ADE7C76B
2A2030E35C9BC7A94D425E972172363DC7E313D91648A118A2F3ACCFCB74FCCE
65D71FA71B6A9433AC9D02E41CA242305AC5B678E93936034AE6FE12CE41357A
0DAECBD9F2115011E1CC07E686DDFFD635F90011C11ABF7DF772E5AFC6EB5181
05E23D7FD6D406B81445BB84A6B0EF830C87E1C441EB8AA10FB2548359D9EA19
5C0D0BEE32EDF668653FA72B39DC784DE67E5CB00245E81C0515B769BEB49AD6
EE977A9386E4D2B60334FA02A3423D5DCD020E196605C4A66144F8A7BDA68565
50CDC50BDC80C521976C522E8ADD4E8888C5146B5467D3E953E5C597006CC0C9
FC0150436D2AA6C88EA60DFE7E9A977EBAFCBB12FFEED9A69E0E27ECDB954214
0CC7BE35A307EF116437B616A8D99FDDA96FDEA38C00BD1F50191387F2FB31F5
C71151EFC1AC059F2A8CC53B058FDEF9B70C0EFDCC0892043F2289FEF834395B
89053174C3AB0A7E5A2A72CC29F6C56F3D118F74C9170D357E6B8FACF0BC2EE4
D8DD0A692DF4DF14806428ECAFBB48F6858D2DDC3411E4BCEADB691503B2EE82
359D11F44FAAE0F714EC8685753F610397281DB0F4EBCA851F4D5ECB460FCE4C
BDF0AFC74F443D205C92D80AEA070FC7127833F05C97B46E7E30EE5FA3F39AEF
B8D016A9A7514A1F894E0C4622809CEF3EE424586D53BC298300204A61F387BD
6FD24A39614EA49E2EC4B061D46B10452C32C9F87AA121B63F8D429F520505EC
21ABE618E68F3EB2B827999175B8A1F5A0216F83AA0B2AF5FCAEDFA4B2C3F306
FDEAE235918823D515E9682A823EF69638BAD78F6602BAA9EB226574128332C4
34CD347849B6415D073D2AC97F7D0E98A82736A1DCACD1D279644D78EC23A882
E5A2DA8EC133D96E01019B102EDCFE62781DA5D279F318B76860DEA590491ED9
2096D165028AE00728AC07E84F5C11CDBB112887F19EAB868EF13FA36427C701
4031C5C2DB7F06A9C22C5FBD1F2812455C58503BE61565A24F08E8453215A042
06BE003A728985588A343720A345217C888F55ED0AB8000C7FB7825CE5A662B5
3E846A96BA5369F341F9D9038FD7554C1B8B958E199D14C10108838A29EC6991
D1C86E153BD684E0DF4824A3C035FE6B55BEE0B102FC0F7E7BE0B71798BE4774
EFA0A4D4A97910BAB76800D8A5211C291BA6B1EEE9526BA53463C5369C290333
5960E72AD92E299404BEFAB52B4CCE46CDD163498560771B1032CE677476B66D
88A72FF52FC8CE7EF5F248432BF5855B81B585D789AFD1B283D9CE60A7AEB086
143494CC4B91EB5BD6903970F549429763ABB403F6F90742336A6D6BD9C716CC
988EDACE99579117DCA4D1663DBF042E15CCEB7BEB72F7A3697BE2980F4FA15A
C1522F8890341B2E5C90D19F22084B8B1EEAC175CCA2A7D61DE42E58DB5B4BC3
65B1E737E617AA5C21768A2961A0CA8161AC7A44273CB9CB9AEBDF0BCEA30658
7256384BA181481BB03694B4A5EC25BD18364AE4D7795106E8D2F7E97773D4BD
DB71892E4DBAD8F2978F3BA88657FA6DCA4E723BAEEBB56279E0E3C8C9031BC7
00DD95E405957E5D493A1B1DA5D162E10DAA090D6ED626C122D40FC65CB25270
2F7E0F7013C7C375E406228D2D7B2FB27DFCC6263CC22386F8F83EBC70894E89
3F42C5CB9D5D873F351A2955340647CFDD1B7D024A2F3A35E3FA044C3A65B3E7
7513006FEE7C965C002D7931CDF5AA21E462C161FFE2BC9CB112E2F6B44C920C
199D9B8CBAE16397E19C327628516E60D8592D5751503ADE3E354C87078BCE82
915C5DD194980DD7F74BF5613C285C7ED74C0BB154F76804A562D9F6F486296C
276A188D28E6FE166C64293FFEBE223223CE84145A5A4F285A00FEC6FB50BCC2
B4B1266BE1C910842AEEE4DF9571469F4C7BF8C4E737FE7B9978572F965DB56A
2959EC66D67E3B4C1B556654B5050F0A0F0814216CEFF35DD583B52972A69790
48ED3F3754130EF6B3653F5879B110B5F6EEC11AA1ED49EAE583CE50ABD81856
28BD01855A2DE0C6F6D321ACC0723B7B18722B79C521E0E02C76E57953256317
90341ABE106C6190B72688292776E17DAA3930959EFA4249EB4A76991BAC2796
DEB5A315092D591A0439C66E2146C6285AB250B8BDB9F50DBC8FD18C42EF887A
ED046BB0F9080ADB4B894B7FF96BC205B509DCF81BF62D35959A288ACD96587A
18EB547FA03B688FC1D3B68C17CE2A9BEE993270EC0D00BAC8FDF82E5EB727E6
5976588FD419EEB137665CD7A6FDE0D880890282706212AD9A76DF5E13307CBE
CE49245A87C4C5F3C5C9C1B3816282BB27CD09AE773FFAB61C03FB22648AD6B5
7FE8D2AE02782690263555D16DAD3A3D79C922FA4C0FF5D87B0843D8FDFDB993
D49DFEE1D1D73FC833437493DCD0F968361B63A473B74323C97D3C33164ECC6C
41642205FFFF8DC8DF057C716426303557BDDD1A9CB561E70E17BA71A81050B7
9B3FD15A6C9549F7C9ED554DC40D9445C9DFEAF9A79A5A568A09FB8FEE021FCE
9197B367C384CF35562F50D0C8A1EA1FE124C238A99C021356E6159F41F4A0D5
38F335E9ACB91AA2D2E43D27D94399793DAF6C8BA46C48E989768A7B104B271B
4CABB67450512FD0C89DD61DEEF79DD16E7B49007F17D5684855A3F7936A8162
E5AAC35C6BCA84E67B89808F4A83CF8927640C1DA5E0E3EF517608F25F210F2C
ADB9FF3526C82B7903D6A28D76DCCA520FE0C9320834F6BA7B1A7F9A04CCC663
FE2E6738A46E57D7298C8EF4A2581056FBA4C216CF3941048B89E4585B1838B8
935B21F91A01AA4AA382771DAA9CB116DDFE570D15B92F6C6A7E3C1976987518
D59164EECC22879DC6197AD4578A89C6B0B70649677A90B32BF05127F16128D7
CC5B9A348E42D8EB71F754A8881C2757F285030143720E67EEC888EFE4EB0061
2C96BB01155A24F7456F6220078CEEC50F1170998948DF22470BC8B2BE7CFF43
383EA5DFEC205269260D50A158F4C41CE15A198B98C2F44A120011F9ABC24D2A
92D3A5151F38A7CB1F8BDDB7B08D0922921699B5EB0529C73F95370837F3BEC3
FDA56CB18C7CC5F281C422ADF225EAA76A7D636A49FBD5FEA7342298FD3A7FFF
6D98B2A548E54BB3554050FDCA080823C374CBF082323546F4EB6F7C36DA49E1
5A82A42355FA357CA5E081E6A6B18DBED2F3D719413EA86F2415F70E1BBED385
3A2C3833ECCC22E3FBD056721EEAC02A655755CBF8D680F33A8DD2E60A5C7F00
5C605A26656D3414C9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: DejaVuSans-Bold
%!PS-AdobeFont-1.0: DejaVuSans-Bold 2.33
%%Title: DejaVuSans-Bold
%Version: 2.33
%%CreationDate: Tue Jul 26 16:57:48 2011
%%Creator: ,,,
%Copyright: Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
%Copyright: Copyright (c) 2006 by Tavmjong Bah. All Rights Reserved.
%Copyright: DejaVu changes are in public domain
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DejaVuSans-Bold def
/FontBBox {-2190 -850 4045 2406 }readonly def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (2.33) readonly def
/Notice (Copyright \050c\051 2003 by Bitstream, Inc. All Rights Reserved.\012Copyright \050c\051 2006 by Tavmjong Bah. All Rights Reserved.\012DejaVu changes are in public domain\012) readonly def
% Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
% Copyright (c) 2006 by Tavmjong Bah. All Rights Reserved.
% DejaVu changes are in public domain
/FullName (DejaVu Sans Bold) readonly def
/FamilyName (DejaVu Sans) readonly def
/Weight (Bold) readonly def
/FSType 0 def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -85 def
/UnderlineThickness 90 def
/ascent 1556 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE366EF37D4823F376DD9F7E4CBB15
DA8E93E91E84D36BA5A5B06F3A46B45692ED11C8FC76C0B0B3157F699878E2ED
D89511CBE105EB42FD76309DA91EEEE85F1AED9920648285111A1690C4AE2638
C0601A7DBC8D2D41CA8C4F9DC7A6AA5C51015D8BA926831892381DCA7E61E230
5BB3BD5632D276B929D97D4836F9703461BED94450CDD2660430A0D13F49EB47
72EB0371E38B92F488FD6E19C944811D4AA52CCC359210320B484568E5060BC5
4D2FDAC73C49BA0168FB5B1B18DA73B90B191ADB82B09D7A67C3DAC2D13FEDE1
45CDBC0F8F17D1D543AD5AECA75F87F1357614097D4EFFDEDA1A36CE8A486612
B3EF4F5A222F0F71E90A41BAB625FD7AD0D3DEA015DD625278FC10E64C834500
5AD3D53491D89C3CB2AD1DD61A50E77FA907E78F83ED8BBD525973FDD7350FCC
013EA88C157192AF5716294C7C2825FDA1D3F0F814F8DA6FB78EFD67C5B98830
A91FF7833FD1DD757F6C2788468C74915181890FEBC508A6113E5B74D48F028B
C38D429AF1FCF32FBD068E600862B234C4146F6BFD70FB11921C8847D549634E
A00862573E1FA6B4ED8919B2CDD526D886DFAFAC21134AE8D24D34C2D97A1352
6127AAD9C80F282797D690DD647C7B577DD87210D34804C3E5CC0BAC5CBFF170
1F19581F26C8C79CD508DE1F0BF469F71093B258A2F0F82B7BB8B8BF2B96F6C2
45338498AFA7E66C8DB86214910756EDBA9CBC0791A8F87C6DAA8D59FCCD1A7C
A11D5346C002065E37A807CBD8C0B9FECD478D17D0747458AD64CC00EDFF0639
CBE694A540CAD0468369D91A641C4CF21E948ED67F7FC1513ABB59E215DA95E7
0AFAE5CC68AF1E35BB9FA7C0697FBECF9D0AE48B51CEF1FFC7E5030DA66C0892
F68C063331B7536C0103A14FC70F4A51229F060876F0829B6782B0F1AFCF9660
4682179E1BE2FB14180C9E29D170CFC25CF2B87101517E4CF04707AFAB3DA92E
EF34DF200B835E20AD9CF2F49741DB75A405C423EEAF2374C5813140EBD1DDB9
A47298BB632C60EB44B4CAB21DAAE999B4E4ACC339AAC0718EE2AEB3B024B1F7
FE1642E833D9E2C898E6AD3609673E38CA5ABDFB8C76878EDF41B45EE600C900
3D210AB2B2F57F60F55214058E7055BE35C4C9202FCE36093E544697D98BAAD0
002976752CE366E99F89FC192FA163D5189811CCEE79063198ED0EDD0E7C5FA1
06BEAC58447163813F968D09F959B63E938261608687FDD0E7CD887AD8FCBB3C
8C1DCD023D8B0F61131FD16E4731E0DA22092F8C5813FA0879ACC597936DE9B6
A2F6D77BEA550B299DFE3EE42272B9A87DA47A63ECF764D17C0D9C6950249FE4
1521F6C02FBF68FA5FB92061FA4CCCDA11F1AA5FE22133F3ACDA35AA010DC226
B8AEAEB4E6755426C9C8671C2365B9A42913F2D8A35E050BF4A1BA0B7E4E5F7F
21A0033FB0785E12A52B857522DE2FF8767D14C0A579018D8C41CAC8AF7628B7
0A3CAE721A7F9CF4217E34B636334495F8FEC970438A2DDEFC7400384BDED98B
6D3D15BDEC875E0EA1B88CF1CDE1D5A33630E8286C07DAAA5DF060BFDA8B1632
9E367D55AE43E762FDF746818974ADC2730669A3A9F5FE526D879E17C39FFC9D
ED4E52123E6877FF288514D4A39328FA2850BC1D5B41B35E211BE9373555C447
362BEF128DF19A87FEEAC9C893D472F5F6C012E31D4F4EFF59BF6755AB43F211
9683457FDFDD1FDD25D5F42D762EF541934EA31D18FC0A877D6532CFEA7F37BF
8B32B1A10023DC2681EC14796B6DE1CB3D7DE300D32D81161C8118DA23E26211
F8A9A414628BB1F809169BF5D700FA528BF3690CF677A21C0DED54074004B569
6A39274891C29DCF871E419296D163EDE0104BA91AEA264A8F4A415CC51C325C
C66D523E6FAF6630DA6EE0CD97096D24FF327247462C94DFCF1331B2BF31F2C8
053733232BCD3CB23DCD55B24EA49C785D42D30330D9F3678F1D9EAD37CD372A
FB66CB45E6EEC2083FE207E806217AF170E1D56255443583E6A180421BBA2921
FCBE0114E2B7AAEBE39D9BFC42FE5A057F94FE84AA385AC8146205E81317ADEA
113B660224E6D4C3813033A5CFD432663547E94F63BB02D47E9D8722C7B89FB4
2CBD22C7FE1F9BADB223CC44883EC05BC694DA9BB11AA1BDFA26145FC54FCFF4
B445164DD0CD6F2C4E053A2F8E7B9B682897EF44A4499EE6E62BAC596CA14424
4951DAB36506C55245E1DD7B8395345F8CFB726AD6F1B57B774759C7DC2A995D
D5AE6639B21FD8E0F898845CB8195E8EBD2F4D510A5DBFE41248D073AA2BE54A
6671F91A977D9CBE74A2B5B24CE47F974B23E849DE725094D024B220F21A808C
F3FAB02D82CD669A8EBC62F74A37B342681F06DF985D88AEE3C918B510F1CBF2
6CD00107A152B152A0E295BC212F8BBACDEB13164EA947ECADE1630E91441CE8
4E29D750E0581C886A574CDB318CB4B6E665C6DCB63B09D8C81CB87566F6003B
CB83413D4C6EA81B5416638AADF08DF505C98EA57C5D1CD8D018C1FDA7F154ED
6D72A246846B95824193730C1F72D4BCB70DC44F8FE699C036FCFF766436A78E
90958C653AC7F22510647465774F8543ABB4498290BB8C3EA62D4A8BD66C9572
2CDC78223D2DAF811CB28A1D903C8DB0C50C1D2C760251EF586794413C0CCA4B
FE33AFAF0BF9CF441A33B2F4EC0E3C821C6CB056672CDAEC54EF41BAA6FAC930
D09F90EAF2AC1E25BC0B317DBF937CBCDC789BD7EADC443CC55419A0A1D8F8EB
5C62463BD1F0AA42F400240F01115FFE139FE569CD0256EA0393458E6208201E
0AD8E5EF2F2903066486717CD774BBA337244FDA023C8092E4DE58D7ACEB291A
BA3CA26EF93D589CBC440746408BAEE2F5DF9C61CC487C4821B4A7F94A9E90E3
B3188A27A14BB4733AACE3EA832CF3ACCDBF350D5346A279CB52B9CD3F760592
684F9BD1AE3C6630675888351B5946FC1B112F2C971E31988F477E24A1A06287
9EB580AF3E3977BE74F9FE5BF391688A852A94B2A4F0AA51F07DCC9AB039E941
51C05E7728527DBBFC177799D95DDBC0E627908E190A1DDAAAABA515822959C0
6FABA7EAC0F63E93039644F4980F2DB55314BCBBB3A2DB2944C6F037AC4C6B67
E198F1919C718A8642C61DF3E0FBBD793C74CA55BC3E895D411390A3A93B15A7
30D792EF3E2F81E65FFA12275C0D0FDD32E5950DAAF57F84BDEFBEF56DA8130A
0EEDFEAF967AC1D6E3AF2CEA4CCA0FB69C6C3533FF69CD14F9DE72F680C90022
33322B77940270DEFC07A14D9607315662B83096DECBF596FFB88CD9DA174B49
171822BDB1708BC554DB26CB64460563571D37119B45B245F18224F9A7C7D230
B8119C55275CB704370FEED822BBB453AE02B53C48CE0274F3782BDAAF327F22
D3477E5F9C6A58C898A2E5E26FE01340D2300AAFFCF50AD30BF4090832966C62
D43B073277EA702FFC439E066A2C99FEA6B9C0350BF10C529CD2CA6CA265220F
DE3B2CCF968DB7137C364AF286F5269C1BCDB0C7126158D8DC52C165BA30F2D8
37414DCE175437850A1C953982ED07C19D3046A25D83447203CF66C626B0B006
85686E42794449A86D85308F884E09423E2F82748F485AA356AB01970524C290
41CBA30E78377B0BD31ED6253872456B1193C586385C5507204E8492C26479A8
98A804D1BF9FB6545BBCF347429E280000BC7CF90AD8EB70E8D570821CB7E543
ED95CF493F28972EFD6E3032E7025BCE05CDC7A923501C2212AC23E4B3FC841B
6D279A893E771E551B5CCB46FD2071C96E7F6B0867D82769CF28AAAA904769B6
319470FBB4CB0064625BF3A9AFABB58F5D2653D6F94035C478B4A28B164B9C00
4F46D552F6E501DEC58C72D07609A6E654EE99796CE6C3AEBAC1248233DE38D7
4E6421DBFDF01053D4DF6F8FE40EF4C5C93442A2BCC5B3041BFFF32D91895526
5407F4F72E7DB26C8BB4B3EF602C6CF17D2F6C797780A0D9DC44D8481E38C6F2
804F802F6D879525B43248ACFA68E621070E6A1ED47EE2A4F1E52EBBEDD754C5
1D00B098900486718B8CD7E36EBBE518976BFF7BD30CF042CDA82E642606700A
F164F1BA9F7F86BC398D2B295BA17A306D8388BEE417FBC9CF5160147665AA1B
F40A6ACCB2E72ADFF2741FF78C37E4156921C5941D01C4DC8E277CC7010D03AC
DE8398430C3BCF41ECF5CB72CA6902861D528ADCD5D05CBABFC4AB26A8F8FB2C
56869F276B64E3C3D1859ABC08B353A17D6CB5F79B6E5909689EB89D5B201336
8E2612259F1F394DFCF7F86F7A8896579E9132D39A0922AC961776E6660D7242
6B16E1471DDBF292A46604780BD99347BC1AE60729243B6FB6CD60E470C70A79
F0FA91BAE1DD40AB240469475A5BFD8FCAC2ABC7FECFFBA90C1D9E5F1788BC04
45C1ED23DEBB71984B87110564843B6C6339CC36E11A58A6BB33ADDE33C12864
172F3E94B3EA0162A4D609129F4F632CE30A10CAE523295CF2942DE47F05732C
528BE791A9B48F81B9A163783EB4AAC48812136030AEDFD86A120AFDE9E5AAAE
6BC8EA2C3CC58CDFC4D615C7BC0A01AC6C911600F293B56D3F811D1158067B51
AB32610764B2AED472B888CA74778F11ADEE8740D33598F65BA5504906EF0BE7
8F26F75DCBF43356DF7A3F0D7A222F72A91A8E5850597E03DCB86DD6EB02C53A
41830D3315E31EB7A2AE58ECCDEF7856341ADE13B6688A7ECA3CECB41C2F6525
473728348C13F832C0182E4FDCD3F641A7E8A31B8FBB8E8D33D022A02D6577C0
D72B1C206DC3CD15B25A6E9F69EBE283F66799DB900BB9D66144EAEE94A5540B
B375B7A4BF219136D6B2B290A401DC82D567B56F8DC6651DC14A07EE72AABB78
B829F3BFF3B7AFC05B5F79DDE465DAF7A220BD49BDA13C4E9607D3343628C410
200A4C18CA577CDDE8D01C7E49CE620AC0451F4459742E547A6101E5BF262BB0
5483656898064135DF44756128429BA6DFDE7E286FC08E653A6B59EEB6C2BC37
05586A28620796DB6F8DFF93D1B420CF01309B298201E5F9651F77A2FB54A6D3
6AD8C8D9FB720992B55DEA8BDE224B4BA7FD5C994A7B29740601FF7A839E511E
916D4355D8EA35AE0972606E922AFAC92A684FD2B33C3FCA1AD533EC50E40BBF
0C2D0E2E213377656D565F184190A1D747F36827199E496103BB1F223B2B5A0A
036D1798EFECFB347C12C01F4F0B87C475F13FAAB9DD023C8B48C17E394D7302
20A930D4D0C922DA595A83C96416C45BE0B64FF836F95A27FC22C28CDD751225
03CC7883EF71FD418EAF37FAB41AFA7D3D4B2E7182BE72AFF3FAF081AAE02494
B60B240892D3C4DA4A0D8A346616E585BF8722193EA3F86B1DEF9CD61789B48E
C9D9E64A2648CE2C2DB022AA3ECAEA561A4947A507E7441C853668409597B131
CAC907C4B5D1CA7D1534F24B9B14D318F8C1038D10CE29E389A4652316252CAA
C4D440F6E53BDAD5D6AAF512CFC6E8953D4B62571A15AB2DB9FF364CE109A07A
92337C8AB8F12F8CC797B984124EED5B256BB6CAFBD9064A209CFCA983EC0DAF
D92C8CDF2FAB6D7775D472CEBA5994192C2273A19C428192CC6B1952071FBA6C
CF98F059BDC825417D2EBEB42EEA05D4B883F7BD32BCEEE45AEA83688173ED49
A256E2C169E397AF41170A97292FCDAA066EC3AB7E775E1898CC48B5B594C8EF
50C8B8D37C2664AE5D93AFB80C91A5A3EE0981F626FD08A3320D1240E868AD41
CE36E9D00463827EF64E0191A1F43FD0EB2C33ECDDCB91B36ABC62959D305CBB
4052267696B3FA0C05D665511AFFA6BE2334E351F645521F5D4A00D93F0916D5
A75E70103E902CFAEBDF3D4DF181A5AE5CB6D2A8E6C67F556118C12ECF542C66
A2849321D3031D8DF6D0E2198ACA2F05917EDADB898961FEECAA49F186834F08
1EA181B8C766499A1978179FFD6395EA6000543AEE6BEA93DE80A91D7C13C19A
AE6CE316A6447D498941817F3C29F779B2AEE8141496D5C56BEAA8024AD360F9
F0C536C22BA4958745663479675E50E9365B65C69E62009B0AFB932B370BE6E9
B0467824811BEB9DBF0D6909CF2427EF89C800870446F8DD0CC54B6A8D65B9BF
C06AAC064BA21DC8C10AEFD9198E74C85194B7FBB7A50AD1A74CD3CE8F09AD58
3BF8F06C7FB7D40E140163FE37C1DBAA99BA3A657883A8493F5D772F522350D9
B3AF1FE045BE8704EF04BFF037F408CB48B7467CAAD8C85A1A478006062FF0DA
56EC50227DED1C9B13BA57F9C64DAEA531F9E1FC4D43FE47CF827B4B3A7284F9
3A5C7427DED53F6AD2A3425657A4095B0C5670E7471AD0470C1D2810CEB245F4
7FA5F5B179ED5F65086F65151E91CB237BF883B529BC0E7ADE95B8E925F4BADE
C507DA2C907BAA1E988C7AF1882C4F55C0DDF139B21069162354513609CA1447
F57AECE54B56082C147FE92B0591BE817538786FDC4BDD43B307F8FD86C95CE6
C200C24FA8875285405A27C70B3FFD619C108077B3C8E67033FA851B6DDFEF4B
F653ED3343A1FF1C7B87D5C307E2287C5D9B0095EA7F861A33612D7F24E06993
8933BB77E81B224A25C8C256877EA0D4B2CA1BCC077E93E55A35E6F13323D4EA
C0CEE0B349A71FE5F7EAFC015E6E449CB865D74993C4B83CCBAC29E4E35D7755
2A096E48D8519843E1AC055C19E403E2D654B196D31A9F9D6255F85C27338DF7
38970913D21454B41EE3640FEEEABF2F005C2B12A8806E966EE4797AAAC5CEF3
0F381285D1D430D36E6AC89E8D944FD4A518CE49634ABA08ACACFF700FE3D2E8
59F22079B78391009ADF658A59DC00B914DDBC1E1777431CE94C4ED580F854BC
6987CFFBE282039CEFA29035A838CD5689246143B1A52B91FB63AA25A2DD4E62
7F160CD7DDEBE5339AFEDC22438D9F64B419E71FA3CFB2B5D39AC7A64D67474E
C6F172A3C3652BE2FE699838ACF310FAEE829D2EF587BE4D217B2AA72D54A98F
6F7E05E28B6FD5E549740734371D54C3D731E17511C9767873DFDBD2E8633845
776055DC2BB3B5FBABEB7D87B13296368B05CA5574C9FF47ACF4325414FA3767
21238CAECA05FD2DB920783626794792E7094D7E691289CFB396D3ACBB0D8CA6
44E36BBAC6A364000311A2578EDB0393914DFA444BCFBC9291EDEE75C3057122
F38F8967FB4BDA12E833058C6F089B65359487B1C4B4013D1F4D78300C2F1118
5BB7CC2BEC0AAE2EE4B9B9699C15E9A66D7C178C6F27E9471A37E236F24FB650
1CEB9550BAEA9CF1B97CBF9A522F86D49CD9EDE851D26DB01B64D9C13F1C56B2
6F11C89C835752CCD2BEB163AD35482AE0A4B48BDFA29DA553869CD3BFC9CA8F
DB78FCFF0C8BAEF7A68B709E858AAD49E6F1FA89376B44495EBFF3BADA04837B
52E121797A84C97A5112B32CDE327F001ECB35F0C8E1D961CA759A42C7692BE3
F6FC471D29AE4960CE715C95C480D4BF7A42683EC266ED31F5008F7275E07270
C810BF51961BC443D686190438502039B6C53F031A3B203434593B55469D1A9F
0F823738CA8491C3F035CB74515BF726E97B978638C449DD288F0623C9655595
BBA50C59213AC69D40FC84ACD169B03CEB1038912D0F7178B843775EF8335DAC
564ABBA3A2CFE25589D5B59FB68889E6BB7B712720885A612FC9301E212C3A20
A88DC7277DB501E6265F681788485BC849C42F2A04AD6C1364C1CCA0D89075D4
3C1CF88A002C5CFD53A9F735654EBD0F9CB184FF4D2391B2732E7CC5AA0090ED
6B76C256A0997FE89F91F9B5229A523FEDF961B8C5685DC70A37C592C559C0D7
A49C8949CA188279F4CA75BC4FB3C8C7C603ABADB069BE0D1BCEB64F72F4FB24
AEFEC13C447F701B97848F223CA4DEC8E1D7CEAE29C5BDC7E963CEF8CFA34D66
EEC8FDBBC9C69D19F4DA648DE53A4310B05AC2BCFE82D329D0113078A44D8FB4
69D50ED2EFA77B5B5F31FAB04E19EBFAB92073CC036BA161251B2F12523757F6
AE29273EEADDBE9C697C5D32A76F096ECAAFC065535AB32B291DCF5DE1745E80
0BCA9FDD7F16E43C168230EED2D7731E2A6B122C6F57790C42B0368AD7A499EE
597D0E46716D81039491DB446916FA5F10B5FF1AEE19164764D83577FFB50B79
76A5BD188036F0ABB66E28F91A54F29EB0FE77777DBFFEF862CC94CE8223729A
2C7FD9A30D9E8FFA9D0A9D090B86A2B91B81193B194CE8A149EF9121880DA9C8
9FECEC969068C0404CE33EEA95A09C7B64F45856AAA4F80B0C2D370050724268
869683C4FB7DF2963032947A51DFABA0DA38695B524A6C07661FE6953BB4C0EE
F805F7A0245A66E4BEB5E239B928735B7F0C81CAAEAD8374642CB6714F585C6E
338F5F95A83E021A513BC9ED89A17D8CDE9B86BB0D7806B03A4DBCE49AE5947E
4F61E7EC67CF781E780A34EB34F4684FB801CFED4867FDE6749682D184744EC8
74D3D1D6B77C9DEDA618AC06D38F217EB643022F1DAB3F382F3322B99175BDC1
EE68E917107A0DD9796C2B9F41B88C3A7E69FAE980A89D90676B111A45C0B698
56591230B56C976D54AD5BCF048E71B153C895E36FDE59445F22F4156E9F8144
8074340CE4D9624771C616295D7FE2B1982AC22BBA48E200AA6D7FC4405F9BB7
DA19376CC87865CD10FB51F8C8C447B886C99FE9D0AC869C6A9E7EC58741808C
7703070EA4A8A3AA987A899E28ECA0D1703BC50A57DED2DCDFA3483FA61A5778
B4E8D650D9E7FFA76B1BD86D7DBE8029C49FEDFD6129FC940D418CCB08578988
AD769685EEB4CC5178384381877ACB6AB41BED3384AD7695D4D427C4C26AB6F1
8AC800EA5A6A8EA2D14400EEF9674E42C41B4A900CE4A55A457BB8060096BC9F
6FDDC66E5EFFA212E3CA8EA174204C9A077E211CDE0CC7BDA200DAD0E429760D
B81F141FD4735FF6EC2BA552E909B8764F605C033F40ED7207C8FE5F7BEAC939
D7829607D558D1407E6DD0E2252B9AC47DAFDE1CBE7E9D3597A3F5B4CA2CADD6
114791A80D077FE7AE2463F40DA89824D1C5D17DC70E135CDC940164A8FD9C5E
F6BA97D75949E232995ECDC83DBE0F6B6966A3380F67C084786D192891C18FC2
9F0DBEAEBAA6412B6ABAE22BC84F3B2F41285EAB4720FCF952E8F9DFC8C9093A
07D46B3102148B03F0B16A43C6EC74AE271326689E007EF544C2324DD24A7CC4
2F526A3537EC6DEDAF60D1723DF115C7FCDC57DBB59326C679F654F27464C3E0
4E4B15FA6FE9D0EF916A1BAB1BAB43F14CED19142764D33FD6BD4601F84AACA3
7B5B73E8F285A967624AB240C4186FB5E4720060CFFC8705723A5D49D049F420
266F034B72EE3B707AFEB064F4C54CEF25313CD7BF2F4750ED01F4B464464201
E231AA18D6C51D9DD3D307ABF939BD3783CDF91768ED4AC93D2F55AA2CD890BD
D9EFE44569F2A13CE28060239EAADD0D24164AC3F8505DFC7A4862BCB5663691
CE1FD2D967EB0A0D2CF498E6AEDEA2D570E3B399E218EF1BB6983C110BC633FA
055A8BD89EB2825BB7AA6F3FF70527A6E899E4C40551FDC72EDDF854D15501AA
0E604200A17BE95970E062EFACBBE9576536DCE6F520A16FEC6BC543657B58D1
7313B32AAD5500E8A10087FDE1F2172212BFD4C8A0378EE57BC2BD10A7AE953A
27DCC944789814E46E0402E819132B0902D1B7DC4E7E213A1AE9C9B5E79745E6
A9DB8D45F1EC553950CB64BC171545AFF69972E5EF2B5404861C90507FE2C421
21FE392A500D43A3A0D8AE81CEC8190320BFBDF7A56B29B7FA10CA7213829FCE
AC430A54AAB1C2701997E6DC26B83665DB71ADF03DB565CB3278F5B54E743362
31E9136F61962383C65150264A44318843ED7BB624069C9C4288D7C772785564
E019F13CA5B948040B5255F62BD2B6A93C68B79E9026102990E062BDD96E9F2E
802299F67905281285F890FF78C7D0BFD1AAA123EFCF45309F5B757C45825D89
2CD59B06238B7079E61D6A98117EC713669C2D892006857C05FE36D27B51631E
67D2F5764B170C502B9CC65E56C1D4B87875ED658BA073CAD30BD9B4F874F7A7
266220F494D78EEF9EC6AEE49108C3C52C37681E0576BDFD3D742E7F1F8C0BD6
C59B70B2BE7C3B42183285AD7E0374C2B351F6218510D76A80E8001DE85689AB
3CB216A5C27D6283EACA7283F24ABC37257028E45B97B452789212EDC313D44A
42CA6D67F598EAC5797C40BB6A3A189955679843F0523B1B4954D7824EDB3D0D
8060B8B46550D92ACEDBBF31AD238989680445290589334AA373CA2E11E25695
176BCCCE40CEF9DC27F40CCD9E19A6ACA8DC227D01B25E95153F1E5E45AF7316
F2FBD0EF0231C0E765A7A2354FFD20B176ABDA26B69F85CC9DB8D609FCDA2FE5
D1438FCF7A39DB9CB860F82CED84C5C59E5827B08462FB8027448C1F8E11CBA5
F54AC4942BF7FB2C4742A7B78C00AF62A98E0CA55C2EEB38B87FB943B7975A0D
EC81CAD218FD0987379A4770C823212EBCCADD52904AD1F80D3A3EED3D68E4AA
28C1F66BF75ACC0DE80CF6650B6D0A99568321E21F4746BB232BFDE953CD1210
A5AEC11BF62153D0971A40FC652CDB05A20DEC5AC788C511C6B90E42206A9797
E1F7DF90CD855751931826A17BE32480DA64C30D35B103D73176C8E1606A061E
66067BFD1C2CA430B81F6B3FA0BD229C4D853E4EE35CBCE04015C23F84FD75CB
36F23C0BEA5C55AD278CA8D551CA2E4DC170914CF1AEFF0134CBD746FAA066FC
4AB756A2F86211F5FE203CAC40D94F2BD258111C0E17E79671022349B36BDFFD
0EB2DDA0FB62342B53C34011D7B3658AA5495F1156A198700ADDEFE2B3F74B7D
F109DB01677AC4260AD77DB005D835B04DC328500DBE2E66A12BE1B77757E92E
A2F51BF07A285E26A452F417D271C27DF1491BE959F1418F547082D175022311
5919DF202D5ECC5686326957B6CDF4492CEC50E13EA4209B1ED5E8434335D76E
0707C36ED5E5C2EC7E59783CA76283CEEE28EA85B42F24249A929520F0BFC0D0
DDE69483F6BEC62BCC68BDD3CDA354051A4A85CE4971721ECFEF5E1FA652B186
6053F407F162746312D9974ACCE287389996F8ADFDB55047C96AA415EC01706F
04E5FFEACBC97E58243D6B5F8E2430924E899FCAAA9B1597DA9B9971B8235D1C
1BBF53018C25B3F2E25D3DAFB526FC38FFACBB6D4FAC8D640D5B1717F9049E70
3F141CD9F941750AEE0066B3393CA2F718E33A4ADEE772D8E5EAA8AE7C4085AE
12612AEE53062EDEA1FF90549DB961A884AABB63BF1F45EC20A39E66DD86CA6A
06E09B3D15E6D1D6EE81D4921C180302C3F13FAF7100C965DAAD2210992E8C11
5F926BB8BDD04004EDACB8E3A59EA8E5401FA6479DC0309A89C7883797185548
8EB553FD313FBA70F203637788D60F25477BB0A4AB34065E12B18949F74A9AF5
1CF9124298093CFF1B92CB37ECED5D6EAA7EE2F3BAC8EB0D0C2409DE3AB806DD
10048845CD4A05AFC37197CBA2C0B933584FA583CE761B6B9796FFA1F6DAB437
860D288F7032F1E08E9FB1DB7CFAF34C59837419ACD9093FA6290A48624FDFFC
82C32FFBB216DF939B86D7D8B4559F798D5EB56F41B247F3F197633EB6B8E80F
EA80CA804ED58CE3A2B8DB5A139A28694C5B5E58C756850229C47FD739DB4DC8
5F63AFDF9C19874C73D81314831831C3AD16C876562E07317D5C474CDCA8544F
8F591399753C9CF512A8ADD9CA51F6C002BD26D9A8026AAE833C87D6DD41384C
155A789B656A95E21F352F5AEB1084427E656E573F12EB74C7500029EAED9CBA
434630502D17192E28868FD4C3D4D2C628BE2EC0515363CD66C3D0B336667EEF
68E82016B112AD6926C26D20DFACC9A51E37BC449BF9E1E5089959A50F02F295
51E5A1EB7B0FBB137A22B60CD054B8C876EF509EF9F1C5095DD7FD20A86F9045
E8E7773F208B3F0E77F06E7149DF1E2D469BCF0E2EE9EC3CEF293BC330F7C108
039540826779E1E0CA4B46AA2EC3BC8D7AD48D47CA792E46681626445E9DAC9E
88471EB4140791328EBF8169CE8472C0F6AC2DA7284D3B91DDFF78EBD9419FB4
C9339C45EE19BC47CA350C402DEAAA79F365A299D338F5D62CDB193E0D078F16
27E20281C530F4A61CB06C6134053489871949704DC0BA71BF470D94D0BC16B2
C5A4361D17BBF7CFBE138F1CE7466E3BF4FA967EAA95A7FAF906109F132B3BCC
EA828BB41AD28D45D3E198CDC8A7CE86A668E76D3ADAF0314B61CB3ED897DE53
2796B42E8B69C3F64EC17027AD5C764FF4F6510CEB0D34A1DBC00DF8D6D2355F
AF837957EE53262C47B4BF4B7937176403EB77F959470417C12F8968FF666A4B
EA0E4B0D236CABCA08B28EA7DDAA024D1C76AF6F92CA947B7EFD1DC6550C3E38
10B5CCC40E91A101DE9A88C7A6249C0CEC82C1541B336D51F28FE08BBC4A7F8A
6116E733BA5E3497017A6E72F86D0486C5E7A7647B55273E5182DAD0A7F0884B
46D0F40394264A6EA23E30B3ADC758D76787E6ACED26EB49B4291FE913800D02
72426039D4EEAE1DCBF67227947E9DDE6F92D1C2A83C2E1BFEF556346B757DE1
150B441421331B671BA647C554FF77680EA6809ADDF290883487CA33BDCA0746
18D9C573405009D731E15A1EF18C20ED131107FC47EC0E33822A5317BF4F286F
15239F22FB2723BA77529492983A21B2AF226CFCBB4EF07352088882A6B48650
D146F0D65E6241DF94A16AD7DA00CC7C168C5D58566462307170C8C853BEE1B5
79931593E7FAE9802824426FC0D8F1CC46416ACFD62C7DD737B6B1B18E7063D7
0B75D564CBD9D1A388B17E69AFD66B5DD1901154F701F3FBCFEA3F156FE89B56
02CA663E8FB2414729C1079BCA4D259CF7286586D1DE7A316DC4B6AA76761346
D2464B67AEA933DC7DC07EC2DBC740F183EC898FD50C035320D50BF3E01E7412
563467E2C2A7D97E29F62203DC421AD7C74D783689665D67483AF5B48C1C975B
E33121D291E004CEE7220A24CD34726185CC4C48607805177E3A7D00E24E2C48
9FA8D869F1F0A35CA1C5C84833870E3626DA5CBE0831EC5847F141271C78BD52
5DA6D6B6353C582CF45F96AD5398E46F585DF5CFBA73A443BDE02EE0D177B8AA
2EF1111E3CCBC2D6641F40058155EDDF6DFB74EE044EF15AC613CB6E137BA189
8BC7BECFE4865838BB959512FFDA00E179F62F7140E29B4CD5501E73F6A4568F
8F44314225F953710EF79CFA407E84FC4457F4432DF13FA1EA6A8683CA8A6047
8752D0100F4ACA9C2FA617B179E4BCD2275CCAB88161A69BB506EA25E5D4476D
C5CC45EF0B7A308B95E6FD08B0810EE1A649C38106F3A6AAD659B581D64AF4F8
8C81A9DB660E9ED1BEB7FC071B5B2DC0130576090AA48187280E975B13B1F4A8
53A0406730747EFF0AF002A25AC6CD748C028C2848FCA8E42296ABEBE8530774
D132CD2A8B613A80AF5F0C4EF8D9B03713003E36F77B5B0B19A725A6E55CDE77
03EAC3383DC10D669793A940009D0658D9520DCC0C7336454A2B5A2B7BA5868F
E4067A787AC7F05785D811B7BCB1921EE39D2803E4D0A9963AFEA2CD68AE827E
F14327FF38A36E2539719D94F6AE0FFF2957BA9610A69A0493B0FD81E9DE6284
1983A58994F63B0B9898E280B4E86B4039E28D2BA881DFF75198C84AF76BC70F
A95CFFC98338D43388880553F1F27873047DC0E1302945CC600D30FD08764C6A
E388240493021926A3E894088D7CF1CF5D7D6F750C8361FDB1FA328207B54EFC
BD4D1B996306DFA327B94AB5EBB748ECBF9FB5718CCD198ACB10835693BF2E3D
A4895BE89A8424D38C491CACE989CB375AA65CB64F8BBCAB905F3FE0D51D4A0C
4A7F41C23554DD5F66F635A819013B837322F46785FCF1A490C4B08FC06E0D10
13682B37DB1C2BC209364EDF4F4360F1046151214E4CBA152593679B1109B494
FC17820F2E8DAB23C5CBC56EBDBAA2C42A45DEE2EBD24D8EACB17DE2B5229D49
478505A2450F57DFD36B34793C1735D2C649C0D4AFF27EFDB78E1B6E1C682B93
0F48BF0A28301B463A55D6DB59D9A6D43A6C80487E4EE0D12066BC87C06304CF
4693968B2AA75FB031C23E1CE3547435C51320A5E7B4212B33D9D985C144F38C
0086FF8372A29857A96BF8714D7B92882C50F3B4CAE322339B6884060A334F0E
4BC8A76DACD14B3594882B4915792BC385B5032F44D13511ACB51AAC17905085
3E72E2653350305B4875465625198D88782C46A2E84419C1031BB45816686575
50A09A790122F838E4BAF52591268C0822023DBF0FA03C18B30C0F8BA3D26DAC
BADC2B907888D27D3F5FA842310FC13C2F16283C5B35A4F065D2311FAE0F134C
3E2FF58AEEBC5F20D344F68F1DE8FDA2DC5232EB4402E7509F5BCAE32E393505
2982624A6472080F7F223A16B189DDD9E848A715A6A92EFEDD826A9F445FFC05
A7573DDD626CA4877E6C76999413203EF3FB68835FCE87FACDD8EBADC19FEC33
DD67CE1456B94F2EB8D9A21900D1263B47C65298102E71B70C3CCBCBD0920930
9CD235B3159291063DB410DC87B0C1C319A14B52F1D04D2AF9DE605BD82C852A
E0AD4E58841FD460E2ABA082BF86D9B85E74631FB8BA8A473CF7B63972845DF7
E743297BBD3CBD5AD2D04D359B0059B17A804A26633406CE8E1015F031200C05
0F504D1D9B278522F637E584432A898448C4D6852609B34FA09A082B3018BA95
299FA61C5B44ACB091FCF3840069A72C17673884A7938DF56B1A7155A3B26FB4
B6881A1AA293263B8FBB964235DC7A0709F2A0BECF278F44F54BCA9D6914EB01
D4CB7BD70AFA0BA342F9F1BE8BBABA0DD1A448CC9101680AB21440DB447D4C10
5DE4DD1416E9060A6F27983980D645E57EEE909CD4A42D4F188FA0DE0499F52B
3F3BDD232C83A845E2FAB65EC286F3A461FD2A63AA3CA08A6A69AA7EDC26DC37
EAE306913D97593A5CA77F81400A2ECEEC8DCA4C42F8B92CBC29FEDE606956B0
44DAD7E8DA3F433746A11963B65F2B2BAD386B68AFE007CB8F046C6ACE6DF962
AB464418CCB3E9E5D88BF1C868D851BDF8AB7B90D3496E09E241109C5CACB271
412602FAC0C644D10F0CF6CF8DD5B72B833B5705A49D0869FB1121B18C936C79
EEE99D995D0122E309B88907FC30DD049B238285CD8B6EF611C932DE08B8C10F
A964F46D0D94B0C81A0C0CBD75CD6B2FF456CEF9D4365C05CA014A12A5417613
3CDF3AF353F8B8BA0F0E3BD8C4436810585C1925B449CD11982ED1F3B6B23E91
61A159AEF85F3432B6C42D5835812C3398A81FCB8B5D32ACCFC669CDF7E653CA
7DF3D28ACB858B170FE686E18C83B673B111D7DB8D7795178BB5B2C4681A3636
63FBED563A979370F3368C94EFD3010522D1C61055E4E85B119DD47A34E681EF
B4DA6209B602488F4D394EDFB0745C23F06C4304522F215BD80ABE4753D3E92E
E22C90C28F5B84C426A551F8DCF44CD1C28E20619A27CD6D2D35D6FB6251D292
50782317C4E15190924ED29B921E21130995E997AAFAC3D7CDCCFBC875A5193F
0DB9FCA2799BE68234C5DFBC9AD259842CC1BED84469E8B46C57172B0B19F85D
8CA11D0A7C4AB8100A7AEB0F6971D43575CD4EBE188DB73267BA6DDB10696727
965B7A0CA94A7B6C9494C86E8C3DB6F9CF0BAF920E6AE1EB829438AC7B6F4EF7
ADA6097799D6B6234097C9AEC747BFA46DBCA0708E7182980FEECF834EB8B347
915215FAD31B659B42FFF9C243F45F4D047A90CBE622F0AB387F7A42611DBE78
39C8ED663E2D58976CE95044E2B207316BD0B7B59BB6F2980A97F6D34F2EBC6F
71CB952771C0B08B9EC60469D7F105FDE8268DFE2BDA1A7DBE603AFAEB04A25D
437C096E683F0D086590A9F5C620D60C7006A5C4AD3A851750F3D9E967FB8443
1C2C35A19A0767B1C56B0F10BF801C6BF8E065D2FFB846B0C82255E1876F3C35
10D0E80F5F738B8D285D28F3307D343169B62C65D2261654E80275C228D14720
3F1CA289EFEF3F591ECE0A14676CF08CC23394076406956EEAC3B01186F121B7
FBDC7947DBB357F284B421E93C81B317CB786128691703D4D2C64C713AD89477
0A2A45D9FAD6CC9B2D30391902782EC9F717BD8BD672A731E12C855213A679D2
8E0D3B4F7E2DE0B1E9333EF36D1C0907E8630F2A7D14DB9A5B72ACC2A6FA10F0
8D8206D3957C658D59D86EC73AB3AF01E0715BE82E59AE145E58C839AA85220D
C36DE4DBD4D872DABD2C8F3DB256AD1176A49AF84F07C3949CCF2485715D8DE5
0BA9CFA6C477A3AB2723B305FD3659992D56E5530839EE5B32872CF2D5A1143B
09D0DB92F58C0AFF6772CFE71F5EB29AF26C53E844CCD24C6116F4CF69F87631
20A9CCCE29EFAF78CCB735A4726F62CCA79C7FF27ADC7388F7FBC2F7982EC6AD
DA917F9416DDFCEC64F8855BE2722FB1A9C13758A0372F1F4CE79FF355FDEC10
7D19954C16534DE09F1573C692A36F62DA6C3DB7C449803C9F81FC17F87F4D2B
EF87D50F37074C545D38A6DAC0E23F9457F7A21CDD09FF7879308B6C447D74D1
AA94E9A6E88E1F82194FED1F4CE4B797021C463B886C69E9F72C574FD38FCCB7
77C6F5D9221923B3CBCA25042A2ECCB968E9A65A983C95E400623CD0696EC860
2AE7ABB8F2F5FD2D7EF71BD95FAA66DC89378AA929DF15E9460E87A4BC3820E2
B7F0390DA0F47C8469D592B55E4E7E5F36AB162B1ED9D6C1CEDA941950A7B2D9
84CB0CB1D910097A29D6B8C4BB7147319128C99769FD2C07AE167DDC90790057
3EB14BFD9B4F4A00BA98B4B21CE5E7C64B403DF8F9157413D624F2D583C734C9
691928CC2A6F79A11F7CABDF80239DADF961C15F773F603E4A27F3009BC3242C
4B35EC82B6791588E03F5E436314B775E4FEEF26EC4083C21B765FF30CA711DF
6EC6EB118E56A9B9CAD8D88A2FE5D0398E92B3060919AD5AEDAACE4C6FC6869F
2AC866BD32858BEC68483EAAC9A5C7B2A1A00BE3C2AA0803091F24B7DFDBE060
307C98EB77AFC4E3D2C106EAEB5A95739302C801B10E066E1E654B651A66FDD5
B7B530AA4AB05C40ECD89AD0E176B50D5B2781AEDAFDCBEDAA72184AB1CABF90
CB59EAD19B3BD0718051C32307003AEFBC3C2F0B613D94B1C36216F45181B3F4
537A5827D72FD3260B350F89A3B9F41A09FE53FAB2CA3FC0E3A29538A60EE3A7
507AC08BB15E66FFDADF8EE5EFBBC84B2FE3B130D440C6B42A1D1CA7684603F8
EFFE0306A039DA9A0ECCF82E47CED53D55994A92F744A0900EE1D4510BB67EE4
19F91F7041E19A94355238AC25BD54002BC85E0DF5CDEC14129883F6D8512832
01B3203C992645C4F14B8B46B6AB61C1DC5BDAE1DFA3AF18474F47D63ECBCCEF
8EC5540AD92553B42CBF48339F851A28C9480C07B85C892C29ABD23D794380A1
89260A6E77B99EA3875A84989CE324AB7B7EBA24400691DFD3D864FF6CBA03D1
DE51812EEFCB01B32B6E046A0348B23A94ABA7ABB3B7A916B388501A969995D2
A0BC71C14C036FE89168357AFEDE90F9CD6577B7E82A0B50BDF8FC83231587C2
3B5185BADCDF8C69DB2E4D6E2C60C320BF9B0C2FF276136F2530CD62BDD318DB
09757EB514E9E9E61D1F8A7AB4E9DED86FADABA22A7C0CF3B7F00D9487A462EA
A0ACB7FCC3AC3962EB52C9EF0DCAB30DB575B37D9F51CC4722E9908121B6F66F
747625B1D0321714F8611BD0491C4D86F78594B39913AC0D77D5B38741389C0A
7FF58B6F85E31F2FF4FE827FD7352C6DF943CDADDA20B0E98DC84C613EB891E6
728AAAE79BC58E4F931CDEE5F095C701191B0D2213CB47495993252A945C7668
E4E305F4A808F1DD42BCB72E2AA2BD030C76AA0A9729B5894FBCFA18075A547D
6C5924C8BDCF5797C208293BD154AF12CD5DD5B3EFC6C79533532116A765184D
B11AAE76470D4B87C02B27DB517463D48E720E9B9A1CB0EF55A00F7434E864CF
8AA42363AD5CFF3C9C7E6539595C632AD64EBBBD94331D1A2DB995AF59945055
B02E28CB787DD4DE6E83E8EC0EFFFEA8501F1BDC067EF2BA6D465D380DE6D167
7CE68B5C2A4F2A9D65B129B38B61A3FBD24808E89CFF4D288E44A96369163477
72ADB73FDB97D06DB6D85FB84A5582BA18C9AB27A3D2F489DFD108CE8BF3CC14
903BC6E7F57098EFFA12E747F8E53901A48779C95244F50DF71286F2FD0EC87A
04EBCA01C12987D72D0D43631997A2A03E28256D40185D9DCDB6521500269A92
CC46015CBA1101EAF75400A2C75C536EC4BEBE67C48A1AE99EDF9DB2C360AF0E
88F68FFEA848857D0182BAFBE3A6E0DC219B34464197211F7141ED9DE3B7E1FF
37522D514C43253F110C44C87D2548E012B367230D7BAC1E10D6FA2DBDF7CC1E
CDE44538293456A9ECE41DA786D910AA3DE1FB323A223FB845F602E49567E401
5C540614F690D7349CC82F1BF2D2A25BAD25F4E8480C12A891D6B949806DA3AD
73B81502CE6221EE2176CCE17160EED71E0AD51B7A46D956C75D0FBDD1E21956
56BA848649DEBD5310071344878C302882805A7DF0FCE66D3885C4EC17B5309A
0D163148A37208E3C26CD3CFA80DC27671C18F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: DejaVuSerif-Italic
%!PS-AdobeFont-1.0: DejaVuSerif-Italic 2.33
%%Title: DejaVuSerif-Italic
%Version: 2.33
%%CreationDate: Tue Jul 26 17:07:22 2011
%%Creator: ,,,
%Copyright: Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
%Copyright: DejaVu changes are in public domain
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DejaVuSerif-Italic def
/FontBBox {-1719 -710 3381 2272 }readonly def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (2.33) readonly def
/Notice (Copyright \050c\051 2003 by Bitstream, Inc. All Rights Reserved.\012DejaVu changes are in public domain\012) readonly def
% Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
% DejaVu changes are in public domain
/FullName (DejaVu Serif Italic) readonly def
/FamilyName (DejaVu Serif) readonly def
/Weight (Book) readonly def
/FSType 0 def
/ItalicAngle -11 def
/isFixedPitch false def
/UnderlinePosition -85 def
/UnderlineThickness 90 def
/ascent 1556 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE373DCBE8503A9C1BDDCDE3976B9A
FF31FADC784CD99E8D913C26819A4962BC428320D924CB0D4BE15E2EA33CD98F
3A3090D3A2B1C56F2D8E679576FAF3FC1A79261690287D7B9444B1B4E36B6E78
13E34916336239067A606618EB045356D480135F7C325841F7B5598118DE9F10
DC40B14F98881CE9249D25473504F621ACEEFEEC415938B11B1EA0DB33CD14DD
BF0F9224FBD2D8BDC80385967061093CBA04EF9F2CC7611612A7B40A88C5F557
0EA7B75CAEE65197D76E2EAFF968FAFF7C1105A090B0608803BE84E398A71073
17422E75FFAC10C7B78D88AE4656E8670F0CFE203076E26559330DB36E3DA818
0A35DF5545775638CA918D7B724A11C790C00416AB08EE446A6726C97D3397B0
0314EBC91B4BC45217722F1100A3B5EBB57C058C16BF371859A9BA53CBAA8070
38B0A8751C786BAB5043C284D16223CDC59398518D50ABF8F3285652A955C253
9EA5F707EBCCED2A37868AB64C6DCF6546DF5654A7B54F720D9B626D88F2993B
DD32706AC49259CFBC2FF04BDCC56EEA526E0250565FD845B7D4D9DF3EF185CA
AE724EBF1165BFEA7D20DC8F30D93CB8B4BDEEA3F37D794B6F6219DB4A85D9FB
331D84CF11D7FE9A46DDE1E08DDD898CE5599C6775CE143CDCDF73E2CD7FB751
BB4EAA22B3436A8AEE73B93CE71A7D64F9875B90B84A0378482C9093DED58B05
C7FC1631E35F7232D1D25D8FBF8954E5B33866BA86201A7951ACA6FBC88A1E74
4C3366072E854BF5305F61AC3C4375742D1316DFD48181563BE1E496980FA645
76EFD0EE2BAAC777BC8C22A340435D518C58463A49E183740ABE3227853E7FC7
0FF9AF7E0C63759864AA2E1BDC9142AA9CD24BBA3364285DA21FF67D3E0D37C4
2371062F5BF8F9EAEE120490D6AD034DEEB108A6B381109035EA4DDDCFB2A005
553868AC67E1E940AB513E1E41FF5F497F52AFA059C626D779AE4ABCC120900B
AAEC4EBEF3BA611650539FBAFAFF5443EBFCCEFB2147917E6A9F644B0BDFDF21
97162103433B454905ACECA48EEDBF777AC02AC4BEF34869642C9AD6127ECD52
12AB846D1450EAA29C556BB121C9C4AC3C940F1EB91146E0A7F170C2333880BC
6D7845E32595B2F9E2050D2B8D3D75F2AD74231D87A3C5991A3F5D1C8456C9A9
5A35F30C2F37FE3916C7DC06B77C08DE7E6FCF51FF4D26EFBDCA16B5626CE6C6
F7EEED4FBF4631E830A06D7A8D86790A680C47C2D1DD26BBBF1E3CD527980F6C
4739C00C2EC20CE1F46C903788C0226806023D73A86D4B8F95B72450041AADC1
919AB52F2165758281D989454CF561A84C97860B8D2A85B146F5805A7CE00D16
3E3C34545135279298C54FD39A960E69814BF4066F589316BA47F8F8F30C27FD
032A2AA9965B0597FCD470D69B9CB4E0E6F914D5BBAA4A98268E1B4DB4900ED7
FB585D63C3DF849ED5FC9B054EA6AB0149E04B8C4302D4A56D8A347EB5D3D2A0
E12CF7E35C8772C5B1A6B545E61F3171CED2010C988BD5437BC3C9B4D5254B36
8E4DD7213D2FCE31DECB963AE3D31F9B35A4A6ADE35ED5283961517E1E2E6E31
7BD9FDB42DBDCE82C93C71126926B9F8E9653E25F47EE74F4049290AAE529429
CA03557A9B8306D976E5EE6F7270FED4449563D2B97615D16887455E43D2FF67
752CD12DAAE57248F81B9FD153B122DB2F44289E5B8296A1093827BD3E127C20
31A3197B4C1A3759A381AE2CEE579A8DDBAE510AD6C9B3C7841540C8D2A499CD
1E377CD81BB642DF5F3B367E903158C2DFC11F715B047748856573801B26A718
980D36AF645F7E80DFB78EE950A877ADC1B84A0EEEFF7499D4A4959FA1BA70D3
DE122C74E2D07F135B33442DBEA6C0F74720F9A0B495847BA1F3896EFEB1048E
980F5A16B50B723A3018A5324994CDA85D9EDAC3DC42794B09481A7089CC45A2
C18A54AEB9CAF270DF2858636E571EBEA7BA976FCE899416BCEC92F4A7418CA8
0B35D3FAA66A46727CB1A0BC620E1B14489B73BF349741A5E15DF72BE6E28527
C05909C897B6B2E47F0576C92BD88F0DA00F757B2FF77463F8186365B317A5F5
6D23B74D9107E2A2D5C2C26E79D6B96DC6A65760E4501B14D3BEA359ACD21A40
8C8EE01EC592B1E306F1F60C17B04C13E3C20E089A6C6BC14BF893C29F61FD23
0BEEA63DD2B6CAD25A911B562367CF82E245712F148827033F3F1C0D11122E05
FE8BCCA62B12230255B5DC112BE3E6B0246E8E14850278761A368889725B0171
CAB9447B6774A330A75974BE76B05ACC3FCB47F4EDB70BC19AE14556EEA6D6A3
1AAAFC7466D2B9A4B2260AD20B602268DA0F0CC24BE660E5639866C9187A8803
98355FD303D10FB649B16AA3285456246A5A421CE1E955AA105D51471C5B7C47
2985E1E00DF456B3876946BC49E0A827E41BF56FC0CACB7842FF8F2DD10AE4A3
E1A7699603EFD017803E471242D6B97C538102B14A91222012637AF1D8DF9A0C
2937A3D7449E2659C0CF7CE35C322ACDA0B29EA3F63DB6F525E4813DA1C73AD0
398BD2FB74B4255299C8F0B0DCD7C6412EF9C5AF0A2193B8E0138EA71C81BA60
59BD057359ED3CD47A324CF587A4B3262405C9E753315B7B157B3DFE0FDA0F71
6F2F2927609219F27B108EEDE1127CCD90ED4FF3CE3E82F5B333E4833BD3A126
5221287185860BD79689DE66AB4144D73A3B10D7A3B85B60A60745696FFABB07
F44C52D830C5CE6089CAF571855A5086B98077A1E07CFE95B30BE896DCDFC069
0BB5B0D5945B3F7F124B923C1FAE68E5F5D9A868EB031F7DA4409F4AEAF38A53
5D931342ADA5ADD4EF1810E41C156EE20CC477571A18859AC3A74AF5B4B003EB
4396A0C3CAA4D0722AA10686F262B7DB8A7B1B948DBEEB188FC1D2A797122B9B
78C1F92F5CCBFCB72818B1E1EA494A80DA0121CEA84B511618E9D0552CC3784B
DB595B1F2C787A199EED810BA309AFF4B63059229C6E306C0756FBED2FF26246
33953D92285348D38BEF6048018106FF6776432F67F7002CD76005E64BB1CDC3
E641C66533433157C6C959600AE0F4280FF4D463AE1D9FEBAD065332B3168C04
6DA7AC6E66F4A9A08A98ADFAEE4711E4FD4268E70CBC5ECAB6F8601CE65E911F
57ECE585FA39D8FB6D93C81F3D76A76D288134981510B78B693DD292CD282FE9
CC3804E23ECF0BA98367C4A7DBDAD921F1434838F6D8E21D133D13A75ADA846D
0A6FA8A0C1230DF428AE05DACB2F34D7233D2B33A9BFADD6D0E03029FDFA95D7
0D991A20A5A862A7A728BD3A8C878491E7A0F1AD7105B1B506801D76818B60E0
B04DDB3EA71A2791D4F3FA5E7C0703FC2C93C5EB02DF2EEF2B6C8D74033C21FB
251F854DC13616E1A9E22445B6CCE04A1CD1C66E50757D480B56351386067E2F
8A211131C712BFA8528235F1A602CB799F8D564C18FE7483103E4E562E889010
F219C1F30B85B78F3F32CEAED568F0CCD395AAB91442ADEA8174064B3EFF00FB
3086E4DDD6B1E84342A2B831D48E2F2EAC65A47427A34CD7C577BFDA61214110
CC3FE5C892B5667CACE7D67677EFA1AD43755AD8904E7C063B3859EF3391F075
F1080F6EE2B9567FD4993ADA941FBAEE9A2A47EE9575E4E3DBDCBB617CE64466
DF58F9DFE73AFE850CC222FA0ECC9EE2613B339BD8F6E5C846DC5141E642FDBA
58B0E8AEEA84816E8C9CB947FDD259B1BDBBBEF73390FACCC79421C4C4A1B01E
FD02A87D5B2AB39A97E6ADB7DEBA6F71E8B9C7D44A7AE32D16398216F197695E
B338006CF423A8A1D0A5DC3C2F4B9BBD9F47D4A2E8D0FF7C231496DC0E7B18A9
E13B98E53AF023E7B552073DD8ACDEEFB3D9D98CE75658B632AAE7D5BE89FC88
7DAA7C4F66B334C15B98EAB0DC869523D3016D45C4650421070C80E288C095D8
BD20CCD0590904EDFB01DFEC8E166498AA88D85F018F88977566E90F777A07B7
AD566A66879DF69139B6BFD1D0F81E00B74A4510F9FD6A2A878B065E6F6972A6
C313F8AB65E7623166F516E7BCC1142485B1D7835060C4F1E8482AF90DAB2654
B101FCCE14EFAC729B2C55852B56B996BDCA0C4873159D3E14C519414E56AD37
F194566008ADD04E6F2B1FF9D34913771FA40103886020036D883325FB8ABE90
84AE51432BEF7CEF6A3BF6050234E293FC06B0A33EECC3EBFB023CE14335714B
E65683FF583E66A4DE2F139EBB8C03C5690130C97973AA4D40CBB60EDDAEEC1F
233D1645D12BB170645AF75534E6DCD097F61B9D2A3F37E0199EA6F2036B2E5A
C4ED2D34BC4A246581E688AC225AF2D19493BA76745E38444432BBAEF32B9BDC
7314F560168019A6F03BA39258C66B75A776640E8857C06877D3459E8660198C
189B126317F7ECB75B7B53BEC994D15C7E8F9C6890ADF6C693EC660FF0E46355
6ED6DDE7232D310BA0A33BD624933FB07E9F4A0AD7075DB073E1E6AB862B2776
8E29E9EE9740DA1A76207A14487FE4908E0DD9BD52A507764E05698324842246
C4DACB32FA759D59E0E4307AC105033A4693565FEE55DE922B4A793278CDF446
D8AEA79FFA606506C11AB66C6DB01A57DC9D5241C0FF101E99D7F264AC03F3D7
EBDF63DACA30FD7A97EC5E907B5AE1E208616803C2A3895FEAA6D3E81CC7CCE9
DC65529319EF2FB6093C41BDE285D7311454AB232BEBA4BD853E4670D3FED784
91C5BCC0FCC7585EF3C780EB6F53FDDB689D8794B812D546F288D2BFA376A854
04060EFBC17A5E9D0768D553B8792AAC122676581B4E4A578AE336C782CDB43C
3101700B30EB242227583E1D2FA256DE82AAD35DE860AE47D8F44620F52A1F86
6F9A2A07B2C81998DD05108FAA7B4D2433FC69F6E6BE010930461A7741DC302C
47137EDAD3219B5666B66E854965AA890FB3B482092485AE32E93893D228BD31
BC4A8D40A4E3DD8957217F9A34A4A711EF4BAD7B866DD4B7F12DA30B7D90C1E3
6A102E81FC795B09A320A26C5C367486EA986F31F6F9450BF21781EE559E8B85
F3B91B40EC2A66B8B14F49F72336FEADBD079B430DA38C6CE99FD4A4D6AE61A2
6916BE2D62BF28B50ACACF7F481A489A290B93C713016B7F0D764AE2920A82BC
A6C8C5C3A7310D2A612183F9EF89D9E89B3E405D192BEE8CD4CA07ADB5C26FB9
B660F77444E7EB0E8060B4EFACADA1878554CFF107B3B4DC9548FA4F52E27C26
3198F0AABC32A4DD17D054DBE4E9C240E522B8A5A731BA48A2D0164CF3504EDC
87A20CD4B3C6CF732FCEACD874F5F3F7F7CA9007433FBE2CD9D38CBA349096A2
77AB3AEED6679964D00AEE7B64D2897ADBA76D7827EBF4108B6FF9E4D7F9F426
CC8DFD61B56FDC2B4D1B52924D30D0DF716D58B19C1C70C429B23F6913CD1B65
55A42D3C7AE4FC81FCE3802023C8E14AC54FE3ECAA816890C27239E80ADDEE21
9768A4BD1017B83B6B0DAFC7F9C21F0923F6ACDEDF20530C23666C134719954B
666BD840165E01DEEAB372E96E5AA1A5D71063B34E6169968FA34ACDEC564722
109C0FA96E09FC2BB8B0F21537EEA7EF11619C1905305500915A807023AE71AC
518D708D372B7436676952806740BE067904B136C2B6B3BD8AFADFD5B5198E3E
D7FD2E525B35E90E78E536702753E7CC21C77863B5FE169C931C76E589FE0F23
F301633CC8A51450E21552CE44696F0E7B47A4F1C6E320D45009E02E7A37259D
8AFFB9F861420BF86287D0099FF9F570AB6A3A61DAA92A2FA020AB1A4BA1B68B
1153BCCDF7803BE3B4AB6A7EA1C6182B041F9AE7F6929633114AFEF487B4F3C0
B17F538C6D5BCD4C8792261DA2F7ED6E5D05FB6EBBAC1981A7DBBDDAB8B9727C
3E69B103C8FB0CD8900E0DDA1AEA5FEC9984CFE63E6282D2D488B6512E37AB4C
C00082B1878813DDD71BC6F707AE3878772EA5EB39E689450C0CF01BD753D418
5094C1B5E21AFF4CEBD076109AFDCFBA7C2F5A4A00BB0AF56057B7CAC8F3B1AA
277E909915B2419C59467ED8B07EF8416F674E211667D27028B1B2D42B4EF7AD
19A6A8FD6B1DF7BAE4A20B7E6C77D8EE3E2179672B4DB7EFE7106D7E06B2B57A
7E1924E88BE11DBA732FA150EDDC0F7A2E3A71E45E0226586217A2F44A8C30DE
22622C63FE21DC29ACEAC586BD8D6405DDE6487C9DA3BDD2E9EFA67589526BD7
BEF4B467FE1728EE77C1463DDEEBCE9A708C4B99F05C7E477B42BED5DB587A18
46AAC3780DA493ECB76E8AD025D0F52957099F97801F17A5902516B261C0B147
B5F64BC49170CE57667264CD351A6D32C26E47484CF1B078EB23F318C84FF921
DA05CA70CE688C8FF59843D691801C17B66ED70B9E5A2E33B9E37E9D2B266904
4BE108764DCA10A12A221A1F1E752D00BE3B85631F391A7488692A48F557075E
AE29FDB85B98A508973695959EA86B5E662D5C279C6909C295B6186236EE9F32
20EFB7BE5B501E69F13DA5B5027FB0719DF9411C388E15BFF65071B4BEA4C29E
2D0955AEB9C3A68B5508683BB7645A406BB57A1C2D4BEBB7DA991A994DFC7471
66C60182B9482737775272E903E75D1D98B0A62DF47F5D09E5797208F8881442
0FFCAFB89430EAEAF9D24853495E5659E98CBBCF3F5F0145C18B32F88C79AAED
E51FFA07E218F4941852BEED3661D27CB425253B0BF5666728D2D9A5C6BB9658
ED7CF8E6B37848E73F70F44CEABA55CD71FD2D3690A55A31A21CB9F3A4C0E998
8B53802399B6E22D8BA9230C4D518855DA74741A249103EEA2CB59608AA9C053
DE43015176D8B520374F1824C0BB9210FCD2DB74A70D8B82BEC9A24508A20472
139C11D99BFBE3F19706594CE9B9D31BC0E18B58A73225FD3F61C1E77CE3FC89
452957D4D4F3706A4B08559B7AB839B3A131D4F8AADC0405493BB9F1D7D4EFB8
E992AE5C11033B9E4ABEE0C93892C18BB56A3EA67F673743657704AC8357A9A0
98AB727A6C3E07427732318FB475CFB3118191C68AA6ACD8B73AEE7AB5D764B3
1A3F2880EC12A71DF8A3DE3783BE45CE0A1BBC429BA4DD33C317914BE4EAA81A
3191CE33DD5F7CEABFF720D4619FC4585FAE13F6013DC2AA19FE6D266B7C736A
8FF114F8048FB2AC67FB9E753C3FAD4DFDE9A6DA80A5A1CD6AA017C76E6246D9
F2A090096A286D38B7CCCCE08F4F218EE72C0452046B01B3E6B31A58989FFADB
0A795D2C2C6D44A680E566E753ACF85A4CFD49783FA209DE6960549AC18C1A41
B238AABE015B8881191DD23092F6D53D5C1CD68EBD038E098D32CB249E7AD49F
AE659BE3B79EBE269ACA32F86F59B0978B9B9383FCBD4D2EB8CE539FC07D9D5A
AE10EBEEB27C28AED5E3C9B39C6A9876779CD7F22CD75A3E296079D081E4C57D
4AD491BB00CE0BB3D6183C9AAE641E41A265C666F029712F83299C4DA83926D6
17401494E30EDEE101787C102051375750570CC8FC4EDDF2C94B08B2706111AB
7D342E8BDAE2843DAEE0AB50F6C970DAF12DD6C9325BC57B6F77FE77AE27ADC3
41D18A7AA33BA557FA8C21536C6CD50F6F4EC0EC1154AA360CC88559E381028E
090BF48869227D89E2465D88BF22262A06AC0CA4EECC03D853B86EE9D6D64C66
C1F1D1A411866221201AE726E3CC68B6E130AFD65411C4B7C3FE2474E6D2D038
63B5BD758A2D1C866A284B6B5E9B8662D1E2E85D8173A9E474E7475D03534B62
650F556ACF90B5C581CB81A633552B83867BFB409BBDA957C67CE6D92E2DB149
A0E0992E6C0E12988BD352C289FCC52AA75C86F475BDE461576FBA75F032E16E
1670467E02BDF2109185B29027A6530B88E6815A0F338993949F3C664470AFB2
592B5485D9ECEA3671CFB54A34B9919AD6EA376833D28585B643C9EEA4CA802F
96BEA28E219E35DB803749A8A0F7D3AEA7CBC49F0A6EEB895925101FBF2FCC19
D1A838F1F3750B8A5E45214EB47AA543F0ED39EB79C0B2D77ED80CEF4FE96FEA
40746223773C8B7A5B5C03930437A18EBA045CBA30EDFC22ABF4F01DB4BF5441
388E54447F753B9820117E2C7BEC8E499885CDC7F2DC8F11F0AAAFB47E09654D
B6BB734C445B822A0F8BD37B80EDA81C30EBF12BBA1F3295CCB9E4142140F426
5B6D86EF9CEBB46F2D5123C2CD95453B21C18803C371C9076B78FAB12018024E
B8BBCA053F918647355868595E31BE1547BC3C7AC1D0074270D5F6F387D6A9FF
E15A9269FA9C545346DCAD7ECB29D31E5C08974AAC5621581EADCF21177B0B1B
485902CFDA97A9E2F77D1FC3405449AFD89EB0790FA4B723E5F8E0A01B115DBF
FD50293090A293267DE4A22D49965FC03459619CEDBE0B30F6C2B46ECA223237
4B2959DACAEB2EA57FFFA271CCAE9C6046CD589FCE486C3090E86706CDB25CAA
714A3AA91BFB6A6E802AD9788749529095B9B8FB2B5F69BC96A0F5F4DBD7BD36
BE4218AA3A476E8BECAC76217C5BA9CC5E4CA5E5E44C4034B40DD2FD0060EFC0
446F9F7558EA5F954CD4AE87B60954FDCAC8062067259133977A83F85EA51528
FD2B6063B72B94F0BE2CA03F070D44B6D84133C960948BB89AF812153DAC6096
8B3EA1D0A18BD688F4FB8A4CF5A732811D7B7ADE4900D947908782ED35C7CBEF
CFD86186FBCABB34782E79B2989891526C9C44BBC5672D0E9A4A5262BF943E88
4E5840D131C0B9F677B3950368CBA6B8ACBE03019079001BEFA9A6D867B560A0
93E153094378BF92B33AB4EAE0378F32A2585D5FA135C715C38B0DAF803BCDBF
F1DBD34A56F52620BBE3E20239415FBBAA7452BCB47AB88FEFD339C246D17BF8
D35413756C12577ED99F26F36EA052482DF7BA3F58DA70A5ECDCF13E2B62C178
525237266051A8B28040CDAAE77448CC1CF74F9C061D1F99C894CE621C8FEF37
70EEFF13883227FB614EC3133E5C3C0A3E9A92C33E796D0D6E14F73D09C1D9C3
B4FE8E239029C6F79E84099DF3FE97919C7600EF34F39A9CCB955B98
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: DejaVuSans-Oblique
%!PS-AdobeFont-1.0: DejaVuSans-Oblique 2.33
%%Title: DejaVuSans-Oblique
%Version: 2.33
%%CreationDate: Tue Jul 26 16:58:16 2011
%%Creator: ,,,
%Copyright: Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
%Copyright: Copyright (c) 2006 by Tavmjong Bah. All Rights Reserved.
%Copyright: DejaVu changes are in public domain
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DejaVuSans-Oblique def
/FontBBox {-2080 -717 3398 2187 }readonly def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (2.33) readonly def
/Notice (Copyright \050c\051 2003 by Bitstream, Inc. All Rights Reserved.\012Copyright \050c\051 2006 by Tavmjong Bah. All Rights Reserved.\012DejaVu changes are in public domain\012) readonly def
% Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved.
% Copyright (c) 2006 by Tavmjong Bah. All Rights Reserved.
% DejaVu changes are in public domain
/FullName (DejaVu Sans Oblique) readonly def
/FamilyName (DejaVu Sans) readonly def
/Weight (Book) readonly def
/FSType 0 def
/ItalicAngle -11 def
/isFixedPitch false def
/UnderlinePosition -85 def
/UnderlineThickness 90 def
/ascent 1556 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE373DCBE8503A9C1BDDCDE3976B9A
FF31FADC784CD99E8D913C26819A4962BC428320D924CB0D4BE15E2EA33CD98F
3A3090D3A2B1C56F2D8E679576FAF3FC1A79261690287D7B9444B1B4E36B6E78
13E34916336239067A606618EB045356D480135F7C325841F7B5598118DE9F10
DC40B14F98881CE9249D25473504F621ACEEFEEC415938B11B1EA0DB33CD14DD
BF0F9224FBD2D8BDC80385967061093CBA04EF9F2CC7611612A7B40A88C5F557
0EA7B75CAEE65197D76E2EAFF968FAFF7C1105A090B0608803BE84E3995203EF
938D1FE5ECD19C4C0741611C838EF46191D5482B85B00B7EA6A4D3D94599B893
AB4ADC01DAC3C3EECBF0E938D6DBB4C2B8E4C6113BD643EAA19400D84E5C9B11
88009A9F7A6C1F87B63893C636BA2EEA1C198A68BB3222D3D4F4068338050746
6F7EDC5492AF14188E568AF25D684EB97A82FADC583AE8EB4B528A2CE4D7F70A
9BC76E83E48442695D4C442FA824461E2C149B754F98E69DA175937EAAF8EA3B
159F5A624DE42CD4345100A17E24425333B3A39C96362411767577083DA7A041
B68184E2E7E6E588A2BC5D074DAE0ACCADD07D0BB982D6548429BF42D168A6BA
AEB88336FAFB8EA64CE1AD528FC7387529634633F32FF9CA8F78BDC7188FB41B
30ABB6763F710CBD2720FD874B86B5C8E257F7D313EAB1D19A0B25F536143A6F
55C2CA9D72EA4E5A4EDB38C26C2F902D84010886044EC3A7E52B1384466E71DB
29EB2EEF7E0C821E63F8E2951F1DD5380CE621D817372F4171369F65F800FC76
3F136A3ABE68F8A8AB89F4CECAF3BDCD242F30B86A3E700F85EB0A80E6A29B17
8CCDADE2A91289BAE0314FC705AF1C3EEFB63DF5BAA7844718D8C471F077940C
805099C5CA88CD8CA97FAA3216E23FAF1ACB5B596133D9AF5E3957B0DA78B132
81E5E41F6EB3F179DD61B7C214203855DFBDC4CAD3F79395EDCD7D265750FE34
609C16291376A732B1C6A863C563DC63745D40451FF3C9701EDC2EC16F381186
6308D403093597C9A43C66E05A1B42B9E967532D0931403DDC5BFDB76EF64F13
864C24A59C36C4AFF8A981F979388FE2510297D5BE58AEAB570EC5E408BDE06C
768C73F03642579D3303AA692364960F640E08EA350983DD70265E77E02B0E0C
4089ACADED144B4D4B1E2101FE145EA3E9BD42A89152C487B8ADBE6830726B22
AF5E3B3562456A76006598BFAE38D141C0045AA3AB32CE9C7B426CBA6B806D10
21D2B0BEE43BB6B92BB93F06631BAFBF6CDB0CA02B4CA5E00136A2D0EC74CE12
2D318D7BE715E1655B7619D70F75E28BA2E4DC24AFED79576F1DC94913CC9A3F
923168FEDE5015DD7DCDDEA9F8172C2C3B8A79E591FD3D112DAF0F10AA41A6DE
755555DFCA078C9D27723EC94EBE97EAB54C75BC8EF9C2E76ADDCB1A7B45CD92
89B8D49C9AC1FFC98E03D34DD03E7C5E051121BB5D95B3DB3FCF8A4CA1346793
8E6CFF8359F528EBA380D5F3BD37EBB5405407E6F848A1D4037D582971F43814
79A9466B16C13D2594F83415B0C84119BF95614042FE81C9E51434B1BD1F02E9
9D80A541F86ECA61FC197665F59659BFB0982206A4C2FA8232262178695AA81B
3C1AEF69630B835463C7C08B6E33987D2FAEF99CF3EBAF6A3FE49B81A2E7E574
F213DC807BE2A56F8B4AE4089E303A3A51B9528C924DEBFDDCF907096EC2E43E
63DF02D8BF51E77E97875A5C153C291A6FB22BB0D5236ED5795914EAFF543855
21CEAB2A9813B5533F6E99E84A6D87A72F8A54E75C7EC327838EF5E480D01C6B
AB85EA3B224FDBA1613FF540DAF3E6FE8D9073D0F0F162B1EC29466E0ECEEBA9
C761B75EAC3ABDE0638B51BB78C4E10261AF359EDAF2903EFF64C85228EDB340
20599941CA4BFA04137B66A8D9DF7E9837AED31FF709F908E13E9C29C1A928D8
01CC0C181451C50989C05E361DB94742CFB6294318669CC66C89C067B83DD0A3
E9008CFDB3C47FACA5BA0AC770231345A085EB8EB6BA8F966F256969FE95BD54
381C08C2762C25267B36D822492250753E556C0CD2A66E9B7DEF9EE99FE2C7E3
AAA3EA07D775EA08E86A05A1DC799E0F485E5E829E9B903F80228D3841B1C386
018E8CBEDE4BFE12685FB4B057D4DC71E6CDC2DC2857A9EA699A01B81A349F05
738F5FDEBE9DAB22AC2FEAC9622CE3D1DC16AA06E3E87A9A9EEBE5E6BE5682C2
67A36CB5F819DB385FB90547A86A6ACF78434654ACC4A35722BC31761C9D2697
935617407D42389457A7A7A2BAC974A0053966086767FC06F7DEE30773D709DD
4B1D6D1D8F0B7D785BF5C7212E5A4367DD419FF9DBAC1FCCF503F43C3976CF1E
4428D1646839CF2C1E8B6F4BD134D0803FBF58655E14D47F8F161EC445EFC03E
8994B6066D6951D318CB3E9E4CFFA89C9B1EFCED0A89C9F3A8047C28E9039732
3EE01B212A8D81811B271A8A25E88AA14E810C170ED6371C02D4A2703E110DF2
577213BF3107BDC9000B4E7B4CD93A2BB03EC3FDA5F32B03C3CD9696F5B83A55
8ECBF60729EB68F2CB3CA7DD74DAD87E02A56A310C519EAE2D337D9995A31FDC
540A1453752D5D18042AF012607B2CB57F2856B6D0BBE7A01FDFA62CDA76B4BF
C3841F212BD4D65A5DA6F428ED22586E8769C225AF8394A759C7F34E3D4479B9
33604C1775068A331AD7B9CBFCDABBF58AE7AF63D83A3582C9542081E2D5EE26
28C20BCC28592E2F17F55ABF567C8B8B2B3741D1827D34AA07B6800AFBDFE9B9
0CE0B079BCB913DBD233F92629D8E335D8224F55709A7CC96DB3A14AB23A558E
EB63519443DB643C395ECF095DB515FDDC9007DE17DE38D57DD2EEEAFF04ABF7
A4BD71A4B875518A9FD28CD9722F6A4CCFF1BC8C2D41B0DEAD3F4084CE9A71CE
F5B0F856BDC528E961F50023AB3879E0561A3C344829551DC349FA9238B66BB4
CB8FC4CD52FBF57C3BF4CE7A062B489BCC7FA55B1B5B9E202169F73242CC377C
A02C035F99981B9FB2819230F9D12D2E4D8C6ED976914C2C089D12D623C896CF
CC534D7D6214F7D516A64EF94DAAF5D3CC61ACBDFBD74BE7E20F0281F904DFA6
F35140E103B6FF3FF9127650305C4881DEBC6E167EA1EE30F59F7EB23427E6D2
DDC047B8C0660A00A51834FD6939ABAC58686FABBD9A1ACF3450D3B27AD45A31
D0D958EEE3CEF020853080B2C977B0C7C34E8D3FAB332E02CBD462C148ADC52B
022C4EE65F0EEB85317C12C28A8573B2B182DB302E54C9DEC7E137691550BDF4
F28F88966BE772FEA39C69CBE69BD397FE17D73B03ABD960435E12CD69C864F5
6BC00D2D2D4F798C5E339C199F4E825E6F45B7C10FFBA951105EDA7837F53382
BD3F5D328441D0BC9B3A0762CAA471AE3BD99EFD6C86F2C3BF76C71F5688878A
E48FFDB4A8E10D1593E7CDEF356814D3D304A0245910DAEBED53E08147D70283
207353FB7E1A4413A5AE2F83234AB7DC8C4DC5789C2BC526E11CAA6454802EA1
91689DC68E6BA47A1A0CDD77C4B92BA00ACE950A0E3907771A359970BBE23E7C
824E53B92656A9FFFD3CB91E4301EC2EA6A8A21E9AEAACBC9A817FECB6568FFB
DDA6AE6D77D2A747833015C1361652599C0CE948263967898407A23EF9D931CC
691EC957AF97C3493FC69784C5B3C8A6321B86C295F0593B79D382676F16F9D9
A7BAB1FBBB026A891469E7B85DA5AD57FB51AEC2795FBF36194BA031C65F4015
487B607881E7108F78F3B00A5F67B2675CC549B77489EE1F9BB18E8B88356DC4
259F651CF77C30EDC01C042F7F3354697A77EC0483E4ED05717DCA96A54EF5E6
F9A7FEE0B3FE019E1C49416547F70D3D278E58430205D10ECE38A88CEB6F8C5D
3FD5FC7FAA8C65E5779799286D2A3E5BC4F84739E8B4B0EEC1632E62374505D9
85027DADBEAD1453F22845A4D5CD4A7ED0447F0E526285780960626E7FB52AF0
88B095B309B74711EB1D976F4229B29F14880E371521925383EAD4A6CEFEDF60
6F0C3F0739F9AE89A7687BE7468D6B3942110A4C31AEF7EBAD796F2851184791
243099D7B05D33AD23EA022C4F4AA6387C7EE1EE228CEFCFEEB9D5C7C34FB26F
6728C4BB78E8E243DF67ED94BB06347D501E650B0F266F6CBC183092CAF727C0
0DB7257F593EFACE56BB4E6FEC81C7D88B84F46CC6DD0E086A9E3D3B78EF8CFE
C4ADF49BCAC2330FE52906D92147F374B2BBD8664A5D19852808F5CA327BDC29
6972318D382F96649C59C5C8593141673C55F9D794CC68E955FE7DF4E372B8B6
035E2D4D6B2B8ACEDD0062E3B3707E6CDB9177352E0EBFB139611054BD088F40
D629A4ABC31E12A021BE105F64273909D5B23718610D5C7F37FF233D3A4589EF
388721ADB1FF3EC771B948837573AED77F27333BC2C7ED909192CB9E52E64E74
286E903E0A0F22AA0E0CCA0A1A4F0FFFBA601241978B6F117862C9EF450DF4D2
9A9B4F284A8EDDB8F4B274C907479584C7686163622D69F3EB0177B45339CFB6
5D9A283F23B7BD05EB23CDACF0F80037CDDB861344D5682C2C239C1A0196B8E1
ACC9D7EC583DDBF218408C63938C1FAE85CE0B93343F713EE48B21ECE5379B27
4352CF0CB23A86701E5C28F3724756B14904CAB56833CD83A7AF0F31955F83D9
18A1F80A87D5BFD384F4C85189736276BB0A741B88D1C3BCC4243E79EE3DEB2D
E27CE78AAC44BF1FDC4842ABFEBACC1EB7CB2F2FC2E4DDE5820567D16DD6F904
3F53C41746F94F1B1045C16E37D3C5DEEC55DF8E8A5593EA66D9DDA2D7BC450E
0FD078FDAD6DA5BBC3BE86DAD45F998605A744A45261EB1CD7F8DF6E19C1CE2A
D53DF80202E2AF76DF95DF32FD92ECC7E8E0F5A6D774EA1DCDE76507E68B08BC
DF587C8F756A818E2035CE982AB77B9397F17478B7C80F6215D6C1D26C029326
56D6A52021C551A6E98CF17AB2F3163E212999785B9CA3DEDD3526E3C0FE1D5C
23400E61A7679003FC241235CE24680783CF3BD61F6D805578A9297C99C5E552
A67066092A5946CB95481313C0730E1A2D830A1F2A82E7BEC53D2C942434057A
EBE50E6B84626BF01C763F884A54457A30DF585F675322DE54DDBF45BED493CD
66DD1EFCB49859970B1C5316EE60399C1097DAB3A47302078B0D70FFF8633CC5
CAA8D83F44D181D4F45DAFF9F69AE509E5BF169AFF42C7473F16B23822B4227F
A874D23945F8531829C812D2C542E4783A6F61E1EA8566E808AF8B4426975F1B
3CFE280D37F5FF9B4E964C27BA25D35F31FBBF5403E1AE3639037970468AB8F2
C43EE010F05CDF274378037E4C4EBB29D2C5EF56E6058FDE94F5B3EF1E4F30DD
22FBB0A19AF489D31941205C95C5A9F00F7FC8C4779AFECDE979F57A4E223393
8391A12B6159EF492222095B89A955BE773447C2D7879628CEE1E19EB3D8AF18
F53402643C57BD0469B4705E058635FC656871FB0E78172DB9770CACCCAFDC61
F4F0F43E0672DA86FF13AADAA81F619BF22A880E1452142B64E8C02C7795A0C7
E256A76DA0B48F7EBCF341D1FED429EDF87C49E4799CA57FB79A1B40170AA290
FF41258D9A306E6A650887B63C8E33441B5D0FAA0E1B8B3D1D4BF0D4AA5A7D29
4269E52379F763044A26EB6BE175D6EA737FFE67D85705DD1A455B1F521D1777
03123BD429A417FA544659DF81CE83C130752C0B174C88075497DECB8EEC8EF7
1DC3216C367003CF28F890524A263489D2A7E5CE877A4428F7386557F590E995
45B84F209606EDB92862484E39EDEAA4124900CEF48D3271C94D8F9E22884A16
70F71BDFB312BC69CC8FC24CD77839EB31280B6A847B785E504008F5D7EFD4D2
58DD67532A1CED485896F762C265268AA91104A5F3685A5F4FA8E5A45651239E
EA4A3BC4AC19AAC90133107136D84B58815166A9CACC09FCCB4D10A83CB1FA98
FCE90F50B864D0C468E6104A861CBD828F2069E50F174AC8DA40596F4A1B87A8
0B2019E5D9069FD166C3DA834179CF75566923CFF3E91C38FF3426AF443AB764
4F2601C0463C51315F70876BC5B3C63C4287C626E043DA914D6013FEAB2D8330
E5E5AF8F19673B60F88D6DB50B65CC907CE33E422B308F4D0E1C8AF15C8D8C05
3562446C5BDE57B810BB9C6AE93E4AE575F1288F52DCA8E0D097C587C34DFBEE
9C3B835546B0D0EDDFB5A9D8BB366374C428F3C0CB1EC0B306516DE97D296D68
09BB13B4E913BABD69B63172E0DD016E92021F299C519EEF7F8911D8B4BFC0B3
CEBEEB772F947BEABBF3A491FCE0B1158849333BCF348E67E1F4732CB1D0E6E5
89189DC199C1DBED6451730CE6BC6B881DEC855F532B83798B0192B0A685F13E
7BD81BF01F44A5144B3303C52D1C7A1327438590ED882C9162211CA90E486659
4C41D17EFD7183E7D61730EDDB2E669A8E326EF5636F2C8BAE67DD35AF72C923
86B8F67CE9846DAF3035DE07CBE5D26F4AF470C4488CF143B4B76F757B0BED1D
12A4FE50317D16D609691826540D6BC1A221F06B5A65BCCCCA6E698A30F980F3
3885616D717F0ED86C9AB9218B0F32E0B4F0FE911CC5A7599B129A1382BB7307
7D97B0458D164C44AF47CF532A29404E3889352943C6DB2C9B1877F5F8B5D29A
343DBDD436224D7A748E9E5DDB414A295D4C939C06727F8C2A496E96AF9F435E
E7512149BD12A717165156929CB0F0998AE58C5AB2FC12638A32DAD590551086
A4D53BCE08428C97BF0E4662F146D5AF959138F47F17046E589FB597491D9204
414C205E8CF5912AC2829B846F2EE9965CFA53EEE1F61AE5D9048F594975EC79
185873AD3F130B1ECC319E1DC0BFF3D08F3AA44705AE64AFE77101A8F44E244A
67AA05FA6E4C73E47B427159CA5D6A1995B566FE5942DA72EB8E8AED84F5F269
BE18CBF335B270538C06ABC143B3B2A0713A0A82033939786563065D52D37B7A
43B10387BA3F794FBA53D62EE62BE0542360FC4A2AB4822AA8AE4F72CDD73A0B
312DB2BC47611022465862BC073298C54F462B3C20E31D508F7014C754295900
28618256FF4B0A1E00A5B1BB5A92D1A1CC8DFB408888DDBE4F3A9DB2E472B15E
8EE63A4DA63973AA0CFE859FD17140842A4492FA59985F107FD33C0049623E43
F1655BEE8EB940D0A75D25821DA6C8801B234B378B1F9DD4EAFAE8C8526A919C
6B32419B3EE5261C835EB2DDE819527AD13D661189E99629F8676A41DD932778
87624250643CAFE3A55ED28E2CD3210FC3A176D5E56DD80B4A2191B12A3CAEB1
2F53B202C8C2023D4DCC397D581D5BDB5233E1FA41322B4E8364EB22E2760046
360945F5925BEF2E0FA1CED35A4E4E82441B1DE3C2E71F6818158CA37C1F12F0
4BE73E35D28B2E35284BE1FA15D33E2B0786832B34BB79D540A815DE059D8ED0
42D5EE5B591FB8BC94F509AC1D2D60FC118C95899491F1CD9121A5A72D7CA9F5
52564D7236096424116A8DF7AB77AE651A9FBAAD8DED28252E602EF6F20D74C0
930A6018F1C87F889EE8F6B48F6E31E568200F6E7AD1DB65529DE080236EF96D
E414DE4FB002FED9861877C2774F752A4EC7F80E6B0078638A9D99FF56A3D4C1
39AC48C27138B032C9A4CF1133F1A2CEF2F2D77FD59BF4A2832E81539A062BC8
1740260FBD8A915CC4D15DC09D6257DFA121A24EDEA570D91561C3EE3092668F
BC6C8FDD6EBBD30A45448D0CB47007E843723AF1B0F31D11E5D4EC5110043DA3
E40091E814E2CC9D57B51B0316387B1E916D4355D8B73BB75174FE1BE39D5BAE
8A5ADFAA12116AC69AB47C590351341FC8E6433C155A65CFD8EE176FE4E5FA44
8CDDA50B5815F334B146D3D081BC672187A411CC1BC2C894B319ECF3531FC1E2
ED948CC0139D565F8CE5847F76E7BD5679BFA93170DD5F49975EC8EA9AE0511D
70A2FC838A1ECF8DD1D43E3CF0058520633A9AF925EF0F3B74E35560D0AAA15C
2BFDC4FB6B567648632D220FC1BC93C07E68F5366491D1BB097D8FF4A71966D4
2DD988F488A17A9A1547F1D8811412A2EB048EE8120FB303DEBEDA65FE59ED04
18F6CF07B28837D638BC0C2538A6D825DE96A8A5AAF64EAAA61967F079C4B3C2
F25757E5541F96F98EB26AC14AAE1E6873FA855BB9D1D335D2BE126B6AD9BDA8
A46FF9260E54AC35107271907E4739469EFE5675C0FE6A19FEC02697503D19AF
BC99CE983EA462DBC29DFBA80E389786A0EFB0F3A58E88F04C3B65660594E0C6
B30B918A0DC8FB6F385802AB247E9FD612C7762E866A6E4C83D0AD28B589A7BA
F7DEFB9CEC1E1B34631245B0CD0A89C7B57A761A390E9E2AE6DDD699E086AE7E
8B82DA56A87803B1EECA58DE0BB7A26FD1D6ABF8A2A38E96EBE70EAFC5AB39D5
755DDDEB1BC4D04EB10CC0982B147D2293F461BCCF0EB34CBB917A02D65D8C44
9D9A1CCE52D10CA45CC1BC7652B9E76547827EFD90798F41EFF7A865D05C8F65
5BF7D1612317DF305BD7B385D495211191DEDE4D3B78F8F31A5A92ADECF6E7F3
706A4B080B60FE19DD066DDFCA49FD3906B7D32C787DE06908B1DF7F79220FFD
0A87F51530D69B11D90001545C4F3E70630FC092350F18DBAF8F2A1C368E486C
0C4E1D829226B9DC09081469223AA0219763C2B44F426004299DC9E465A7892D
5DFD4B654D2973AAAD8001ACFC1C33D6A16B7EABC23C5943095BF1E82A90ED92
58885DF56EBF727A6A212D64423CD27DCC76148BCD2C48220E3BBD9E9393DA2C
AFE45BC2E8BAF913BF1821A66A12B76083A8F536C6DD14058FF53AC3F2E13F6A
217FB4DF7B8C3EED2036BBC82C8258837945CF961BFED03950B8C1E73C1CE393
5563851EEFA114A75C74C17E693ED1D328D57BB7AB669E3DAADE4D946B20518F
3EB4FDA745C998338A2E7B6BBF9B8E57F0A0BD92180C886C89C3EEBA42D29641
27E1B366FA750F9611DEF3B8660016573E4A0300F7243709C4B616237F142370
C0BEFF746036902D2E4041C5E1C1FE36F553E99933C15580199CBA072F3F3E6F
C8ACD526F2F00A58ABDD0C086A48AD0AE9BB415E4E385507F54F7B275CF0E38D
7D0FCCB303A6AD3DDFF2F57C704E20FA821D890C325F962342C0D2A9D3E105A1
9D1B57C4459401AE3114CC83B1B24FE74C351EABBC368E5403453FECCD0AF58C
15FBDD5D36338CB0ECF40BA233DDBEAA22714CD44A04CE29C9B414EF463679A2
2F07B8555BA60C360904A44F1D1EC6A33C1236880DC34D29A0CCC2D98CFA8E2E
A9517AC5FF1A9E33AD527954482C8AE579801B110C76FD7357B8B0659B1BCD73
324593ABAEB5548FD229220F8B49CC808E590F745714601C951F04D6B0D0E599
445910CC42F926DD71C9A1DF269D89E303F37ACA22B901DEE03B85711E3B4192
901B7E2ADA50A6FA842125360BF3DC1144957CE05EE11479CD3A02BE03C555B0
808D40B953D2EC568760708BF2A360A33A473E6D63D300577B2C99A5F45D0EE6
7D3AB833626938F56939283DA37B18363AB00187E940882529CE5E4111CBB13C
C3AB7AF1B865C905F4AB20C636173D5D9EF4C45B087BC34E8F14FCED37A9FC6F
CD739618D3A7A43A88BCA04612EA2F5A6C8A7C614DBDF2EB65869969F2653419
38B2C7D6B979342D903DEE23FCEBEFDB600F329705E66D0BBF112BA75BEDEB14
4329B8DAB35303C922432E92394A95196DA90BA14C72D396FCDF472EA459E0D3
8F1B3CFA112EA94A1E0DDA0D4DEDABCEEFBB94D35FD6AA23331BD1EEDBA24EA8
129575F45562C3A9DE6D4EBF59482D7A75A523A1886FDADA6E09DA69158D9928
7EBE0D2FBCD12E7EA72AA2C2EA54482A16933EA760142ABF564B97EE290B983A
7CFD19B9DB65CB41D0CE65F05CC6ADE1A5A640658AB48C1A12CAD1F524BAA1F4
283662EDBDC8BAE02A8B13B63DBADB1456F264BE6F72D65559D3785707ECCB35
8CD32324BD1DEDB96D2E92F0120CECCF9FD5CF7D946EB265AC93ECDC66602C3F
17D4C4B24B57B8530C8A1691294FDA96EC00B2BDE3CAB5EDD45EE1A189A5571D
F78F8D0655B3DAA1C678311D14C779B76F52C61BEA735D0CC2EDB80B62AA6617
EDBFEAE80AB26D4FDF3AC75EA372724904A03712C1E9C72B6B090AE88F4D3DC1
76341D75D90E6C3EEAA59B64F7C0C44066EE4D11EA6137C07CD089E8A44EF718
6E8C55BDB562338C4D15717506469DE6EE7C62F873801474A4A3A31A5A1E03E1
F86F0C21AC770E51AE71C71E6B7796B6B54F27FEB1D9FF9D83598FBA5FE616E3
3EA2F454625BE4B1D174ACB4EE2A3DF44A0E9804EFA2830C2B630734F5993923
4DA77D95D50A7C1599E62D4FCAB001D5F9DA84FA530FC728E91DDFBEAF65EB7B
28D41FC2ACFEE9D6D55AAA5150067A1B859F133F99BD59298DDDB1619555D16E
C1DC65C914E6689BA08EDE82568BFA3AC336356C2C4E97C7A9DF88EF4D4736CF
5CFB0477EEF35126847B574F60E61F9FA8E46874F62616F1D4AA2D0C3481AEED
2638F8BD63AA356B85B894EC7E8016CA821B5216570FB618E6A9213F2AFA3149
8CE3C90BFB0AEAEAEAD5CDC33C783C6F48DC7C8B633A72C4E556984C5A9E5CAC
17C6F1BA3477A5466FD6CFE3C07BC994E62E3590682BE555DB35C599A5E162C2
5E0ECE1490012DFF7A94A05A7BDF68A7C9337FD99FAA9B5E99B8EDD7F3847A75
482B53E9CCD1A1823A6CECAA632EBD3B5C9429E91C20F24FCFF3B8645ECC3AD0
C5EA2C6E64951BD1F7F71D77DE7B4D89F524F9C3162EDDEA27A99F2D83D91F72
1ABD116A40698F26610853E7FD07547D9DB5AEBD7FCA9B27524DE0E10AD84344
06429D13548ACF79D025682792597CE45963DD9BBD64D0B1B7BEF72E5EA6E799
239ECEF6AA5AD80080C4F3FC57F7AFE383C92D2760A40AB621132DA0DA39D124
0D5CC15DB80A2C17DE828401952546779351520F208B0CD3F02CA1C91CA8EF70
9AA13710EA318B982A6FA8B179994081582541868FFDD79D1D00AA769B9198BD
BD3164E8FDF9AE09FACAE17EFC8C1E9BC731EB797BAA3658B8AD58435B34B1D7
D501B561D3E1812D5D5E97FFF1E35756C47A6A8FD44E2528D5460A44CA25AC75
85A77E9427925F63070FC1F62B45083BC38710E8001DDF0750125FBCF26095A3
20A1071176B65BB67B666B84BC164518713BBBD20E129189FB1A11AB3F83FAC0
1F1A052E23200E94DCDA8807FC3021A036495490F7D4F3C059CECBFBF7F20EC5
431691AB8AFBD58F87D5145728C12387213B2AA0570A583C2F94A78270C6370D
4B6C1CEB410F41005FBB3237C8A09523BA8AD18F670D0151F8FA7FD4C1B36CF3
41958350BE10A0988C30CAC11037E03D10CD99FC24AADB61B00F0441B5285C5A
2BC1D4053C37E49EC8530A2B959B7CC4EC03C13974E182113A4461EF83F4CF9B
18D3648CEAC8299400AAEC709B6706CDDB026605DDDE69FD6256AED68DB4A9BD
1A951706AF501FF5C3D61EC708D2D4264E6CE75B18B27B2A7C43F6C627B9158F
D7E05998D4DB17A65A2CF506BA4A46BBB41862B3B130F4F118A0AFD029DC97D7
F95BF9D0E96B6524832DDCDD6746A956AD6E0B736D5A8A6CC0A5B142049383FB
A276116C1CE00B1D59ADDA3AF7FA67A58446CF7BA1B631B9254CE82EE3C83C34
39D5C0F9F5035F04B1258FE0549B5562B5D514F7EBC506AC54D6F006E7658577
3805AB2C8E841242C754F1DDF94F962AE037E33761EA9FC9C6A9FA8163F27C16
C41ABBCFFF2F2F7B9F4D5097FAF3D63176BAF1588BCE485A83AF8374454C1986
6536E4B11CCE0213FCE1FC37CCD8365D268DF47BD9FD951D62784D2590970DD2
20D34BA5DF738EBB2AE6A75F7987ED026F207ED8162BE45778FBD69B22AB45C4
638DC46882D16A91EA27367B50830F30F0B90901E210BBF9AA517B39B9FBE288
7398237452F8416165E6A173662005EE851DE9E1A11CC2E68797AFE2FAB84089
1C521FC25FACCC9A2EE210C7AB696C4EF6AC1E6813C0F02870F1E13FE3367C5E
4ADFE9268145F6636FBAFC9BEB727891DDE1C28329B02DF11653E68F0EEA7055
25AC68DBD45FA1E1DCC2FD0963F634C8CD0D00B528FDD2C53C9CC493747F2E4C
6239CCFF1F4FD5827BE0916E6B5575531EAD5E55284282297430BE26E2176229
024E9FD4832F58E0FDA5CA6489E5E9B081D7E78CF04E3D833FFABB9E04A6C90A
90C4E3AC5D717C0A952FB5ABCB9C1A9A3634F74F19D24A488169FD8CF21B534E
563B01218E147D7C86F6338D5E17CC474EB00DB55D2C51376B97F37E839B6380
CAEA203F1B96893B6E027A69CCABAB13A4AADA9987BF50A91FE8EB8B8B13888A
024CE49DC3D5CCB794242C2AEA583B7C5BC8E7AAC2C42099A7670D30316F925A
51977788B9356817E2639223C31D6BFFB14009FF2BAB3153F929AF5D0498892A
78DF120FA535F4C63DE4C015411FC29B3CF20D8AA5AEE7C91D0031EE2D1ADE31
3198E06A3ABFB738C3B5F25494FDE363DB1A22965E2FAAE4C8860B6D96271D31
223E57A6238904764121C7BE9989D20CD40EC35C5D91281FE0762E1DA4E474EC
7D6FD2999E2203ACCFAB96D12DA8BBDFF2A843
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 27597259 39158274 1000 8000 8000 (new-member-manual.dvi)
@start /Fa 134[704 3[881 560 682 639 1[848 808 881 1283
460 2[460 1[848 1[771 848 738 1[785 9[1361 1[1057 2[1007
3[1108 12[940 65[{ AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }21
1212.12 /DejaVuSerif-Bold rf /Fb 240[606 15[{}1 1212.12
/CMSY10 rf /Fc 134[772 1[1143 1[966 614 748 700 929 929
886 966 1406 505 920 1[505 1[929 571 845 929 809 929
861 6[970 2[1492 2[988 959 1104 1[999 1157 1[1470 934
2[621 1255 2[1012 1152 1057 1123 21[462 4[462 39[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }38
1328.35 /DejaVuSerif-Bold rf /Fd 134[926 2[926 1159 736
897 840 2[1063 1159 1[606 2[606 1159 1115 1[1014 1115
971 1[1033 9[1790 2[1186 1[1325 10[1361 1[1215 3[1237
1[934 8[1109 1109 1109 1109 1109 1109 2[555 46[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }30
1594.02 /DejaVuSerif-Bold rf /Fe 132[606 639 685 684
1038 685 781 487 622 579 776 776 730 781 1149 388 735
376 388 781 776 449 717 776 679 776 723 7[800 1[1246
875 1022 808 830 913 1[816 994 1061 1241 805 906 486
479 1057 968 841 885 972 927 891 875 5[408 408 771 771
771 771 771 771 771 771 771 771 408 385 410 385 1[606
473 473 385 1079 3[620 487 18[1246 1[808 861 11[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }76
1212.12 /DejaVuSerif rf /Ff 138[1961 1316 1639 1358 1[1971
1892 1961 2870 944 1831 1[944 1961 1971 1198 1868 1971
1633 1[1858 9[3038 3[1984 2121 2341 4[1755 2134 2[2305
26[1143 45[{ AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }26
2754.12 /DejaVuSans-Bold rf /Fg 204[1461 1461 1461 49[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }3 2295.84
/DejaVuSerif-Italic rf /Fh 139[625 1[655 1[1012 7[1010
2[981 3[977 29[1113 67[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }7 1594.02
/DejaVuSans-Oblique rf /Fi 198[1109 1109 1109 1109 1109
1109 1109 1109 1109 1109 48[{
 AutoEnc_erxmsn2dewfhvd5ktdkymdjaed ReEncodeFont }10
1594.02 /DejaVuSans-Bold rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 8000dpi
TeXDict begin
%%BeginPaperSize: a5
/setpagedevice where
{ pop << /PageSize [420 595] >> setpagedevice }
{ /a5 where { pop a5 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 31305 1907 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 73.725 17.22415 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial 1 TeXcolorgray Fi(1)p Black 0 TeXcolorgray
Black 0 TeXcolorgray -1550 5919 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -1550 5919 a -1550
5919 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -1550 5919 a 9556 15439 a Fh(Chapter)507 b Fg(1)p
-1550 18029 30553 45 v -1550 21633 a Ff(W)-98 b(elcome)948
b(to)i(London)5428 24954 y(Hackspace)p -1550 27076 V
-1550 32579 a Fe(This)477 b(is)g(the)g(largest)g(hackspace)e(in)i(the)g
(UK,)f(and)g(you)-1550 34085 y(are)337 b(free)g(\(and)e(encouraged\))g
(to)h(tinker)g(and)f(create)i(us-)-1550 35590 y(ing)385
b(our)g(tools)g(and)f(expertise.)332 37246 y(T)-94 b(o)590
b(do)f(this,)641 b(we)589 b(need)h(your)f(help)g(as)h(well.)1062
b(Y)-105 b(our)-1550 38752 y(membership)398 b(fee)f(is)f(a)h(big)f
(part)h(of)f(this,)j(and)d(helps)h(us)-1550 40257 y(pay)405
b(our)g(rent)h(and)e(utility)g(bills.)508 b(W)-99 b(e)406
b(also)f(need)g(you)f(to)-1550 41763 y(keep)423 b(the)f(space)h
(running)d(and)i(looking)e(as)i(you)g(found)-1550 43268
y(it.)1024 b(If)576 b(you)g(can)g(improve)g(our)h(facilities,)623
b(bring)576 b(cake)-1550 44774 y(\(and)350 b(clear)g(up)g(the)g
(crumbs!\),)358 b(or)350 b(even)h(just)f(help)f(keep)p
0 TeXcolorgray 13341 47814 a(1)p 0 TeXcolorgray eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray -8161 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 73.725 17.48047 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(2)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fe(it)385 b(tidy)-161 b(,)385 b(so)g(much)g(the)g(better)-133
b(.)3432 9646 y(In-person)415 b(contact)h(with)g(awesome)h(people)g(is)
f(one)1550 11152 y(the)355 b(best)h(things)f(about)f(the)i(Hackspace,)
361 b(but)355 b(we)h(have)1550 12657 y(far)259 b(more)h(members)h
(online)d(than)h(are)g(physically)e(in)i(the)1550 14163
y(space)457 b(at)h(any)e(time,)477 b(so)457 b(we)h(strongly)f
(encourage)g(you)1550 15668 y(to)428 b(participate)f(online)g(as)g
(well.)577 b(W)-99 b(e)429 b(use)f(IRC)g(and)f(the)1550
17173 y(london-hackspace)447 b(mailing)j(list)g(\(check)h(the)g
(website)1550 18679 y(for)462 b(details\))f(for)h(technical)f(talk,)481
b(and)461 b(for)h(the)g(organi-)1550 20184 y(sation)384
b(of)h(the)g(space.)3432 22693 y(If)483 b(you)f(haven't)h(been)h(to)f
(the)h(space)f(yet,)509 b(Tuesday)1550 24199 y(evenings)348
b(are)i(the)g(best)g(time)g(for)f(newcomers)h(to)f(visit,)1550
25704 y(and)435 b(there)i(will)e(be)h(tours)g(of)g(the)g(space.)602
b(Also)436 b(ask)f(ev-)1550 27210 y(eryone)522 b(what)f(they're)i
(working)e(on)g(-)h(people)g(love)g(to)1550 28715 y(talk)384
b(at)h(length)g(about)f(their)i(projects.)3432 31224
y(Some)440 b(of)f(our)h(equipment)f(is)h(dangerous)f(or)h(easily)1550
32730 y(damaged,)517 b(so)491 b(we)g(need)g(to)g(restrict)g(its)g(use)g
(\(eg.)767 b(the)1550 34235 y(3-in-1)382 b(mill/drill/lathe,)h(and)f
(the)i(laser)f(cutter\).)450 b(These)1550 35741 y(will)460
b(be)i(clearly)f(labelled,)480 b(and)461 b(often)g(secured)h(with)f(a)
1550 37246 y(key)-161 b(.)431 b(Ask)330 b(on)g(the)g(mailing)f(list,)
341 b(and)329 b(someone)h(will)f(usu-)1550 38752 y(ally)321
b(o\013er)i(to)f(show)f(you)h(the)g(ropes)h(&)f(give)g(you)g(access.)
1550 40257 y(Don't)567 b(attempt)h(to)g(use)g(them)g(without)e
(training,)612 b(be-)1550 41763 y(cause)272 b(we)g(hate)g(clearing)f
(up)h(blood)f(&)h(body)f(parts)i(even)1550 43268 y(more)311
b(than)e(we)h(hate)g(waiting)e(six)i(weeks)g(for)g(new)f(tools)1550
44774 y(to)385 b(arrive.)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 3 3
TeXDict begin 3 2 bop 0 TeXcolorgray 31305 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 73.725 17.48047 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(3)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -1550 7137 a Fd(1.1)1594
b(Access)-1550 9920 y Fe(Y)-105 b(ou)536 b(can)f(open)h(the)g(door)h
(to)f(London)f(Hackspace)g(24)-1550 11426 y(hours)344
b(a)f(day)h(using)e(an)i(RFID)f(card)h(\(such)f(as)g(your)h(cur-)-1550
12931 y(rent)532 b(Oyster)g(card\),)569 b(if)531 b(you're)g(a)h(member)
h(-)e(the)h(wiki)-1550 14437 y(has)385 b(instructions)f(on)h(setting)g
(this)g(up.)-1550 18207 y Fc(Out)462 b(of)h(Hours)f(access)-1550
20572 y Fe(The)323 b(main)f(gates)h(are)f(sometimes)i(shut)e(with)f
(the)i(chain)-1550 22078 y(draped)257 b(over)g(them,)284
b(and)256 b(sometimes)h(completely)g(locked)-1550 23583
y(at)480 b(night.)733 b(If)479 b(they're)i(locked)e(or)h(you)g(have)f
(any)g(prob-)-1550 25089 y(lems,)655 b(ask)599 b(the)h(security)g
(guard)f(who)g(will)g(be)h(in)f(his)-1550 26594 y(o\016ce)548
b(next)g(to)g(the)g(gates.)938 b(There)549 b(is)f(a)f(keypad)g(lock)
-1550 28100 y(on)434 b(the)h(stairwells,)446 b(which)432
b(restricts)k(access)e(between)-1550 29605 y(7pm)442
b(and)e(7am.)617 b(If)441 b(you)f(are)h(a)g(member)-133
b(,)457 b(you)440 b(can)g(\014nd)-1550 31111 y(the)587
b(code)f(on)f(the)i(members)h(page.)1052 b(If)586 b(not,)636
b(contact)-1550 32616 y(someone)407 b(in)f(the)h(Hackspace)e(by)i(IRC)f
(or)h(phone)f(to)g(be)-1550 34122 y(let)386 b(in.)-1550
37892 y Fc(Car)462 b(parking)-1550 40257 y Fe(W)-99 b(e)297
b(have)e(two)g(parking)g(slots,)314 b(which)294 b(you)h(can)g(use)h
(with)-1550 41763 y(a)481 b(permit)g(-)f(the)h(permits)h(are)f(kept)f
(inside)g(the)h(space,)-1550 43268 y(attached)538 b(to)g(large)g
(pieces)g(of)g(wood.)907 b(Please)538 b(return)-1550
44774 y(them)386 b(when)e(you)h(leave!)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 4 4
TeXDict begin 4 3 bop 0 TeXcolorgray -8161 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 73.725 17.22415 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(4)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fc(Bike)462 b(storage)1550 9425 y Fe(There)386 b(are)g(a)f(few)g
(places)g(to)g(store)h(bikes:)p 0 TeXcolorgray 3368 12090
a Fb(\017)p 0 TeXcolorgray 606 w Fe(Cycle)469 b(rack)f(in)h(the)g(car)g
(park)f(\(use)h(a)f(good)h(lock,)4580 13596 y(not)578
b(recommended)h(at)f(night)f(as)h(we)g(have)g(had)4580
15101 y(theft)385 b(attempts\))p 0 TeXcolorgray 3368
17539 a Fb(\017)p 0 TeXcolorgray 606 w Fe(On)268 b(the)h(main)f
(balcony)f(in)h(front)h(of)f(the)h(space)g(\(you)4580
19044 y(need)465 b(a)g(sizeable)f(lock)f(to)i(lock)f(around)g(the)h
(rail-)4580 20550 y(ings\))p 0 TeXcolorgray 3368 22988
a Fb(\017)p 0 TeXcolorgray 606 w Fe(Please)425 b(don't)h(keep)f(your)g
(bike)g(in)g(the)h(space)f(un-)4580 24493 y(less)385
b(you're)h(working)e(on)h(it.)3432 27158 y(There)k(is)f(a)g(Barclays)f
(Cycle)h(Hire)g(station)g(in)f(Front)1550 28663 y(of)455
b(the)h(entrance)g(to)g(Hoxton)f(Station,)474 b(there)456
b(are)h(also)1550 30169 y(two)385 b(other)g(docking)f(stations)g
(nearby:)p 0 TeXcolorgray 2818 32834 a(1.)p 0 TeXcolorgray
606 w(Opposite)256 b(Hackney)g(Community)h(College,)282
b(F)-82 b(alkirk)4580 34339 y(Street.)p 0 TeXcolorgray
2818 36777 a(2.)p 0 TeXcolorgray 606 w(Shoreditch)385
b(High)g(Street,)i(near)e(the)h(church.)1550 40562 y
Fd(1.2)1594 b(T)-146 b(uesday)555 b(social)f(evenings)1550
43268 y Fe(Where)440 b(people)f(hang)g(out)g(and)g(hack)f(on)h
(projects,)454 b(so-)1550 44774 y(cialise)386 b(and)h(collaborate.)455
b(Bring)387 b(beer)i(if)d(you)h(like.)456 b(Ev-)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 5 5
TeXDict begin 5 4 bop 0 TeXcolorgray 31305 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 73.725 17.22415 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(5)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -1550 7137 a Fe(ery)360
b(Tuesday)f(at)g(7:00pm-ish)g(til)g(whenever)g(people)h(go)-1550
8642 y(home,)492 b(generally)470 b(very)h(late.)705 b(Everyone)470
b(is)g(welcome,)-1550 10148 y(both)391 b(members)j(and)d(non-members.)
469 b(It)391 b(tends)h(to)g(be)g(a)-1550 11653 y(nice)385
b(mix)g(of)g(regulars,)g(irregulars)h(and)e(new)h(faces.)-1550
15850 y Fd(1.3)1594 b(Why?)p 0 TeXcolorgray 268 18619
a Fb(\017)p 0 TeXcolorgray 607 w Fe(Simply)364 b(to)h(take)f(a)h(look)e
(around,)368 b(see)e(the)f(Maker-)1481 20124 y(Bot,)385
b(Laser)h(Cutter)-133 b(,)386 b(etc.)451 b(and)384 b(have)h(a)g(chat.)p
0 TeXcolorgray 268 22933 a Fb(\017)p 0 TeXcolorgray 607
w Fe(Because)256 b(you)g(want)g(to)h(hack)e(on)i(projects)g(but)f
(don't)1481 24438 y(get)385 b(time.)p 0 TeXcolorgray
268 27247 a Fb(\017)p 0 TeXcolorgray 607 w Fe(Because)g(you)f(need)i
(help)e(with)h(something.)p 0 TeXcolorgray 268 30056
a Fb(\017)p 0 TeXcolorgray 607 w Fe(Because)442 b(you)g(want)g(to)h
(see)h(the)f(space)f(and)g(play)1481 31561 y(with)384
b(our)h(gear)h(before)f(becoming)g(a)g(member)-133 b(.)p
0 TeXcolorgray 268 34370 a Fb(\017)p 0 TeXcolorgray 607
w Fe(Because)471 b(we)h(have)f(tools)g(you)g(need)h(to)g(use)g(that)
1481 35876 y(you)384 b(don't)h(have)g(at)g(home.)p 0
TeXcolorgray 268 38685 a Fb(\017)p 0 TeXcolorgray 607
w Fe(Because)463 b(you)g(just)g(want)g(to)g(hang)f(out)i(with)e(like)
1481 40190 y(minded)385 b(people.)p 0 TeXcolorgray 268
42999 a Fb(\017)p 0 TeXcolorgray 607 w Fe(Because)303
b(you)f(want)g(to)i(get)f(involved)f(with)g(the)i(or-)1481
44504 y(ganisation)383 b(of)h(the)i(London)e(Hackspace.)p
0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 6 6
TeXDict begin 6 5 bop 0 TeXcolorgray -8161 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 73.725 17.48047 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(6)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fd(1.4)1594 b(Rules)1550 9859 y Fe(London)381 b(Hackspace)h(is)h(run)
f(entirely)h(by)f(its)h(members)1550 11364 y(and,)323
b(on)308 b(the)h(whole,)323 b(this)308 b(works)g(pretty)h(well.)424
b(As)309 b(hack)-21 b(-)1550 12870 y(ers)512 b(we)f(hate)g(making)f
(rules)h(almost)g(as)f(much)h(as)g(we)1550 14375 y(hate)603
b(following)e(them,)659 b(so)603 b(we)h(really)f(want)f(to)i(keep)1550
15881 y(the)499 b(number)f(of)h(rules)f(to)h(a)f(minimum.)790
b(W)-99 b(e)499 b(can)f(only)1550 17386 y(do)423 b(this)h(if)f(members)
i(and)e(visitors)h(observe)g(the)g(spirit)1550 18892
y({)385 b(not)f(just)h(the)g(letter)g({)g(of)g(these)g(rules;)g(they)g
(are)g(here)1550 20397 y(\014rstly)377 b(for)f(your)h(safety)-161
b(,)378 b(and)e(secondly)f(to)i(prevent)g(an-)1550 21903
y(noyance)384 b(to)h(other)h(users)f(of)g(the)h(space.)1550
25302 y Fc(Rule)462 b(Zero)p 0 TeXcolorgray 2818 27606
a Fe(0.)p 0 TeXcolorgray 606 w(Do)385 b(not)g(be)h(on)e(\014re.)1550
31005 y Fc(Safety)p 0 TeXcolorgray 2818 33309 a Fe(1.)p
0 TeXcolorgray 606 w(Don't)622 b(use)g(power)h(tools)e(unless)h(you've)
g(had)f(a)4580 34815 y(safety)385 b(brie\014ng)g(on)g(them)h(\014rst.)p
0 TeXcolorgray 2818 37401 a(2.)p 0 TeXcolorgray 606 w(Don't)257
b(defeat)f(or)i(hack)d(safety)i(features/equipment.)4580
38907 y(This)498 b(is)h(for)f(other)h(people's)g(safety)f(as)g(much)g
(as)4580 40412 y(yours.)p 0 TeXcolorgray 2818 42999 a(3.)p
0 TeXcolorgray 606 w(Check)257 b(the)g(wiki)e(for)i(instructions.)405
b(Read)257 b(the)f(warn-)4580 44504 y(ings.)449 b(If)385
b(in)f(doubt,)h(ask.)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 7 7
TeXDict begin 7 6 bop 0 TeXcolorgray 31305 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 73.725 17.22415 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(7)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -1550 7137 a Fc(Making)462
b(Decisions)p 0 TeXcolorgray -282 9425 a Fe(1.)p 0 TeXcolorgray
607 w(If)357 b(something)g(is)h(broken,)363 b(\014x)358
b(it;)367 b(don't)358 b(complain.)p 0 TeXcolorgray -282
11727 a(2.)p 0 TeXcolorgray 607 w(If)268 b(you're)h(doing)f(something)h
(major)-133 b(,)292 b(ask)268 b(the)i(mail-)1481 13233
y(ing)384 b(list)h(\014rst.)-1550 16437 y Fc(Etiquette)p
0 TeXcolorgray -282 18725 a Fe(1.)p 0 TeXcolorgray 607
w(Do)481 b(not)g(treat)h(the)f(Hackspace)g(like)f(your)h(home,)1481
20230 y(it)406 b(is)f(a)h(shared)h(space.)512 b(Sleeping)406
b(in)f(the)i(space)f(is)1481 21736 y(forbidden.)-1550
24940 y Fc(P)-36 b(ersonal)462 b(Items)p 0 TeXcolorgray
-282 27228 a Fe(1.)p 0 TeXcolorgray 607 w(Members)319
b(are)g(allowed)e(to)h(store)h(personal)f(items)1481
28733 y(in)392 b(the)h(space,)i(but)d(they)h(must)g(be)g(kept)g(in)f
(one)h(of)1481 30239 y(the)570 b(plastic)f(boxes,)616
b(labelled)569 b(with)g(your)g(name.)1481 31744 y(One)507
b(box)h(per)h(member)-133 b(.)819 b(Empty)508 b(boxes)g(may)g(be)1481
33250 y(recycled)385 b(for)g(other)h(members)h(if)d(needed.)p
0 TeXcolorgray -282 35552 a(2.)p 0 TeXcolorgray 607 w(Larger/more)258
b(items)g(may)e(be)h(allowed,)282 b(but)256 b(please)1481
37057 y(note)301 b(that)g(space)g(is)g(limited.)421 b(Y)-105
b(ou)301 b(must)g(email)g(the)1481 38563 y(mailing)396
b(list)i(\014rst,)404 b(and)397 b(items)i(should)e(be)i(clearly)1481
40068 y(labelled)372 b(as)i(yours,)i(and)d(with)g(the)g(date)h(they)g
(will)1481 41574 y(be)398 b(removed)h(by)-161 b(.)488
b(\(W)-99 b(e)399 b(have)f(Do)f(Not)h(Hack)g(stick)-21
b(-)1481 43079 y(ers)603 b(in)e(the)h(entrance)h(area.)1100
b(If)602 b(you)f(can't)h(\014nd)1481 44585 y(them,)386
b(ask)e(someone.\))p 0 TeXcolorgray 0 TeXcolorgray eop
end
%%Page: 8 8
TeXDict begin 8 7 bop 0 TeXcolorgray -8161 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 73.725 17.48047 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(8)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fc(Donating,)461 b(Loaning)g(or)h(Borrowing)g(Items)p
0 TeXcolorgray 2818 9486 a Fe(1.)p 0 TeXcolorgray 606
w(Carefully)483 b(consider)h(the)g(true)g(usefulness)f(of)h(an)4580
10991 y(item)324 b(before)g(bringing)e(it)h(to)h(the)f(space.)429
b(Disposal)4580 12497 y(requires)269 b(e\013ort)h(and)d(space)i(is)f
(limited.)410 b(Seek)270 b(per-)4580 14002 y(mission)385
b(for)g(large)g(items.)p 0 TeXcolorgray 2818 16803 a(2.)p
0 TeXcolorgray 606 w(If)607 b(you're)g(leaving)f(something)h(and)g(you)
f(would)4580 18309 y(rather)257 b(it)g(was)f(not)h(mercilessly)g
(ripped)f(apart,)283 b(please)4580 19814 y(label)385
b(it)g(accordingly)-161 b(.)p 0 TeXcolorgray 2818 22615
a(3.)p 0 TeXcolorgray 606 w(Likewise,)282 b(if)256 b(something)g(looks)
g(expensive)g(or)i(use-)4580 24121 y(ful)408 b(please)g(don't)h
(mercilessly)g(rip)f(it)h(apart)f(with-)4580 25626 y(out)385
b(asking)f(\014rst.)p 0 TeXcolorgray 2818 28427 a(4.)p
0 TeXcolorgray 606 w(Don't)589 b(remove)g(tools)g(from)g(the)g(space)f
(without)4580 29933 y(asking)384 b(the)h(mailing)f(list)h(\014rst.)1550
33602 y Fc(Tidiness)p 0 TeXcolorgray 2818 35951 a Fe(1.)p
0 TeXcolorgray 606 w(W)-82 b(orkbenches)256 b(should)f(be)i(completely)
g(clean)f(when)4580 37456 y(you)453 b(leave)h(-)g(be)g(considerate)g
(for)f(the)i(next)e(user)-133 b(.)4580 38962 y(Please)366
b(put)g(tools)g(back)f(where)i(you)e(found)g(them.)p
0 TeXcolorgray 2818 41763 a(2.)p 0 TeXcolorgray 606 w(Put)596
b(your)g(dirty)g(cups)g(and)f(plates)h(in)g(the)g(dish-)4580
43268 y(washer)346 b(before)g(leaving)e(the)i(space.)437
b(Don't)345 b(leave)4580 44774 y(them)386 b(in)e(the)i(sink.)p
0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 9 9
TeXDict begin 9 8 bop 0 TeXcolorgray 31305 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 73.725 17.48047 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(9)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray -282 7137
a Fe(3.)p 0 TeXcolorgray 607 w(Any)414 b(items)h(left)g(on)f(a)g
(workbench)g(overnight)g(be-)1481 8642 y(come)460 b(fair)f(game.)675
b(Put)459 b(your)h(stu\013)g(back)f(in)g(your)1481 10148
y(box.)p 0 TeXcolorgray -282 12629 a(4.)p 0 TeXcolorgray
607 w(If)365 b(you)g(have)g(engaged)g(in)g(any)g(waste)h(generating)
1481 14134 y(activity)371 b(\(e.g.)446 b(peeling)373
b(wires\),)i(hoover)e(the)g(spot.)p 0 TeXcolorgray -282
16615 a(5.)p 0 TeXcolorgray 607 w(Please)454 b(do)h(not)g(bring)f
(bikes)h(into)f(the)i(space)f(un-)1481 18121 y(less)498
b(you)f(are)i(working)e(on)h(them,)527 b(they)498 b(take)g(up)1481
19626 y(too)385 b(much)f(room.)-1550 22914 y Fc(Disposal)p
0 TeXcolorgray -282 25203 a Fe(1.)p 0 TeXcolorgray 607
w(If)349 b(you)g(think)g(something)g(should)g(be)h(thrown)f(out,)1481
26708 y(put)457 b(it)h(in)g(the)g(outgoing)e(trash)i(box.)668
b(T)-43 b(wo)458 b(weeks)1481 28214 y(later)385 b(the)g(box)g(will)f
(go)h(in)g(the)g(skip.)p 0 TeXcolorgray -282 30695 a(2.)p
0 TeXcolorgray 607 w(If)e(something)f(is)i(too)f(big)g(to)h(\014t)g(in)
f(the)g(trash)h(box,)1481 32200 y(you)g(should)g(probably)g(post)h(to)h
(the)f(list)g(about)f(it.)p 0 TeXcolorgray -282 34681
a(3.)p 0 TeXcolorgray 607 w(If)467 b(you)g(want)g(to)h(throw)g
(something)f(away)g(which)1481 36186 y(looks)389 b(useful,)i(make)f
(sure)h(the)f(mailing)f(list)g(is)i(in-)1481 37692 y(formed)385
b(well)g(in)f(advance.)-1550 40980 y Fc(P)-36 b(enalties)-1550
43268 y Fe(If)351 b(you)g(continually)e(annoy)h(or)i(endanger)g(others)
g(by)f(ig-)-1550 44774 y(noring)448 b(these)h(rules,)465
b(the)449 b(trustees)g(have)f(the)h(right)f(to)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 10 10
TeXDict begin 10 9 bop 0 TeXcolorgray -9270 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 83.7445 17.48047 .5
Frame  gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(10)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fe(impose)449 b(sanctions)e(up)h(to)h(stripping)f(you)f(of)i(member-)
1550 8642 y(ship)585 b(and)g(banning)f(you)h(from)h(the)h(space.)1052
b(It)586 b(is)f(not)1550 10148 y(something)384 b(they)i(want)e(to)h(do)
-21 b(.)1550 25950 y Fd(1.5)1594 b(Governance)1550 30633
y Fe(London)460 b(Hackspace)i(is)f(run)h(by)g(its)g(members.)681
b(If)462 b(you)1550 32138 y(have)572 b(an)g(opinion)f(or)j(want)e(to)h
(raise)g(an)f(issue,)620 b(then)1550 33644 y(please)376
b(do)g(-)g(as)h(a)f(subscribing)f(member)j(your)e(voice)g(is)1550
35149 y(as)385 b(important)g(as)g(anyone)f(else's.)3432
38752 y(London)401 b(Hackspace)h(Ltd.'s)h(ultimate)g(governance)1550
40257 y(lies)458 b(with)g(the)h(Board)f(of)h(Trustees,)479
b(who)457 b(are)j(also)e(the)1550 41763 y(directors)463
b(of)f(the)g(company)-161 b(.)680 b(These)464 b(are)f(elected)g(reg-)
1550 43268 y(ularly)-161 b(,)398 b(with)d(the)h(longest-serving)f
(third)h(of)g(the)g(Board)1550 44774 y(required)386 b(to)f(stand)g(for)
g(re-election)g(every)h(year)-133 b(.)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 11 11
TeXDict begin 11 10 bop 0 TeXcolorgray 31305 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 83.7445 17.22415 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(11)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -1550 7137 a Fc(Current)462
b(T)-97 b(rustees)-886 9546 y Fa(Name)11768 b(Username)1351
b(Appointed)-886 11051 y Fe(Russ)385 b(Garrett)7852 b(russss)4372
b(2010-07-27*)-886 12557 y(Charles)386 b(Y)-94 b(arnold)5909
b(solexious)2558 b(2010-07-27)-886 14062 y(Robert)386
b(Leverington)3681 b(roberthl)3183 b(2010-07-27)-886
15568 y(Andy)385 b("Bob")f(Brockhurst)1328 b(b3cft)5058
b(2010-07-27)-886 17073 y(Jonty)385 b(W)-105 b(areing)7056
b(jontyw)4123 b(2011-08-06*)-886 18579 y(Martin)385 b(Dittus)7394
b(Martind)3245 b(2011-08-06)-886 20084 y(Mark)385 b(Steward)6902
b(ms7821)3365 b(2011-08-06)-886 21590 y(Philip)384 b(Roy)9466
b(cepmender)1329 b(2011-08-06)332 23546 y(*)385 b(re-appointed)-1550
29530 y Fc(Directors')462 b(Responsibilities)-1550 32261
y Fe(All)281 b(UK)f(companies)g(must)g(have)h(have)f(a)g(board)g(of)h
(direc-)-1550 33766 y(tors,)320 b(but)301 b(directorship)h(of)f(London)
g(Hackspace)g(Ltd.)422 b(is)-1550 35271 y(primarily)265
b(a)g(symbolic)g(role.)410 b(W)-99 b(e)266 b(want)f(trustees)h(to)g
(sim-)-1550 36777 y(ply)412 b(make)g(sure)h(that)f(the)g(company)g(is)g
(doing)f(what)h(its)-1550 38282 y(members)387 b(want.)332
40257 y(In)370 b(order)h(to)g(do)f(that,)j(there)f(are)f(regular)f
("talk)f(to)i(a)-1550 41763 y(Trustee")366 b(sessions)e(where)h(you)f
(can)g(raise)h(any)e(issues,)-1550 43268 y(or)410 b(ask)f(for)h(help,)
415 b(in)409 b(con\014dence.)523 b(Please)410 b(take)f(advan-)-1550
44774 y(tage)386 b(of)e(them!)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 12 12
TeXDict begin 12 11 bop 0 TeXcolorgray -9270 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 83.7445 17.48047 .5 Frame
 gsave 0.8 0 0  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(12)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fd(1.6)1594 b(Events)1550 9843 y Fe(Google)517 b(Calendar)f(\(see)i
(the)f(wiki)f(for)h(details\))f(is)h(our)1550 11348 y(canonical)378
b(list)i(of)g(events,)i(but)e(here's)h(a)f(selection.)448
b(All)1550 12854 y(events)471 b(listed)g(are)h(at)f(the)g(space)g
(itself)f(unless)h(other-)1550 14359 y(wise)385 b(noted.)1550
17582 y Fc(Recurring)p 0 TeXcolorgray 3368 19870 a Fb(\017)p
0 TeXcolorgray 606 w Fe(Every)320 b(Monday)-161 b(,)332
b(19:30)320 b(-)g(Gadget)f(Geeks)h(viewing)4580 21375
y(in)385 b(quiet)g(room)p 0 TeXcolorgray 3368 23718 a
Fb(\017)p 0 TeXcolorgray 606 w Fe(Every)508 b(Tuesday)-161
b(,)538 b(19:00)509 b(-)e(W)-99 b(eekly)507 b(public)f(meet-)4580
25223 y(ings)p 0 TeXcolorgray 3368 27565 a Fb(\017)p
0 TeXcolorgray 606 w Fe(Every)451 b(W)-99 b(ednesday)-161
b(,)468 b(19:30)453 b(-)e(Biohacking)d(catch-)4580 29071
y(up)p 0 TeXcolorgray 3368 31413 a Fb(\017)p 0 TeXcolorgray
606 w Fe(Every)385 b(W)-99 b(ednesday)-161 b(,)386 b(19:30)g(-)f(Mind)f
(Hackers)p 0 TeXcolorgray 3368 33755 a Fb(\017)p 0 TeXcolorgray
606 w Fe(Every)569 b(Thursday)-161 b(,)615 b(19:00)570
b(-)f(Music)f(Hack)h(Space)4580 35260 y(meetings)p 0
TeXcolorgray 3368 37602 a Fb(\017)p 0 TeXcolorgray 606
w Fe(3rd)257 b(Thursday)-161 b(,)283 b(19:30)257 b(-)g(OneClickOrgs)e
(hack)h(evening)p 0 TeXcolorgray 3368 39945 a Fb(\017)p
0 TeXcolorgray 606 w Fe(1st)375 b(Saturday)-161 b(,)377
b(13:00)f(-)f(OneClickOrgs)f(hack)g(day)p 0 TeXcolorgray
3368 42287 a Fb(\017)p 0 TeXcolorgray 606 w Fe(2nd)301
b(Saturday)-161 b(,)319 b(15:00)302 b(-)g(Lockpicking)d(sports)j(ses-)
4580 43792 y(sion)p 0 TeXcolorgray 0 TeXcolorgray eop
end
%%Page: 13 13
TeXDict begin 13 12 bop 0 TeXcolorgray 31305 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 83.7445 17.48047 .5
Frame  gsave 0 0 0.85  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(13)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 9556 15439 a Fh(Chapter)507
b Fg(2)p -1550 18029 30553 45 v 4340 21633 a Ff(K)-48
b(eeping)959 b(the)3496 24954 y(Hackspace)h(in)8905 28275
y(Shape)p -1550 30397 V -1550 37246 a Fe(According)300
b(to)h(our)f(rules)h(you're)g(expected)g(to)f(clean)g(up)-1550
38752 y(your)288 b(workspace)f(after)i(you're)f(done.)417
b(Beyond)288 b(that)f(we)-1550 40257 y(ask)397 b(that)f(you)g(help)h
(us)f(maintain)g(the)h(space.)485 b(W)-99 b(e)397 b(have)-1550
41763 y(a)540 b(lot)f(of)g(members)i(that)f(make)f(constant)g(use)g(of)
h(our)-1550 43268 y(facilities,)381 b(and)g(it)g(adds)g(up)g(quickly)
-161 b(.)447 b(A)381 b(few)g(good)g(rules)-1550 44774
y(of)k(thumb:)p 0 TeXcolorgray 12955 47814 a(13)p 0 TeXcolorgray
eop end
%%Page: 14 14
TeXDict begin 14 13 bop 0 TeXcolorgray -9270 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 83.7445 17.22415 .5 Frame
 gsave 0 0 0.85  setrgbcolor  1. .setopacityalpha  fill  grestore gsave
0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(14)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
3368 7137 a Fb(\017)p 0 TeXcolorgray 606 w Fe(Strive)325
b(to)f(do)g(one)f(maintenance)g(task)h(every)g(time)4580
8642 y(you)486 b(visit.)753 b(Y)-105 b(ou're)488 b(already)e(helping)f
(if)h(you)g(only)4580 10148 y(bring)567 b(out)h(the)g(garbage)g(or)g
(wipe)g(a)f(few)h(desks)4580 11653 y(clean.)p 0 TeXcolorgray
3368 14340 a Fb(\017)p 0 TeXcolorgray 606 w Fe(Strive)423
b(to)g(leave)f(our)g(facilities)f(in)h(a)g(better)h(state)4580
15846 y(than)384 b(you)h(found)f(them.)p 0 TeXcolorgray
3368 18532 a Fb(\017)p 0 TeXcolorgray 606 w Fe(If)528
b(you)g(don't)h(know)e(how)h(things)g(work)g(and)g(the)4580
20038 y(wiki)347 b(doesn't)i(help)f(then)g(just)h(ask)f(around,)355
b(in)348 b(the)4580 21543 y(space)322 b(or)h(on)f(IRC)-43
b(.)322 b(Then)h(update)f(the)h(wiki)d(for)j(the)4580
23049 y(next)385 b(person.)1550 26574 y Fc(W)-115 b(aste)461
b(Disposal)1550 28899 y Fa(Regular)423 b(W)-105 b(aste)1550
31224 y Fe(This)369 b(includes)f(industrial)g(waste)h(\(electronics,)j
(metal,)1550 32730 y(stone,)d(wood,)f(...\))443 b(as)365
b(long)e(as)i(it)f(is)g(not)g(toxic.)443 b(W)-99 b(e)365
b(have)1550 34235 y(set)445 b(up)g(a)g(few)f(bins)g(in)h(various)f
(places.)628 b(Once)445 b(they're)1550 35741 y(full)555
b(take)h(out)h(the)g(bag,)599 b(replace)557 b(it)g(with)e(a)i(new)f
(one)1550 37246 y(\(you)538 b(can)h(\014nd)g(them)h(under)g(the)f
(kitchen)g(sink\),)577 b(and)1550 38752 y(dispose)459
b(of)g(the)h(full)e(bag.)673 b(There)461 b(are)f(two)f(black)g(bins)
1550 40257 y(in)344 b(the)h(Cremer)j(Business)c(Centre)i(parking)e
(space)h(out-)1550 41763 y(side)565 b(our)g(house,)610
b(to)566 b(your)f(left)g(when)f(you)h(enter)h(the)1550
43268 y(main)352 b(gate.)439 b(There)355 b(are)e(two)g(more)h(half)-43
b(-way)350 b(down)i(the)1550 44774 y(carpark.)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 15 15
TeXDict begin 15 14 bop 0 TeXcolorgray 31305 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 83.7445 17.22415 .5
Frame  gsave 0 0 0.85  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(15)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -1550 7137 a Fa(Recycling)-1550
9427 y Fe(W)-99 b(e've)555 b(acquired)e(some)h(bright)f(orange)g(skips)
g(in)g(the)-1550 10932 y(business)547 b(centre)i(-)e(these)i(are)f
(marked)g(as)f(recycling)-1550 12438 y(skips.)488 b(There)399
b(are)f(also)f(fewer)i(normal)e(skips)g(than)h(be-)-1550
13943 y(fore)382 b(so)g(recycling)f(is)h(now)f(encouraged.)448
b(As)383 b(far)f(as)f(we)-1550 15449 y(can)k(tell,)g(we)g(can)g
(recycle:)p 0 TeXcolorgray 268 18269 a Fb(\017)p 0 TeXcolorgray
607 w Fe(Plastics)f(\(recyclable)g(ones\))p 0 TeXcolorgray
268 20785 a Fb(\017)p 0 TeXcolorgray 607 w Fe(Cans)h(&)g(foil)p
0 TeXcolorgray 268 23300 a Fb(\017)p 0 TeXcolorgray 607
w Fe(Glass)g(bottles)p 0 TeXcolorgray 268 25816 a Fb(\017)p
0 TeXcolorgray 607 w Fe(Cardboard)g(&)g(paper)332 28636
y(There)394 b(should)c(be)j(a)f(bin)f(labelled)h(in)f(the)h(space)h
(for)-1550 30142 y(recycling)383 b(-)g(please)h(use)f(it.)449
b(Also,)385 b(please)e(empty)h(it)g(out)-1550 31647 y(regularly)-161
b(.)-1550 34957 y Fc(Cleaning)-1550 37246 y Fe(Most)257
b(cleaning)e(utensils)h(can)g(be)h(found)f(under)g(the)h(kitchen)-1550
38752 y(sink.)624 b(\(See)444 b(also)f(the)h("re-stocking)e(supplies")g
(section)-1550 40257 y(further)452 b(below)-144 b(.\))649
b(W)-99 b(e)452 b(have)f(a)h(small)f(dishwasher)g(next)-1550
41763 y(to)396 b(the)g(kitchen)f(sink.,)j(and)d(several)i(vacuum)d
(cleaners)-1550 43268 y(which)337 b(normally)g(live)g(in)g(the)i
(workshop.)432 b(Supplies)338 b(are)-1550 44774 y(currently)277
b(stored)g(under)g(the)g(kitchen)e(sink,)298 b(and)276
b(above)p 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 16 16
TeXDict begin 16 15 bop 0 TeXcolorgray -9270 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 83.7445 17.48047 .5
Frame  gsave 0 0 0.85  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(16)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1550 7137
a Fe(the)524 b(black)f(fridge.)867 b(If)524 b(we)g(run)g(out)g(of)g
(anything)e(\(e.g.)1550 8642 y(kitchen)564 b(gloves)h(go)g(quite)g
(quickly\))e(it)i(would)f(be)i(ap-)1550 10148 y(preciated)358
b(if)f(you)g(bought)g(more.)442 b(The)359 b(Hackspace)e(can)1550
11653 y(reimburse)463 b(you)e(if)g(needed)i(-)f(talk)f(to)h(a)g
(trustee)h(about)1550 13159 y(that.)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 17 17
TeXDict begin 17 16 bop 0 TeXcolorgray 31305 1907 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 6.8 neg 83.7445 17.22415 .5 Frame
 gsave 0.8 0.31999 0  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1 TeXcolorgray Fi(17)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 9556 15439 a Fh(Chapter)507
b Fg(3)p -1550 18029 30553 45 v -1401 21633 a Ff(Quick-reference)959
b(QR)9225 24954 y(codes)p -1550 26543 V -1550 32188 a
Fe(The)386 b(main)f(hackspace)e(page)332 33986 y(The)j(wiki)332
35784 y(How)f(to)g(get)h(to)f(the)h(Space)332 37582 y(The)g(mailing)e
(list)332 39380 y(Announcements)h(mailing)e(list)332
41178 y(Infrastructure)i(mailing)f(list)332 42976 y(wi\014)332
44774 y(VCard)i(with)e(all)h(the)g(space)g(contact)g(details)p
0 TeXcolorgray 12955 47814 a(17)p 0 TeXcolorgray eop
end
%%Page: 18 18
TeXDict begin 18 17 bop 0 TeXcolorgray -9270 1935 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.8 SLW 1  setgray  0. true 6.8 neg 7.00447 neg 83.7445 17.48047 .5
Frame  gsave 0.8 0.31999 0  setrgbcolor  1. .setopacityalpha  fill
 grestore gsave 0.8 SLW 1  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 1 TeXcolorgray 6299 w Fi(18)p
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 3432 13919
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.  1 1 0.0
 0.0  translate scale rotate 0 0 moveto (WIFI:T:WPA;S:LondonHackspace;P:DFDE595F79;;)
(eclevel=M width=1.0 height=1.0) /qrcode /uk.co.terryburton.bwipp findresource
exec grestore  end
 
@endspecial 17439 x @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.  1 1 0.0
 0.0  translate scale rotate 0 0 moveto (MECARD:\ N:London Hackspace;\ TEL:+442076135391;\ ADR:Laboratory 24, Unit 24, 37 Cremer Street, London, E2 8HD, GB;\ URL:https://london.hackspace.org.uk/;\ URL:http://wiki.london.hackspace.org.uk/view/London_Hackspace;;)
(eclevel=M width=2.0 height=2.0) /qrcode /uk.co.terryburton.bwipp findresource
exec grestore  end
 
@endspecial 9439 x @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.  1 1 0.0
 0.0  translate scale rotate 0 0 moveto (geo:51.53034,-0.07660?q=51.53034,-0.07660(London+Hackspace))
(eclevel=M width=1.0 height=1.0) /qrcode /uk.co.terryburton.bwipp findresource
exec grestore  end


@endspecial 0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
